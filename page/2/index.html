<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>孙利峰的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="孙利峰的技术博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="孙利峰的技术博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孙利峰的技术博客">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="孙利峰的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">孙利峰的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天幕红尘</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS-抽屉效果三方库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/24/iOS-抽屉效果三方库/" class="article-date">
  <time datetime="2015-09-24T08:53:43.000Z" itemprop="datePublished">2015-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/24/iOS-抽屉效果三方库/">iOS_抽屉效果三方库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>现对当下比较火的几大热门抽屉效果的第三方库进行了调研。代码全部选自github</p>
<p>一.RESideMenu<br><a href="https://github.com/romaonthego/RESideMenu" target="_blank" rel="external">https://github.com/romaonthego/RESideMenu</a></p>
<p>支持iOS7+</p>
<p>优点：</p>
<p>1.里面的文件较少，不需要使用cocoapods即可运行。</p>
<p>2.里面自定义API也比较多，可以设置变小的抽屉效果或者不变小。</p>
<p>3.里面有两个事例程序，一个是纯手码，一个是Storyboard得。可见作者也非常喜欢IB开发，此框架用IB开发应该可以完美兼容。</p>
<p>4.可以使用手势拖来拖去。</p>
<p>5.项目里各个文件不需要继承，导入头文件就行。<br>缺点：</p>
<p>1.左边显示的菜单可选项是固定的几个button，暂时想把左边换成tableView还不知道可不可行。（现已解决，可以改）</p>
<p>2.不能实现状态栏右移。（董铂然博客园）</p>
<p>3.暂时没找到两边控制器的占比怎么自定义。（现已解决，可以改）</p>
<p>二.Mutual Mobile Drawer Controller<br><a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="external">https://github.com/mutualmobile/MMDrawerController</a></p>
<p>示例程序内存跑到15M<br>优点。</p>
<p>1.里面有9个文件比上面的略多。但也还凑合吧</p>
<p>2.虽然没有缩小抽屉的动画，但是在平向切入时，leftVC有几种转场动画可选。</p>
<p>3.左边已经是tableVIew。</p>
<p>4.自定义的接口挺多。</p>
<p>5.作者最近还在更新</p>
<p>缺点。</p>
<p>1.相比于上面的，这个项目是用纯手码写的。</p>
<p>2.现在有一个抽搐的小bug，不过感觉我应该能改好。</p>
<p>3.在设置左右占比时，用的是固定数值，这样的话4s和6的手机界面显示是不一样的。（应该能改成百分比）</p>
<p>4.依旧状态栏不能右移。</p>
<p>5.项目内各个文件需要继承工具类。</p>
<p>三.PPRevealSideViewController<br><a href="https://github.com/ipup/PPRevealSideViewController" target="_blank" rel="external">https://github.com/ipup/PPRevealSideViewController</a><br>iOS6+</p>
<p>测试效果一般。</p>
<p>优点：</p>
<p>1.支持iOS6</p>
<p>2.基本的自定义也都是支持的。</p>
<p>3.页面大部分是Storyboard搭建。</p>
<p>4.导入头文件，而不是继承。</p>
<p>缺点：</p>
<p>1.也是支持iOS6，导致界面始终控制的必须有一个黑条。并且在切换的时候太低端了。</p>
<p>2.除了自己的PPRSVC，还必须使用cocoapods依赖了另一个库，PPHelpMe。这个库有29个文件。</p>
<p>3.手势支持做的不怎么好，能拉出来但不能拉回去。（董铂然博客园）<br>四.SWRevealViewController<br><a href="https://github.com/John-Lluch/SWRevealViewController" target="_blank" rel="external">https://github.com/John-Lluch/SWRevealViewController</a><br>非常干净的界面也没有图片，为什么内存会跑到28M?</p>
<p>iOS7+</p>
<p>测试的效果一般</p>
<p>优点：</p>
<p>1.使用的是导入头文件，而不是继承。</p>
<p>2.非常干净，基本只有核心功能，只有两个文件一个.h一个.m</p>
<p>3.可以实现三层抽屉。</p>
<p>4.支持手势的各种操作。</p>
<p>5.里面使用了不少xib文件。</p>
<p>6.左右占比控制的很好。<br>缺点：</p>
<p>1.能够自定义的接口不是很多。（但改源码的话应该也不会很难）</p>
<p>2.横屏时的屏幕适配需要再改进下。</p>
<p>2.貌似没有缺点了。</p>
<p>五.ECSlidingViewController （现在用的）<br><a href="https://github.com/ECSlidingViewController/ECSlidingViewController" target="_blank" rel="external">https://github.com/ECSlidingViewController/ECSlidingViewController</a></p>
<p>支持iOS5</p>
<p>测试效果一般。</p>
<p>优点：</p>
<p>1.除了星多，貌似没有优点（和上面几个相比的话）<br>缺点：</p>
<p>1.用了13个文件，但是貌似只是实现了最基本的抽屉效果功能。</p>
<p>2.缩在右边时还向右边拉，会产生bug。</p>
<p>3.用的是继承。每个文件都要继承。</p>
<p>4.去年8月以后就停止更新了。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/24/iOS-抽屉效果三方库/" data-id="cipjqxxjh000qf4s6nu9o5fa8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-对UITableView三种计算动态行高的方法分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/09/iOS-对UITableView三种计算动态行高的方法分析/" class="article-date">
  <time datetime="2015-09-09T08:47:25.000Z" itemprop="datePublished">2015-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/09/iOS-对UITableView三种计算动态行高的方法分析/">iOS_对UITableView三种计算动态行高的方法分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>tableView是一个神奇的东西，可以这么说，就算是一个初学者如果能把tableView玩的很6，那编一般的iOS的需求都问题不大了。tableView是日常开发中用烂了的控件，但是关于tableView中的自定义cell的动态行高，还是有一些玄机的。笔者本次主要是因为预估行高的方法的问题作为了一个契机顺带写了此文对几种动态行高方法的分析。</p>
<p>如果你不是在董铂然博客园看到本文，请点击查看原文。</p>
<p>旧方法<br>现在常规的动态行高的计算方法还是用</p>
<p>[str boundingRectWithSize:size options:NSStringDrawingUsesLineFragmentOrigin attributes:attrs context:nil].size<br>这其中需要先传入一个最大尺寸和一个属性字典，特殊的格式要求都写在属性字典中。</p>
<p>NSDictionary *attrs = @{NSFontAttributeName : font};<br>整个流程的基本思想大概就是：用一个字符串对象来调用此方法，中间需要传入一个属性字典来告知字体和样式，然后根据字符串长度的多少来算出应该给多大的frame。前面传进的size一般可以设置最大宽度。 此方法一般写成分类便于调用。</p>
<p>#import “NSString+Size.h”</p>
<p>@implementation NSString (Size)</p>
<p>/**</p>
<ul>
<li>类方法计算size大小<br>*/</li>
</ul>
<ul>
<li>(CGSize)sizeWithString:(NSString <em>)str andFount:(UIFont </em>)font andMaxSize:(CGSize)size<br>{<br>NSDictionary *attrs = @{NSFontAttributeName : font};<br>return [str boundingRectWithSize:size options:NSStringDrawingUsesLineFragmentOrigin attributes:attrs context:nil].size;<br>}</li>
</ul>
<p>/**</p>
<ul>
<li>对象方法计算size大小<br>*/</li>
</ul>
<ul>
<li>(CGSize)sizeWithFount:(UIFont <em>)font andMaxSize:(CGSize)size;<br>{<br>NSDictionary </em>attrs = @{NSFontAttributeName : font};<br>return [self boundingRectWithSize:size options:NSStringDrawingUsesLineFragmentOrigin attributes:attrs context:nil].size;<br>}<br>@end<br>这些方法从字面上看也比较容易理解。</li>
</ul>
<p>调用时的代码基本就是取到一个字符串，传入一个font和一个最大size，如下把宽设置成了270就是最大宽度为270高度往下顺延的话就把高度写成MAXFLOAT</p>
<p>NSString *text = _message.text;<br>CGSize textSize = [text sizeWithFount:[UIFont systemFontOfSize:14] andMaxSize:CGSizeMake(270, MAXFLOAT)];<br>然后在frame中取到最下面一个空间的maxY，从而让每一个cell在set方法中就得到自己的行高 ，然后通过cell的类方法返回。</p>
<p>新方法<br>随着iOS8的自动布局和Interface builder越来越成熟，逐渐衍生出了一种先用storyboard或xib界面再算自定义行高的方法。</p>
<p>这种方法一般需要先搭建一个图形化界面。如下图大概搭一个比较复杂的cell。</p>
<p>首先可以清晰的看出，用IB搭建看上去很快就能搭建完毕，并且有的图片或是view的背景设置了之后能看出界面大概的感觉。这里需要注意的就是label设置约束的方法，普通控件一般都要设置四个约束才能固定位置，label和button只设置两个约束（只需要写固定位置的两条约束，不需要写自身宽高的约束）也不会报错，但是需要在editor中设置sizeToFit，这样可以根据字数自动给你分配一个控件的大小。</p>
<p>一般评论类的label肯定都是字数比较多的，这时2条约束就不够了需要再设置一个最大宽度的约束，如图1我设置的方法是，把评论label与左右边界的间隙给设定了，这个在IB中叫Leading（前）和Training（后），高的约束我们没有写如果字数超过了一行他就会自己往下顺延。 这么写相较于把宽度约束写死的好处是会自动根据屏幕适配不管屏幕多大都是左右空出若干像素。这样做也有局限性，就是假设给这个label设置一个背景色，如果字数就5个字背景色也会延伸到一整行。如果QQ聊天页面也这样做，不管是几个字都是一整行的聊天气泡那会很丑。于是有了一种少则背景也少，多也不超过最大宽度的做法，就是设置label的width的less than来设置最大宽度。这么做如果字数不足一行的话，约束也会自动缩到与label长度匹配。</p>
<p>如果这个页面用纯手码写，可想而知会非常麻烦。</p>
<p>用IB页面做自定义行高的计算方法也更简单。也就是里面模型的set方法正常写，给自己的UI控件赋值。然后在tableView的行高方法heightForRow中，先给cell的模型赋值，然后再使用一次</p>
<p>[cell layoutIfNeeded];<br>他会自动根据填进去数值来布局，然后我们直接在这个方法中返回最下面一个控件的bottom位置+若干间隙，以此来作为行高即可。</p>
<p>真正的布局其实也就是用了这一行代码，并且可以做到屏幕适配不用if判断各种frame。但这样写也有一些问题，首先就是这么写从结构上来看不合理。这个行高方法中不应该写这些赋值语句。官方还是其他大神说不合理的原因，应该是这个方法应该仅仅是用来算出行高并显示的，会调用多次，如果在这里赋值性能会很差。这么说有道理，把这里面的每行代码都看一遍，能看出性能较差的方法主要就是这两行：1.给cell里模型赋值  2.layoutIfNeed 。如果调用多次这个方法那这两行也会执行多次，所以这应该是不科学的。　　我实际的做法是在其中设置一个行高缓存字典，并且找一个肯定不会重复的标识来做key值。每一行cell计算行高前都先拿自己的id去行高缓存字典里取一下看有没有值，如果有则直接返回对应的value，如果没有再计算。这样可以使这性能比较差得两行代码只执行一次。达到优化效果。</p>
<p>MTFBNoReplyCell *feedbackNoreplyCell = [MTFBNoReplyCell cell];</p>
<p>NSString *thisId =[NSString stringWithFormat:@”%d”, feedbackModel.feedbackid];</p>
<p>//            MTLog(@”%@”,[self.cellHeightCache valueForKey:thisId]);<br>CGFloat cacheHeight = [[self.cellHeightCache valueForKey:thisId] doubleValue];<br>if (cacheHeight) {<br>//            MTLog(@”返回缓存的行高”);<br>return cacheHeight;<br>}<br>//            MTLog(@”耗性能的行高”);<br>feedbackNoreplyCell.feedbackDetailModel = feedbackModel;<br>[feedbackNoreplyCell layoutIfNeeded];</p>
<p>[self.cellHeightCache setValue:@(feedbackNoreplyCell.replyBtn.bottom+16) forKey:thisId];</p>
<p>return feedbackNoreplyCell.replyBtn.bottom+16;<br>大概的思想如上所示。 如果这个tableView的数据不会随时改变较为固定的话，可以把取到的模型作为value以indexpath.row为key存一个缓存字典这样也能优化一些。行高方法里取过了，cellForRow就可以直接用了。</p>
<p>预估行高方法<br>这里我想重点说一下这个预估行高的方法estimatedHeightForRowAtIndexPath 。这个方法可能大部分人一说到这个，就说这个方法好啊，预估行高方法可以减少heightForRow的调用次数，使得性能达到优化。 孰不知实际运用中是存在着一定问题的。</p>
<p>就拿整个tableView来说 他是继承自scrowView的，scrowView能够滚动是因为它有contentSize。tableView在初次加载的时候也需要算出自己的contentSize（而且会算不止一次），也就是说需要调一下所有的行高方法然后自己内部给他累加一下算出整个contentSize。如果在行高方法里设置一个打印会看到方法会调用很多次。这时如果有一个预估方法return 100。那它就能很快算出总值了。就会减少行高方法的调用，在实际用到某一行时再调用。</p>
<p>但是可能会出现如下左图的问题。</p>
<p>问题的原因就是，一开始预估方法给每行预估了一个行高，然后后面实际加载的行高与预估的行高不合时，会出现cell上下的“窜动”给人卡卡的感觉。对此我的思想是，如果是动态的且cell的复杂度较高，行与行之间差距大的时候，就直接不要写预估行高方法了吧，让他自己算吧哪怕多调用几次，毕竟上面已经写过缓存行高字典了，性能姑且是可以hold住了，并且不会出现“窜动”情况。如右图所示。</p>
<p>但是如果是固定行高有一种或是三种不同的cell，行高分别是120，150，200。你在预估行高了写个return 150。遇到行高与预估不等时，却也不会出现“窜动”。我推测应该是estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可。</p>
<p>关于上面行高的新方法和旧方法的对比，我的总结是：首先新方法肯定性能上是比旧方法要差一些的。具体体现在两个方面，1是在IB页面开发的东西，程序一启动就会全部加载进内存由系统托管，以至于有的界面你已经把导航控制器的栈顶控制器给pop了，发现内存还没有下降。2是新方法和旧方法有一个本质的区别，旧方法是直接算，算你需要多大的尺寸就告诉你，新方法则是先强制布局然后看你占了多大的尺寸再告诉你，这两者一对比，新方法就是多了一个强制布局的过程，这肯定是会对性能造成一定影响的，那具体影响多少？关于滑动计算行高我还不知道有什么可以明确一个数据的对比，我只能用肉眼看屏幕的滑动来区分对比，我的感觉就是基本没差别，如果要说有的话新方法可能会非常轻微的卡顿，换而言之就是同一个页面，旧方法编完需要10小时，新方法编完需要3小时，但是新方法的性能略差于旧方法。就看你自己怎么衡量了。当然非常庞大的项目还是建议用旧方法，毕竟一点一点的“略差于”积累在一起就是很差了。</p>
<p>关于iOS8新的行高特性<br>首先是有了一个新的用法。写在viewdidload里</p>
<p>self.tableView.estimatedRowHeight = 50.0f;<br>self.tableView.rowHeight = UITableViewAutomaticDimension;<br>这就没什么好说的了，苹果自己帮你把动态行高计算了，所有乱七八糟的都不用管了。 但是暂时说这些基本没用，因为现在还看不到哪个公司的项目不适配iOS7，就算出了iOS9感觉也不会让你直接适配iOS8的，iOS7还会存在相当长一段时间，毕竟以后新系统版本改变应该都不会有iOS6到7变化那么大了，除非啥时候苹果总设计师乔纳森伊夫下台了。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/09/iOS-对UITableView三种计算动态行高的方法分析/" data-id="cipjqxxiv000if4s61kp3uipt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-关于XMPP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/24/关于XMPP/" class="article-date">
  <time datetime="2015-08-24T08:59:30.000Z" itemprop="datePublished">2015-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/24/关于XMPP/">关于XMPP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>xmpp整理笔记：聊天信息的发送与显示  <a href="http://www.cnblogs.com/dsxniubility/p/4307073.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/4307073.html</a></p>
<p>xmpp整理笔记：环境的快速配置(附安装包)  <a href="http://www.cnblogs.com/dsxniubility/p/4304570.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/4304570.html</a></p>
<p>xmpp整理笔记：xmppFramework框架的导入和介绍  <a href="http://www.cnblogs.com/dsxniubility/p/4307057.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/4307057.html</a></p>
<p>xmpp整理笔记：用户网络连接及好友管理 <a href="http://www.cnblogs.com/dsxniubility/p/4307066.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/4307066.html</a></p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/08/24/关于XMPP/" data-id="cipjqxxk1000xf4s66arqtp4f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-多线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/03/iOS-多线程/" class="article-date">
  <time datetime="2015-07-03T09:04:49.000Z" itemprop="datePublished">2015-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/03/iOS-多线程/">iOS_多线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>本文是对以往学习的多线程中知识点的一个整理。</p>
<p>多线程中的队列有：串行队列，并发队列，全局队列，主队列。</p>
<p>执行的方法有：同步执行和异步执行。那么两两一组合会有哪些注意事项呢？</p>
<p>如果不是在董铂然博客园看到这边文章请 点击查看原文</p>
<p>提到多线程，也就是四种，pthread，NSthread，GCD，NSOperation  </p>
<p>其中phtread是跨平台的。GCD和NSOperation都是常用的，后者是基于前者的。</p>
<p>但是两者区别：GCD的核心概念是将一个任务添加到队列，指定任务执行的方法，然后执行。 NSOperation则是直接将一个操作添加到队列中。</p>
<ol>
<li><p>开不开线程，取决于执行任务的函数，同步不开，异步开。</p>
</li>
<li><p>开几条线程，取决于队列，串行开一条，并发开多条(异步)</p>
</li>
<li><p>主队列：  专门用来在主线程上调度任务的”队列”，主队列不能在其他线程中调度任务！</p>
</li>
<li><p>如果主线程上当前正在有执行的任务，主队列暂时不会调度任务的执行！主队列同步任务，会造成死锁。原因是循环等待</p>
</li>
<li><p>同步任务可以队列调度多个异步任务前，指定一个同步任务，让所有的异步任务，等待同步任务执行完成，这是依赖关系。</p>
</li>
<li><p>全局队列：并发，能够调度多个线程，执行效率高，但是相对费电。 串行队列效率较低，省电省流量，或者是任务之间需要依赖也可以使用串行队列。</p>
</li>
<li><p>也可以通过判断当前用户的网络环境来决定开的线程数。WIFI下6条，3G/4G下2～3条。</p>
</li>
</ol>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/03/iOS-多线程/" data-id="cipjqxxj5000kf4s6wy4ugwvx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-几种常见的加密方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/27/iOS-几种常见的加密方法/" class="article-date">
  <time datetime="2015-05-27T09:18:49.000Z" itemprop="datePublished">2015-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/27/iOS-几种常见的加密方法/">iOS_几种常见的加密方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>一.MD5</p>
<p>MD5编码是最常用的编码方法之一，是从一段字符串中通过相应特征生成一段32位的数字字母混合码。</p>
<p>MD5主要特点是 不可逆，相同数据的MD5值肯定一样，不同数据的MD5值不一样（也不是绝对的，但基本是不能一样的）。<br>MD5算法还具有以下性质：<br>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。<br>2、容易计算：从原数据计算出MD5值很容易。<br>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。<br>4、弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。<br>5、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。</p>
<p>MD5虽然说是不可逆的 但是由于有网站<a href="http://www.cmd5.com的存在，专门用来查询MD5码" target="_blank" rel="external">http://www.cmd5.com的存在，专门用来查询MD5码</a> 所以有的简单的MD5码是可以在这里搜到源码的。<br>为了让MD5码更加安全 涌现了很多其他方法 如加盐。 盐要足够长足够乱 得到的MD5码就很难查到。</p>
<p>终端代码：<br>$ md5 -s “abc”      给字符串abc加密<br>$ echo -n abc|openssl md5        给字符串abc加密  </p>
<p>二.HMAC加密</p>
<p>此加密方法需要先生成密钥，然后再对密码进行MD5和HMAC加密，数据库中需要存放当时使用的密钥和密码加密后的密文<br>在用户登陆时 再次对填入的密码用密钥进行加密 并且还要加上当前时间（精确到分钟） 再次HMAC加密，服务器里也会拿出以前存放的密文加上时间再次加密。所以就算黑客在中途截取了密码的密文 也在能在1分钟只能破译才能有效，大大加强了安全性。服务器为了考虑到网络的延迟一般会多算一种答案，如23分过来的密码 他会把23分和22分的都算一下和用户匹配只要对上一个就允许登陆。<br>三.base64编码<br>在MIME格式的电子邮件中，base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。使用时，在传输编码方式中指定base64。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，等号“=”用来作为后缀用途。</p>
<p>完整的base64定义可见RFC 1421和RFC 2045。编码后的数据比原始数据略长，为原来的4/3。<br>终端指令<br>先cd 找到当前目录<br>加密： $ base64 abc.png -o abc.txt<br>解密： $ base64 abc.txt -o 123.png -D</p>
<p>四.对称加密算法<br>优点：算法公开、计算量小、加密速度快、加密效率高、可逆<br>缺点：双方使用相同钥匙，安全性得不到保证<br>现状：对称加密的速度比公钥加密快很多，在很多场合都需要对称加密，<br>相较于DES和3DES算法而言，AES算法有着更高的速度和资源使用效率，安全级别也较之更高了，被称为下一代加密标准</p>
<p>nECB ：电子代码本，就是说每个块都是独立加密的<br>nCBC ：密码块链，使用一个密钥和一个初始化向量 (IV)对数据执行加密转换</p>
<p>ECB和CBC区别：CBC更加复杂更加安全，里面加入了8位的向量（8个0的话结果等于ECB）。在明文里面改一个字母，ECB密文对应的那一行会改变，CBC密文从那一行往后都会改变。</p>
<p>ECB终端命令：<br>$ openssl enc -des-ecb -K 616263 -nosalt -in msg1.txt -out msg1.bin<br>CBC终端命令：<br>$ openssl enc -des-cbc -K 616263 -iv 0000000000000000 -nosalt -in msg1.txt -out msg2.bin</p>
<p>五.RSA加密<br>RSA非对称加密算法<br>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）<br>公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密<br>特点：<br>非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快<br>对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了<br>基本加密原理：<br>(1)找出两个“很大”的质数：P &amp; Q<br>(2)N = P <em> Q<br>(3)M = (P – 1) </em> (Q – 1)<br>(4)找出整数E，E与M互质，即除了1之外，没有其他公约数<br>(5)找出整数D，使得E<em>D除以M余1，即 (E </em> D) % M = 1<br>经过上述准备工作之后，可以得到：<br>E是公钥，负责加密<br>D是私钥，负责解密<br>N负责公钥和私钥之间的联系<br>加密算法，假定对X进行加密<br>(X ^ E) % N = Y<br>n根据费尔马小定义，根据以下公式可以完成解密操作<br>(Y ^ D) % N = X</p>
<p>但是RSA加密算法效率较差，对大型数据加密时间很长，一般用于小数据。<br>常用场景：<br>分部要给总部发一段报文，先对报文整个进行MD5得到一个报文摘要，再对这个报文摘要用公钥加密。然后把报文和这个RSA密文一起发过去。<br>总部接收到报文之后要先确定报文是否在中途被人篡改，就先把这个密文用私钥解密得到报文摘要，再和整个报文MD5一下得到的报文摘要进行对比 如果一样就是没被改过。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/27/iOS-几种常见的加密方法/" data-id="cipjqxxik000df4s65ozfoep6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-在label中添加图片" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/16/iOS-在label中添加图片/" class="article-date">
  <time datetime="2015-03-16T09:01:48.000Z" itemprop="datePublished">2015-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/16/iOS-在label中添加图片/">iOS_在label中添加图片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>这个需求其实是有的，比如QQ聊天界面里面发送的信息，可以用label来显示文字（也可以用button显示），但是有时候用户可能会发送图片。如果能让Label遇到文字就显示文字，遇到图片就显示图片就好了。可能有的人会说用Quartz2D,直接在Label的drawinrect 里面用上下文画上去。但这感觉太刻意去弄了，而且比较麻烦。</p>
<p>如果你不是在董铂然博客园看到本文，请点击查看原文</p>
<p>推荐一种用Label系统的属性来做。</p>
<p>UIImage *image = [UIImage imageNamed:@”321.jpg”];</p>
<p>// 1&gt; 生成文本附件<br>NSTextAttachment *textAttach = [[NSTextAttachment alloc] init];<br>textAttach.image = image;</p>
<p>// 2&gt; 使用文本附件创建属性文本<br>NSAttributedString *strA = [NSAttributedString attributedStringWithAttachment:textAttach];</p>
<p>self.lblChat.attributedText = strA;<br>里面的lblChat是一个成员变量 在storyboard里拖得一个label。</p>
<p>所有人都知道label.Text 但应该不是全都知道label.attributedText </p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/16/iOS-在label中添加图片/" data-id="cipjqxxip000ff4s6xu4iui2f" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-关于蒲公英" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/07/iOS-关于蒲公英/" class="article-date">
  <time datetime="2015-03-07T07:50:33.000Z" itemprop="datePublished">2015-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/iOS-关于蒲公英/">iOS_关于蒲公英</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>蒲公英托管平台网站<a href="http://www.pgyer.com/" target="_blank" rel="external">http://www.pgyer.com/</a></p>
<p>首先说一下蒲公英是干什么的，蒲公英就是你程序希望给别的用户测试，但是他手机又没有在的开发者账号列表下，那么就需要企业账号打包才可以给用户进行安装，但是安装你又需要架设一个网页，等等其他麻烦事情，所以使用蒲公英可以简单做到这些事情，你无须有企业账号，只需要能打包成ipa文件即可，然后上传到蒲公英平台上，之后蒲公英就给你一个连接你发送给客户，或者做成二维码扫描即可</p>
<p>原理​</p>
<p>那么你奇怪为什么我随便打个包给他，别人就能下载了，从原理上分析，蒲公英提供了大量的企业级开发者账号，也就是299美金那种，然后你上传ipa文件，他服务器自动把ipa文件拆包，更换里面的签名文件，替换为企业级开发者账号的签名文件，之后在把这个ipa文件的地址发送给你，你下载就是299美金授权那种，这也就解释了​有的时候你在蒲公英上面一段时间后就不行的原因，因为被人举报了，蒲公英要启动一个新的账号，所以那个授权就过期了</p>
<p>注：最新版本的蒲公英需要用户自己提供299美金账号打包了，他不在提供修改ipa文件帮你修改了，这点需要注意​</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/07/iOS-关于蒲公英/" data-id="cipjqxxiq000gf4s6ciok4ja3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-关于判断VPN小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/17/iOS-关于判断VPN小结/" class="article-date">
  <time datetime="2015-02-17T07:44:09.000Z" itemprop="datePublished">2015-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/17/iOS-关于判断VPN小结/">iOS_关于判断VPN小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>需要判断是否开启了VPN方法的代码</p>
<p>头文件需要添加</p>
<p>#include</p>
<p>#include</p>
<p>代码部分</p>
<ul>
<li>(BOOL)isVPNConnected<br>{<br>struct ifaddrs <em>interfaces = NULL;<br>struct ifaddrs </em>temp_addr = NULL;<br>int success = 0;</li>
</ul>
<p>// retrieve the current interfaces - returns 0 on success<br>success = getifaddrs(&amp;interfaces);<br>if (success == 0) {<br>// Loop through linked list of interfaces<br>temp_addr = interfaces;<br>while (temp_addr != NULL) {<br>NSString *string = [NSString stringWithFormat:@”%s” , temp_addr-&gt;ifa_name];<br>if ([string rangeOfString:@”tap”].location != NSNotFound ||<br>[string rangeOfString:@”tun”].location != NSNotFound ||<br>[string rangeOfString:@”ppp”].location != NSNotFound){<br>return YES;<br>}</p>
<p>temp_addr = temp_addr-&gt;ifa_next;<br>}<br>}</p>
<p>// Free memory<br>freeifaddrs(interfaces);<br>return NO;</p>
<p>}</p>
<p>直接调用即可<br>BOOL isSucceess =[self isVPNConnected];</p>
<p>YES为开启了VPN，NO为关闭了VPN</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/02/17/iOS-关于判断VPN小结/" data-id="cipjqxxis000hf4s6gb82btbf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-JSON解析四种方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/07/iOS-JSON解析四种方法/" class="article-date">
  <time datetime="2015-01-07T14:00:23.000Z" itemprop="datePublished">2015-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/07/iOS-JSON解析四种方法/">iOS_JSON解析四种方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>相关链接：<a href="http://blog.csdn.net/enuola/article/details/7903632" target="_blank" rel="external">http://blog.csdn.net/enuola/article/details/7903632</a></p>
<p>从IOS5开始，APPLE提供了对json的原生支持（NSJSONSerialization），但是为了兼容以前的iOS版本，可以使用第三方库来解析Json。</p>
<p>本文将介绍TouchJson、 SBJson 、JSONKit 和 iOS5所支持的原生的json方法，解析国家气象局API，TouchJson和SBJson需要下载他们的库</p>
<p>TouchJson包下载： <a href="http://download.csdn.net/detail/enuola/4523169" target="_blank" rel="external">http://download.csdn.net/detail/enuola/4523169</a></p>
<p>SBJson 包下载： <a href="http://download.csdn.net/detail/enuola/4523177" target="_blank" rel="external">http://download.csdn.net/detail/enuola/4523177</a></p>
<p>JSONKit包下载：<a href="http://download.csdn.net/detail/enuola/4523160" target="_blank" rel="external">http://download.csdn.net/detail/enuola/4523160</a></p>
<p>下面的完整程序源码包下载：<a href="http://download.csdn.net/detail/enuola/4523223" target="_blank" rel="external">http://download.csdn.net/detail/enuola/4523223</a></p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/01/07/iOS-JSON解析四种方法/" data-id="cipjqxxin000ef4s69rk9x8b3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-三种途径实现一方法有多个返回值" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/03/24/iOS-三种途径实现一方法有多个返回值/" class="article-date">
  <time datetime="2014-03-24T08:24:39.000Z" itemprop="datePublished">2014-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/03/24/iOS-三种途径实现一方法有多个返回值/">iOS_三种途径实现一方法有多个返回值</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>以前觉得这种标题有点偏向于理论，实际开发中怎么会有这种诡异的需求，但是真正遇到了这种硬需求时觉得还是有那么点价值的，理论付诸了实践在此也就做了个整理。</p>
<p>以我私下开发中的一处代码为例，本意是希望有这么一个方法：能够传入一个开始标记（NSString<em>）一个结束标记（NSString</em>）一段文字（NSString*）  然后内部在文字中扫描并返回标记包裹内容的范围（NSRange这个范围是忽视标记的）这个范围可能会有多个所以返回的应该是一个装着range的数组。并且顺便把原来字符串中的开始和结束标记全过滤掉，把过滤后的字符串也返回出来。</p>
<p>举个例子就是：传入开始标记“&lt;” 结束标记“&gt;” 一段文字 “会议需要叫上&lt;彼得&gt;和&lt;罗宾&gt;”   然后希望返回一个数组 [{location:6,length:2},{location:9,length:2}] ，和返回处理后的字符串“会议需要叫上彼得和罗宾”。</p>
<p>代码希望能够写成这样，但是是不可能的。</p>
<p>1</p>
<ul>
<li>(NSArray <em>,NSMutableString </em>)scanBeginStr:(NSString <em>)beginstr endStr:(NSString </em>)endstr inText:(NSMutableString *)text</li>
</ul>
<p>好下面提供三种途径完成此需求。　　</p>
<p>1.使用字典</p>
<p>这种方法是最low但是最容易理解的，就是如果你需要返回多个对象，直接将多个对象塞在一个字典里面自己设置合理的key并返回字典，字典里面可以放任意数量的“返回值”。</p>
<ul>
<li>(NSDictionary <em>)scanBeginStr:(NSString </em>)beginstr endStr:(NSString <em>)endstr inText:(NSMutableString </em>)text{<br>NSRange range1,range2;<br>NSUInteger location =0,length=0;<br>range1.location = 0;<br>NSMutableArray *rangeArray = [NSMutableArray array];<br>while (range1.location != NSNotFound) {<br>range1 = [text rangeOfString:beginstr];<br>range2 = [text rangeOfString:endstr];<br>if (range1.location != NSNotFound) {<br>location = range1.location;<br>length = range2.location - range1.location - 1;<br>if (length &gt; 5000)break;<br>[text replaceOccurrencesOfString:beginstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range1.location + range1.length)];<br>[text replaceOccurrencesOfString:endstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range2.location + range2.length - 1)];<br>}<br>[rangeArray addObject:@{@”location”:@(location),@”length”:@(length)}];<br>}<br>return @{@”rangeArray”:rangeArray,@”text”:text};<br>}<br>这个方法在调用时也就是这样了，非常朴实的代码。</li>
</ul>
<p>NSDictionary<em> result = [self scanBegin2Str:@”&lt;” endStr:@”&gt;” inText:mutableText];<br>NSArray </em>rangeArray = result[@”rangeArray”];<br>NSMutableString *text = [result[@”text”] mutableCopy];<br>如果觉得字典不舒服也完全可以用模型，自定义一个对象然后给这个对象的各个属性赋值然后再把这个自定义对象返回回去，虽然代码看上去更科学一点但是需要写一些额外的代码并且不能实现任意可配置（每一种属性都必须要提前设定好），这个和上面算是一个相同的思路就不单独再列一条说了。 </p>
<p>2.使用指针的指针</p>
<p>这种方法是我实际使用的方法，就是把需要修改的text的指针的指针传进去，然后在方法的内部对这个实参取一下值得到text的指针。然后通过这个指针修改外部的变量的值。代码实现如下</p>
<ul>
<li>(NSArray <em>)scanBeginStr:(NSString </em>)beginstr endStr:(NSString <em>)endstr inText:(NSMutableString </em> <em>)textPointer{<br>NSRange range1,range2;<br>NSUInteger location =0,length=0;<br>range1.location = 0;<br>NSMutableString </em>text = <em>textPointer;<br>NSMutableArray </em>rangeArray = [NSMutableArray array];<br>while (range1.location != NSNotFound) {<br>range1 = [text rangeOfString:beginstr];<br>range2 = [text rangeOfString:endstr];<br>if (range1.location != NSNotFound) {<br>location = range1.location;<br>length = range2.location - range1.location - 1;<br>if (length &gt; 5000)break;<br>[text replaceOccurrencesOfString:beginstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range1.location + range1.length)];<br>[text replaceOccurrencesOfString:endstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range2.location + range2.length - 1)];<br>}<br>[rangeArray addObject:@{@”location”:@(location),@”length”:@(length)}];<br>}<br>return rangeArray;<br>}<br>这个方法在调用时就这么写了，因为mutabletext的修改是无声无息的。</li>
</ul>
<p>NSArray *rangeArray = [self scanBegin3Str:@”&lt;” endStr:@”&gt;” inText:&amp;mutableText];<br>// 董铂然博客园
　　</p>
<p>3.使用block回调</p>
<p>这种方法实际上严格意义来说不能算返回值，但是能够实现返回值的效果。</p>
<ul>
<li>(void)scanBeginStr:(NSString <em>)beginstr endStr:(NSString </em>)endstr inText:(NSMutableString <em>)text result:(void(^)(NSArray </em>rangeArray,NSMutableString <em>text))result{<br>NSRange range1,range2;<br>NSUInteger location =0,length=0;<br>range1.location = 0;<br>NSMutableArray </em>rangeArray = [NSMutableArray array];<br>while (range1.location != NSNotFound) {<br>range1 = [text rangeOfString:beginstr];<br>range2 = [text rangeOfString:endstr];<br>if (range1.location != NSNotFound) {<br>location = range1.location;<br>length = range2.location - range1.location - 1;<br>if (length &gt; 5000)break;<br>[text replaceOccurrencesOfString:beginstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range1.location + range1.length)];<br>[text replaceOccurrencesOfString:endstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range2.location + range2.length - 1)];<br>}<br>[rangeArray addObject:@{@”location”:@(location),@”length”:@(length)}];<br>}<br>result(rangeArray,text);<br>}<br>这个block在使用时可能比较特殊就这么写了</li>
</ul>
<p>[self scanBeginStr:@”&lt;” endStr:@”&gt;” inText:mutabletext result:^(NSArray <em>rangeArray, NSMutableString </em>text) {<br>NSLog(@”%@,%@”,rangeArray,text);<br>}];<br>如果把block的返回值写成一个字典或是模型也可以，但是那就多此一举了。 返回值不能尝试结构体类型，结构体内不能用OC对象只能用基本数据类型。</p>
<p>其实感觉还有别的方法，比如设置N个成员变量在方法内部计算后重新set也完全可以，但是可能大家也知道成员变量多了比较恶心。最近比较火的函数式编程一直在倡导“方法内不能产生副作用”“实现引用透明” ，如果这么看那后两种方法就不符合FP的规则了，但是用着也有自己的特色。</p>
<p>原文链接：<a href="http://www.cnblogs.com/dsxniubility/p/5122146.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/5122146.html</a></p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/03/24/iOS-三种途径实现一方法有多个返回值/" data-id="cipjqxxih000cf4s6iq6nd7sk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/04/17/openGL学习/">openGL学习</a>
          </li>
        
          <li>
            <a href="/2016/03/21/UITableView的应用和其中js与oc交互/">UITableView的应用和其中js与oc交互</a>
          </li>
        
          <li>
            <a href="/2016/02/15/搞定iOS与js交互/">搞定iOS与js交互</a>
          </li>
        
          <li>
            <a href="/2016/01/28/移动直播开发技术介绍/">移动直播开发技术介绍</a>
          </li>
        
          <li>
            <a href="/2016/01/22/Bilibili开源的直播框架/">Bilibili开源的直播框架</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>