<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>孙利峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="孙利峰">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="孙利峰">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孙利峰">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="孙利峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">孙利峰</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="写ios-SDK注意问题小结" class="article article-type-写ios" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/14/SDK注意问题小结/" class="article-date">
  <time datetime="2013-12-14T13:35:15.000Z" itemprop="datePublished">2013-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/14/SDK注意问题小结/">SDK注意问题小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>我发现即使是像腾讯、小米这样的大厂提供的 SDK，在质量和规范上也有很多问题，而且包括我以及我身边的很多朋友都被恶心到了，所以我就把这些注意事项总结出来，希望大家不要犯同样的错误。<br>注意事项一：所有类名都应该加前缀<br>说明：没有前缀的类名有冲突的风险。<br>Bad Case：微信分享的 SDK，文件名：WXApiObject.h，代码如下，其中BaseReq类和BaseResp类都没有加前缀。<br>@interface BaseReq : NSObject</p>
<p>/<strong> 请求类型 */<br>@property (nonatomic, assign) int type;<br>/</strong> 由用户微信号和 AppID 组成的唯一标识，发送请求时第三方程序必须填写，用于校验微信用户是否换号登录 <em>/<br>@property (nonatomic, retain) NSString</em> openID;</p>
<p>@end</p>
<p>#pragma mark - BaseResp<br>/<em>! @brief 该类为微信终端 SDK 所有响应类的基类
</em><br><em>/<br>@interface BaseResp : NSObject<br>/** 错误码 </em>/<br>@property (nonatomic, assign) int errCode;<br>/<strong> 错误提示字符串 <em>/<br>@property (nonatomic, retain) NSString </em>errStr;<br>/</strong> 响应类型 */<br>@property (nonatomic, assign) int type;</p>
<p>@end<br>注意事项二：所有 category 方法加前缀<br>说明：category 方法如果不加前缀，有冲突的风险。<br>Bad Case：腾讯分享的 SDK，它为 NSArray 增加了一个 JSONArray 的 category，造成我们本身的同名 category 被覆盖。另外他们为 NSArray 增加的其它 category 和著名的 Cordova 开源库冲突，造成 Cordova 无法使用。<br>注意事项三：不要将第三方库打包进 SDK<br>说明：尽量不要将第三方库打包进 SDK，如果要打包，最好也要将该第三方库重命名，以避免冲突。<br>Bad Case：小米的推送 SDK，直接在 SDK 静态库里面编进去一个第三方依赖库，而且这个库还是 ASIHttpRequest。ASIHttp 当前已经处于无人维护状态，很多 Bug 都是大家自己在修复（例如网易就自己维护了一个 ASIHttpRequest 的分支）。在 SDK 中依赖这种库还是比较麻烦的。<br>注意事项四：做基本的检查和测试<br>说明：SDK 对外公布前应该进行基本的编译检查，不应该有编译器警告存在。<br>Bad Case：腾讯分享的 SDK。它的 CGIParamsWrap.o 和 TencentOAuth.o 文件里面的方法名冲突了，如下所示：<br>ld: warning: instance method ‘deleteAPIRequestBySeq:’ in category from /Users/tangqiao/work/iphone/solar-ios/lib_common/TencentOpenApi/TencentOpenAPI.framework/TencentOpenAPI(CGIParamsWrap.o) overrides method from class in /Users/tangqiao/work/iphone/solar-ios/lib_common/TencentOpenApi/TencentOpenAPI.framework/TencentOpenAPI(TencentOAuth.o)<br>注意事项五：文档完整并且正确<br>说明：这就不用解释了吧？<br>Bad Case: 微信官方的微信支付的示例代码，里面有各种错误，代码都无法编译成功。如下所示的是其中一个错误：</p>
<p>于是还有人专门帮微信另外制作了一个非官方的说明文档，地址在这里：<a href="https://github.com/gbammc/WechatPayDemo" target="_blank" rel="external">https://github.com/gbammc/WechatPayDemo</a><br>注意事项六：支持最新的 CPU 版本<br>说明：去年苹果的一次 Bug，造成上传应用必须支持 arm64 的 CPU 版本，结果众多应用因为依赖的 SDK 不支持 arm64 而无法更新。当然，这次 Bug 出来之后，各 SDK 厂商都紧急做了更新。但是我觉得这种事情如果要做得专业，就应该一开始就紧跟技术更新，及时更新，而不是被迫更新。<br>总结<br>以上 6 点是我认为写一个 SDK 的最最基本的要求，希望被点名批评的同学能尽快改正哟～<br>如果大家在使用其它 SDK 时也发现了类似的问题，欢迎在文章下面留言。希望通过这种方式给开发相关 SDK 的同学一些压力，让他们好好改一下。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/14/SDK注意问题小结/" data-id="cipiddz5c0008113zc18eyt8s" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-培训出来的iOS学员怎么了？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/06/培训出来的iOS学员怎么了？/" class="article-date">
  <time datetime="2013-12-06T13:27:43.000Z" itemprop="datePublished">2013-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/06/培训出来的iOS学员怎么了？/">培训出来的iOS学员怎么了？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>今天就想和大家聊聊这个沉重的话题。<br>诚信的恶性循环<br>首先我们说说简历造假吧。在我看来，简历造假还是时常遇到的。我认识礼物说的 CTO，我们 iOS 群里常常有朋友面试时遇到说自己在礼物说工作过的候选人，为什么呢？还不是网上有一堆高仿礼物说的 APP，自己下载下来看看，然后就可以假装是自己做的了。<br>为什么很多候选人选择造假呢？除了简历不够好之外，造假很多时候确实有用。对于很多小公司来说，面试官自己也不懂如何面试 iOS 开发，那么就特别容易被忽悠。<br>但是，一个公司里面有 iOS 开发者，然后再稍微懂一些面试技巧的话，简历造假是很容易发现的。关于怎么在面试中鉴别造假，我们在下一节聊。<br>我们先聊聊看造假会造成什么危机呢？对于面试公司来说，如果他发现面试的效率特别低，或者招进来的人干活不行时，他会怎么办呢？<br>我觉得他会很直接地开地图炮，把一类人直接刷掉，不再给面试机会。这类人是哪些人？简历雷同的、培训机构培训出来的人。<br>这样公平吗？对候选人肯定不公平，但是公司招人也需要讲效率的，面试候选人其实成本特别高。<br>所以造假这个行为，最终伤害的是候选人本人，以及培训机构的信誉。<br>如何在面试中鉴别造假<br>其实挺简单的，首先面试的时候不要设置固定问题，然后根据候选人的回答情况来深入问细节。<br>就比如说一个候选人说他做过礼物说，那就有很多可以深入问的，比如问他：<br>礼物说有几个 iOS 开发<br>大家是如何分工的<br>你负责的那块最主要的难点在哪里<br>团队整个协作的过程<br>在开发的时候有没有遇到需求变更<br>功能上线后大概的数据是什么样的<br>你觉得哪些地方还需要改进<br>你们主要的竞争对手是谁，他们在哪些技术方面比你们做得好<br>一个谎话要编容易，难的是每一个细节都编得面面俱到，所以深入细节问，很容易就会露馅。<br>我是培训机构学员怎么办<br>简单地说，公司招一个人最终级的目的还是把活干好。如果一个培训机构的学员，没有实际的工作能力，单凭几个月的培训就想一劳永逸地找一份好工作，这是不现实的。<br>互联网技术日新月异，iOS 开发每年技术都在更新，如果指望所有知识都是从培训机构那儿获得，那么早晚都会被淘汰。<br>所以，即使你当前是培训机构出来的学员，也必须培养自己实际解决问题的能力和自学能力。这样才能一点点地增强自己的实力。<br>另外说一个残酷的现实，公司一般不会给你大块的上班时间用来学习新知识的。所以大多数学习充电过程只能是在下班后或周末。<br>我们应该怎么看待培训机构学员<br>我自己就招过一个培训机构出来的学员，她还是一个女生，现在工作得挺棒的。她是非计算机专业毕业的，参加培训机构学了 3 个月就来我们公司面试。她能通过面试，很大程度上是因为她不止参加了培训班的课，而且自己在网上学习了计算机数据结构和算法的基础知识，而且是看的国外的课程。<br>当时面试时我完全没有考查她 iOS 知识，因为她承认只参加了 3 个月的培训。所以我考查了一下她自学数据结构和算法的情况。结果让我觉得她是一个自学能力还不错的女生，所以我就把她招了进来。<br>刚进来带她做 iOS 费了一些精力，但是很快她就可以上手自己做事情了。现在，我已经完全把小猿搜题的 iOS 端交给她来负责。我想她就是一个培训机构出来学员的成功案例。<br>我们并不鄙视培训机构的学生，但是我们不认同那些没有自学能力，认为参加 3 个月培训就可以拿高薪的「投机者」。这个行业虽然高薪，但是也很辛苦，如果没有兴趣和毅力，是没办法做好的。<br>搞 iOS 开发到底需要什么核心能力<br>大家看了我上次采访的 YYKit 作者的文章 后，或许就能明白，其实一个人核心的能力就是学习能力。有强大的学习能力，那么就可以像 YYKit 作者那样，才接触 iOS 开发一年多就可以开源出大量优秀的作品。<br>基本上，一个人在一个领域坚持投入大量的时间，很难做得不好。所以你是一个培训机构的学员，苦于找不到工作。与其简历造假拿到面试机会，倒不如再多花花精力，自己多专研一些代码，写一些 App，不要那么急功近利，我想结果都会好很多。<br>愿培训机构出来的 iOS 学员都能找一份好工作。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/06/培训出来的iOS学员怎么了？/" data-id="cipiddz6f000g113zbs1b7r98" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-Runtime全方位装逼小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/11/27/iOS-Runtime全方位装逼小结/" class="article-date">
  <time datetime="2013-11-27T13:10:55.000Z" itemprop="datePublished">2013-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/27/iOS-Runtime全方位装逼小结/">iOS_Runtime全方位装逼小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>楔子<br>Runtime是什么？见名知意，其概念无非就是“因为 Objective-C 是一门动态语言，所以它需要一个运行时系统……这就是 Runtime 系统”云云。对博主这种菜鸟而言，Runtime 在实际开发中，其实就是一组C语言的函数。胡适说：“多研究些问题，少谈些主义”，云山雾罩的概念听多了总是容易头晕，接下来我们直接从代码入手学习 Runtime。</p>
<p>1、由objc_msgSend说开去：<br>Objective-C 中的方法调用，不是简单的方法调用，而是发送消息，也就是说，其实 [receiver message] 会被编译器转化为: objc_msgSend(receiver, selector)，何以证明？新建一个类 MyClass，其.m文件如下：</p>
<p>#import “MyClass.h”<br>@implementation MyClass</p>
<p>-(instancetype)init{<br>if (self = [super init]) {<br>[self showUserName];<br>}<br>return self;<br>}</p>
<p>-(void)showUserName{<br>NSLog(@”Dave Ping”);<br>}<br>使用 clang 重写命令:</p>
<p>$ clang -rewrite-objc MyClass.m<br>然后在同一目录下会多出一个 MyClass.cpp 文件，双击打开，可以看到 init 方法已经被编译器转化为下面这样：</p>
<p>static instancetype _I_MyClass_init(MyClass <em> self, SEL _cmd) {<br>if (self = ((MyClass </em>(<em>)(__rw_objc_super </em>, SEL))(void <em>)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(“MyClass”))}, sel_registerName(“init”))) {<br>((void (</em>)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(“showUserName”));<br>}<br>return self;<br>}<br>我们要找的就是它：</p>
<p>((void (<em>)(id, SEL))(void </em>)objc_msgSend)((id)self, sel_registerName(“showUserName”))<br>objc_msgSend 函数被定义在 objc/message.h 目录下，其函数原型是酱紫滴：</p>
<p>OBJC_EXPORT void objc_msgSend(void /<em> id self, SEL op, … </em>/ )<br>该函数有两个参数，一个 id 类型，一个 SEL 类型。</p>
<p>2、SEL<br>SEL 被定义在 objc/objc.h 目录下：</p>
<p>typedef struct objc_selector *SEL;<br>其实它就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获得一个 SEL 类型的方法选择器。</p>
<p>3、id<br>与 SEL 一样，id 也被定义在 objc/objc.h 目录下：</p>
<p>typedef struct objc_object *id;<br>id 是一个结构体指针类型，它可以指向 Objective-C 中的任何对象。objc_object 结构体定义如下：</p>
<p>struct objc_object { Class isa OBJC_ISA_AVAILABILITY;};<br>我们通常所说的对象，就长这个样子，这个结构体只有一个成员变量 isa，对象可以通过 isa 指针找到其所属的类。isa 是一个 Class 类型的成员变量，那么 Class 又是什么呢？</p>
<p>4、Class<br>Class 也是一个结构体指针类型：</p>
<p>typedef struct objc_class *Class;<br>objc_class 结构体是酱紫滴：</p>
<p>struct objc_class {<br>Class isa  OBJC_ISA_AVAILABILITY;</p>
<p>#if !<strong>OBJC2</strong><br>Class super_class                                        OBJC2_UNAVAILABLE;<br>const char <em>name                                         OBJC2_UNAVAILABLE;<br>long version                                             OBJC2_UNAVAILABLE;<br>long info                                                OBJC2_UNAVAILABLE;<br>long instance_size                                       OBJC2_UNAVAILABLE;<br>struct objc_ivar_list </em>ivars                             OBJC2_UNAVAILABLE;<br>struct objc_method_list <em>*methodLists                    OBJC2_UNAVAILABLE;<br>struct objc_cache </em>cache                                 OBJC2_UNAVAILABLE;<br>struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</p>
<p>#endif</p>
<p>} OBJC2_UNAVAILABLE;<br>我们通常说的类就长这样子：<br>·Class 也有一个 isa 指针，指向其所属的元类（meta）.<br>·super_class：指向其超类.<br>·name：是类名.<br>·version：是类的版本信息.<br>·info：是类的详情.<br>·instance_size：是该类的实例对象的大小.<br>·ivars：指向该类的成员变量列表.<br>·methodLists：指向该类的实例方法列表，它将方法选择器和方法实现地址联系起来。methodLists 是指向 ·objc_method_list 指针的指针，也就是说可以动态修改 *methodLists 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因.<br>·cache：Runtime 系统会把被调用的方法存到 cache 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高.<br>·protocols：指向该类的协议列表.</p>
<p>说到这里有点乱了，我们来捋一下，当我们调用一个方法时，其运行过程大致如下：</p>
<p>首先，Runtime 系统会把方法调用转化为消息发送，即 objc_msgSend，并且把方法的调用者，和方法选择器，当做参数传递过去.</p>
<p>此时，方法的调用者会通过 isa 指针来找到其所属的类，然后在 cache 或者 methodLists 中查找该方法，找得到就跳到对应的方法去执行.</p>
<p>如果在类中没有找到该方法，则通过 super_class 往上一级超类查找（如果一直找到 NSObject 都没有找到该方法的话，这种情况，我们放到后面消息转发的时候再说）.</p>
<p>前面我们说 methodLists 指向该类的实例方法列表，实例方法即-方法，那么类方法（+方法）存储在哪儿呢？类方法被存储在元类中，Class 通过 isa 指针即可找到其所属的元类.</p>
<p>上图实线是 super_class 指针，虚线是 isa 指针。根元类的超类是NSObject，而 isa 指向了自己。NSObject 的超类为 nil，也就是它没有超类。</p>
<p>5、使用objc_msgSend<br>前面我们使用 clang 重写命令，看到 Runtime 是如何将方法调用转化为消息发送的。我们也可以依样画葫芦，来学习使用一下 objc_msgSend。新建一个类 TestClass，添加如下方法：</p>
<p>-(void)showAge{<br>NSLog(@”24”);<br>}</p>
<p>-(void)showName:(NSString *)aName{<br>NSLog(@”name is %@”,aName);<br>}</p>
<p>-(void)showSizeWithWidth:(float)aWidth andHeight:(float)aHeight{<br>NSLog(@”size is %.2f * %.2f”,aWidth, aHeight);<br>}</p>
<p>-(float)getHeight{<br>return 187.5f;<br>}</p>
<p>-(NSString *)getInfo{<br>return @”Hi, my name is Dave Ping, I’m twenty-four years old in the year, I like apple, nice to meet you.”;<br>}<br>我们可以像下面这样，使用 objc_msgSend 依次调用这些方法：</p>
<p>TestClass *objct = [[TestClass alloc] init];</p>
<p>((void (*) (id, SEL)) objc_msgSend) (objct, sel_registerName(“showAge”));</p>
<p>((void (<em>) (id, SEL, NSString </em>)) objc_msgSend) (objct, sel_registerName(“showName:”), @”Dave Ping”);</p>
<p>((void (*) (id, SEL, float, float)) objc_msgSend) (objct, sel_registerName(“showSizeWithWidth:andHeight:”), 110.5f, 200.0f);</p>
<p>float f = ((float (*) (id, SEL)) objc_msgSend_fpret) (objct, sel_registerName(“getHeight”));<br>NSLog(@”height is %.2f”,f);</p>
<p>NSString <em>info = ((NSString</em> (*) (id, SEL)) objc_msgSend) (objct, sel_registerName(“getInfo”));<br>NSLog(@”%@”,info);<br>也许你已经注意到，objc_msgSend 在使用时都被强制转换了一下，这是因为 objc_msgSend 函数可以hold住各种不同的返回值以及多个参数，但默认情况下是没有参数和返回值的。如果我们把调用 showAge 方法改成这样：</p>
<p>objc_msgSend(objct, sel_registerName(“showAge”));<br>Xcode 就会报错：</p>
<p>Too many arguments to function call, expected 0, have 2.<br>完整的 objc_msgSend 使用代码在这里。</p>
<p>6、objc_msgSendSuper<br>编译器会根据情况在 objc_msgSend，objc_msgSend_stret，objc_msgSendSuper，objc_msgSendSuper_stret 或 objc_msgSend_fpret 五个方法中选择一个来调用。如果消息是传递给超类，那么会调用 objc_msgSendSuper 方法，如果消息返回值是数据结构，就会调用 objc_msgSendSuper_stret 方法，如果返回值是浮点数，则调用 objc_msgSend_fpret 方法。</p>
<p>这里我们重点说一下 objc_msgSendSuper，objc_msgSendSuper 函数原型如下：</p>
<p>OBJC_EXPORT void objc_msgSendSuper(void /<em> struct objc_super </em>super, SEL op, … */ )<br>当我们调用 [super selector] 时，Runtime 会调用 objc_msgSendSuper 方法，objc_msgSendSuper 方法有两个参数，super 和 op，Runtime 会把 selector 方法选择器赋值给 op。而 super 是一个 objc_super 结构体指针，objc_super 结构体定义如下：</p>
<p>struct objc_super {<br>/// Specifies an instance of a class.<br>__unsafe_unretained id receiver;</p>
<p>/// Specifies the particular superclass of the instance to message. </p>
<p>#if !defined(<strong>cplusplus)  &amp;  !</strong>OBJC2<strong><br>/<em> For compatibility with old objc-runtime.h header </em>/
</strong>unsafe_unretained Class class;</p>
<p>#else<br>__unsafe_unretained Class super_class;</p>
<p>#endif<br>/<em> super_class is the first class to search </em>/<br>};<br>Runtime 会创建一个 objc_spuer 结构体变量，将其地址作为参数（super）传递给 objc_msgSendSuper，并且将 self 赋值给 receiver：super—&gt;receiver=self.<br>举个栗子，问下面的代码输出什么：</p>
<p>@implementation Son : Father</p>
<ul>
<li>(id)init<br>{<br>self = [super init];<br>if (self)<br>{<br>NSLog(@”%@”, NSStringFromClass([self class]));<br>NSLog(@”%@”, NSStringFromClass([super class]));<br>}<br>return self;<br>}<br>@end<br>答案是全部输出 Son.<br>使用 clang 重写命令，发现上述代码被转化为:</li>
</ul>
<p>NSLog((NSString <em>)&amp;<strong>NSConstantStringImpl</strong>var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (</em>)(id, SEL))(void <em>)objc_msgSend)((id)self, sel_registerName(“class”))));<br>NSLog((NSString </em>)&amp;<strong>NSConstantStringImpl</strong>var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (<em>)(__rw_objc_super </em>, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass(“Son”)) }, sel_registerName(“class”))));<br>当调用 [super class] 时，会转换成 objc_msgSendSuper 函数：</p>
<p>第一步先构造 objc_super 结构体，结构体第一个成员就是 self。第二个成员是 (id)class_getSuperclass(objc_getClass(“Son”)).</p>
<p>第二步是去 Father 这个类里去找 – (Class)class，没有，然后去 NSObject 类去找，找到了。最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class)) 去调用，此时已经和 [self class] 调用相同了，所以两个输出结果都是 Son。</p>
<p>7、对象关联<br>对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：</p>
<p>OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) <strong>OSX_AVAILABLE_STARTING(</strong>MAC_10_6, __IPHONE_3_1);<br>·object 是源对象.<br>·value 是被关联的对象.<br>·key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.<br>·policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：</p>
<p>typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {<br>OBJC_ASSOCIATION_ASSIGN = 0,           /**<br>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：</p>
<p>objc_setAssociatedObject(self, associatedKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>objc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.<br>举个栗子，假如我们要给 UIButton 添加一个监听单击事件的 block 属性，新建 UIButton 的 Category，其.m文件如下：</p>
<p>#import “UIButton+ClickBlock.h”</p>
<p>#import </p>
<p>static const void *associatedKey = “associatedKey”;</p>
<p>@implementation UIButton (ClickBlock)</p>
<p>//Category中的属性，只会生成setter和getter方法，不会生成成员变量</p>
<p>-(void)setClick:(clickBlock)click{<br>objc_setAssociatedObject(self, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>[self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];<br>if (click) {<br>[self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];<br>}<br>}</p>
<p>-(clickBlock)click{<br>return objc_getAssociatedObject(self, associatedKey);<br>}</p>
<p>-(void)buttonClick{<br>if (self.click) {<br>self.click();<br>}<br>}</p>
<p>@end<br>然后在代码中，就可以使用 UIButton 的属性来监听单击事件了：</p>
<p>UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];<br>button.frame = self.view.bounds;<br>[self.view addSubview:button];<br>button.click = ^{<br>NSLog(@”buttonClicked”);<br>};<br>完整的对象关联代码点这里</p>
<p>8、自动归档<br>博主在学习 Runtime 之前，归档的时候是酱紫写的：</p>
<ul>
<li><p>(void)encodeWithCoder:(NSCoder *)aCoder{<br>[aCoder encodeObject:self.name forKey:@”name”];<br>[aCoder encodeObject:self.ID forKey:@”ID”];<br>}</p>
</li>
<li><p>(id)initWithCoder:(NSCoder *)aDecoder{<br>if (self = [super init]) {<br>self.ID = [aDecoder decodeObjectForKey:@”ID”];<br>self.name = [aDecoder decodeObjectForKey:@”name”];<br>}<br>return self;<br>}<br>那么问题来了，如果当前 Model 有100个属性的话，就需要写100行这种代码：</p>
</li>
</ul>
<p>[aCoder encodeObject:self.name forKey:@”name”];<br>想想都头疼，通过 Runtime 我们就可以轻松解决这个问题：<br>1.使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.<br>2.使用 ivar_getName 方法获取成员变量的名称.<br>3.通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.</p>
<p>举个栗子，新建一个 Model 类，其.m文件如下：</p>
<p>#import “TestModel.h”</p>
<p>#import </p>
<p>#import </p>
<p>@implementation TestModel</p>
<ul>
<li>(void)encodeWithCoder:(NSCoder <em>)aCoder{<br>unsigned int outCount = 0;<br>Ivar </em>vars = class_copyIvarList([self class], &amp;outCount);<br>for (int i = 0; i<br>完整的自动归档代码在这里</li>
</ul>
<p>9、字典与模型互转<br>最开始博主是这样用字典给 Model 赋值的：</p>
<p>-(instancetype)initWithDictionary:(NSDictionary *)dict{<br>if (self = [super init]) {<br>self.age = dict[@”age”];<br>self.name = dict[@”name”];<br>}<br>return self;<br>}<br>可想而知，遇到的问题跟归档时候一样（后来使用MJExtension），这里我们稍微来学习一下其中原理，字典转模型的时候：<br>1.根据字典的 key 生成 setter 方法.<br>2.使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.</p>
<p>模型转字典的时候：<br>1.调用 class_copyPropertyList 方法获取当前 Model 的所有属性.<br>2.调用 property_getName 获取属性名称.<br>3.根据属性名称生成 getter 方法.<br>4.使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.</p>
<p>代码如下：</p>
<p>#import “NSObject+KeyValues.h”</p>
<p>#import </p>
<p>#import </p>
<p>@implementation NSObject (KeyValues)</p>
<p>//字典转模型<br>+(id)objectWithKeyValues:(NSDictionary <em>)aDictionary{<br>id objc = [[self alloc] init];<br>for (NSString </em>key in aDictionary.allKeys) {<br>id value = aDictionary[key];</p>
<p>/<em>判断当前属性是不是Model</em>/<br>objc_property_t property = class_getProperty(self, key.UTF8String);<br>unsigned int outCount = 0;<br>objc_property_attribute_t <em>attributeList = property_copyAttributeList(property, &amp;outCount);<br>objc_property_attribute_t attribute = attributeList[0];<br>NSString </em>typeString = [NSString stringWithUTF8String:attribute.value];<br>if ([typeString isEqualToString:@”@”TestModel””]) {<br>value = [self objectWithKeyValues:value];<br>}<br>/<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>/</p>
<p>//生成setter方法，并用objc_msgSend调用<br>NSString <em>methodName = [NSString stringWithFormat:@”set%@%@:”,[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];<br>SEL setter = sel_registerName(methodName.UTF8String);<br>if ([objc respondsToSelector:setter]) {<br>((void (</em>) (id,SEL,id)) objc_msgSend) (objc,setter,value);<br>}<br>}<br>return objc;<br>}</p>
<p>//模型转字典<br>-(NSDictionary <em>)keyValuesWithObject{<br>unsigned int outCount = 0;<br>objc_property_t </em>propertyList = class_copyPropertyList([self class], &amp;outCount);<br>NSMutableDictionary *dict = [NSMutableDictionary dictionary];<br>for (int i = 0; i<br>完整代码在这里</p>
<p>10、动态方法解析<br>前面我们留下了一点东西没说，那就是如果某个对象调用了不存在的方法时会怎么样，一般情况下程序会crash，错误信息类似下面这样：</p>
<p>unrecognized selector sent to instance 0x7fd0a141afd0<br>但是在程序crash之前，Runtime 会给我们动态方法解析的机会，消息发送的步骤大致如下：</p>
<p>1.检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数了.</p>
<p>2.检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉.</p>
<p>3.如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行.<br>如果 cache 找不到就找一下方法分发表.</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/11/27/iOS-Runtime全方位装逼小结/" data-id="cipiddz5n000a113zme4l1la9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS多线程编程基础小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/11/20/iOS多线程编程基础小结/" class="article-date">
  <time datetime="2013-11-20T13:06:30.000Z" itemprop="datePublished">2013-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/20/iOS多线程编程基础小结/">iOS多线程编程基础小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>一、基本概念<br>计算机操作系统都有的基本概念，以下概念简单方式来描述。</p>
<p>进程： 一个具有一定独立功能的程序关于某个数据集合的一次运行活动。可以理解成一个运行中的应用程序。</p>
<p>线程： 程序执行流的最小单元，线程是进程中的一个实体。</p>
<p>同步： 只能在当前线程按先后顺序依次执行，不开启新线程。</p>
<p>异步： 可以在当前线程开启多个新线程执行，可不按顺序执行。</p>
<p>队列： 装载线程任务的队形结构。</p>
<p>并发： 线程执行可以同时一起进行执行。</p>
<p>串行： 线程执行只能依次逐一先后有序的执行。</p>
<p>注意:</p>
<p>一个进程可有多个线程。</p>
<p>一个进程可有多个队列。</p>
<p>队列可分并发队列和串行队列。</p>
<p>二、iOS多线程对比</p>
<ol>
<li>NSThread</li>
</ol>
<p>每个NSThread对象对应一个线程，真正最原始的线程。</p>
<p>1）优点：NSThread 轻量级最低，相对简单。</p>
<p>2）缺点：手动管理所有的线程活动，如生命周期、线程同步、睡眠等。</p>
<ol>
<li>NSOperation</li>
</ol>
<p>自带线程管理的抽象类。</p>
<p>1）优点：自带线程周期管理，操作上可更注重自己逻辑。</p>
<p>2）缺点：面向对象的抽象类，只能实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。</p>
<ol>
<li>GCD</li>
</ol>
<p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。</p>
<p>1）优点：最高效，避开并发陷阱。</p>
<p>2）缺点：基于C实现。</p>
<ol>
<li>选择小结</li>
</ol>
<p>1）简单而安全的选择NSOperation实现多线程即可。</p>
<p>2）处理大量并发数据，又追求性能效率的选择GCD。</p>
<p>3）NSThread本人选择基本上是在做些小测试上使用，当然也可以基于此造个轮子。</p>
<p>三、场景选择<br>图片异步加载。这种常见的场景是最常见也是必不可少的。异步加载图片有分成两种来说明一下。</p>
<p>第一种，在UI主线程开启新线程按顺序加载图片，加载完成刷新UI。</p>
<p>第二种，依然是在主线程开启新线程，顺序不定地加载图片，加载完成个字刷新UI。</p>
<p>创作工具上的异步。 这个跟上边任务调度道理，只是为了丰富描述，有助于“举一反三”效果。如下描述的是app创作小说。</p>
<p>场景一，app本地创作10个章节内容未成同步服务器，同时发表这10个章节产生的一系列动作，其中上传内容，获取分配章节Id，如何后台没有做处理最好方式做异步按顺序执行。</p>
<p>场景二，app本地创作列表中有3本小说为发表，同时发表创作列表中的3本小说，自然考虑并行队列执行发表。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/11/20/iOS多线程编程基础小结/" data-id="cipiddz6a000e113zudglb8sn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-IOS开发之多线程技术小结2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/11/14/IOS开发之多线程技术小结2/" class="article-date">
  <time datetime="2013-11-14T12:59:47.000Z" itemprop="datePublished">2013-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/14/IOS开发之多线程技术小结2/">IOS开发之多线程技术小结2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>三、如何使用多线程技术<br>ios中多线程实现的多种技术方案：</p>
<p>POSIX 表示可移植操作系统接口（Portable Operating System Interface )—–pthread</p>
<p>1）pthread技术：<br>pthread 是 POSIX 多线程开发框架，由于是跨平台的 C 语言框架，在苹果的头文件中并没有详细的注释要查阅 pthread 有关资料，可以访问 <a href="http://baike.baidu.com" target="_blank" rel="external">http://baike.baidu.com</a></p>
<p>// 创建线程，并且在线程中执行 demo 函数</p>
<ul>
<li>(void)pthreadDemo {</li>
</ul>
<p>/<em>*<br>参数：<br>1&gt; 指向线程标识符的指针，C 语言中类型的结尾通常 _t/Ref，而且不需要使用 </em><br>2&gt; 用来设置线程属性<br>3&gt; 新建立的线程执行代码的函数<br>4&gt; 运行函数的参数</p>
<p>返回值：</p>
<ul>
<li>若线程创建成功，则返回0</li>
<li>若线程创建失败，则返回出错编号</li>
</ul>
<p>在混合开发时，如果在 C 和 OC 之间传递数据，需要使用 __bridge 进行桥接，桥接的目的就是为了告诉编译器如何管理内存<br><em>/<br>pthread_t threadId = NULL;<br>NSString </em>str = @”Hello Pthread”;</p>
<p>int result = pthread_create(&amp;threadId, NULL, demo, (__bridge void *)(str));</p>
<p>result ? NSLog(@”为其他任何值时代表开辟子线程失败”) : NSLog(@”当result为0时表示开辟子线程成功”);<br>}</p>
<p>// 后台线程调用函数<br>void <em>demo(void </em>params) {<br>NSString <em>str = (__bridge NSString </em>)(params);</p>
<p>NSLog(@”%@ - %@”, [NSThread currentThread], str);</p>
<p>return NULL;<br>}</p>
<p>C语言中pthread.h里pthread实现多线程<br>2）NSThread技术：</p>
<ul>
<li>(void)viewDidLoad {<br>[super viewDidLoad];</li>
</ul>
<p>NSLog(@”主线程%@”, [NSThread currentThread]);<br>/<em>*<br>多个线程之间的执行顺序是随机的
</em>/</p>
<p>// 方式1：通过NSThread的对象方法<br>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(demo:) object:@”方式1”];<br>[thread start];</p>
<p>// 方式2：没有thread字眼，隐式创建并启动线程，所有 NSObject 都可以使用此方法，在其他线程执行方法<br>[self performSelectorInBackground:@selector(demo:) withObject:@”方式2”];</p>
<p>// 方式3：detachNewThreadSelector 类方法不需要启动，会自动创建线程并执行 @selector 方法<br>[NSThread detachNewThreadSelector:@selector(demo:) toTarget:self withObject:@”方式3”];</p>
<p>}</p>
<ul>
<li>(void)demo:(NSString *)str {<br>NSLog(@”%@, %@”, str, [NSThread currentThread]);<br>}</li>
</ul>
<p>通过NSThread创建线程的三种方式<br>2.1）线程属性</p>
<ol>
<li><p>name - 线程名称</p>
</li>
<li><p>threadPriority - 线程优先级</p>
</li>
</ol>
<p>取值范围从 0~1.0</p>
<p>1.0表示优先级最高</p>
<p>0.0表示优先级最低</p>
<p>默认优先级是0.5</p>
<ol>
<li><p>stackSize - 栈区大小</p>
</li>
<li><p>isMainThread - 是否主线程</p>
</li>
</ol>
<p>2.2）资源共享(抢夺)<br>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源，比如多个线程访问同一个对象、同一个变量、同一个文件当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。如购买火车票问题：</p>
<p>解决方案:</p>
<p>#pragma mark</p>
<p>#pragma mark - 模拟卖票系统</p>
<ul>
<li>(void)sellTicket {</li>
</ul>
<p>_count = 50;</p>
<p>NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(ticket) object:nil];<br>thread1.name = @”t1”;<br>[thread1 start];</p>
<p>NSThread *thread2 = [[NSThread alloc] initWithTarget:self selector:@selector(ticket) object:nil];<br>thread2.name = @”t2”;<br>[thread2 start];<br>}</p>
<ul>
<li>(void)ticket {</li>
</ul>
<p>while (YES) {</p>
<p>// 被加锁的对象<br>@synchronized(self) {<br>if (_count &gt; 0) {<br>_count = self.count - 1;<br>NSLog(@”剩余票数%ld ——%@”, _count, [NSThread currentThread]);<br>} else {<br>NSLog(@”票卖没了倒霉蛋”);<br>break;<br>}<br>}<br>}</p>
<p>}</p>
<p>卖票系统线程同步解决线程不安全问题<br>互斥锁 ：如果发现有其他线程正在执行锁定的代码，线程会 进入休眠状态 ，等待其他线程执行完毕，打开锁之后，线程会被 唤醒<br>自旋锁 ：如果发现有其他线程正在执行锁定的代码，线程会以 死循环 的方式，一直等待锁定代码执行完成<br>线程安全</p>
<p>多个线程进行读写操作时，仍然能够得到正确结果，被称为线程安全，要实现线程安全，必须要用到锁、为了得到更佳的用户体验，UIKit 不是线程安全的，所以更新 UI 的操作都必须主线程上执行！因此，主线程又被称为UI 线程。</p>
<p>3）GCD技术<br>为保证篇幅不过与杂糅，请见“IOS开发之多线程技术——GCD篇”</p>
<p>4) NSOperation技术<br>为保证篇幅不过与杂糅，请见“IOS开发之多线程技术——NSOperation篇”</p>
<p>四、线程的生命周期（线程状态）<br>新建</p>
<p>实例化线程对象</p>
<p>就绪</p>
<ul>
<li>(void)start;</li>
</ul>
<p>向线程对象发送 start 消息，线程对象被加入 可调度线程池 等待 CPU 调度</p>
<p>detachNewThreadSelector 方法和 performSelectorInBackground 方法会直接实例化一个线程对象并加入 可调度线程池</p>
<p>运行</p>
<p>CPU 负责调度可调度线程池中线程的执行</p>
<p>线程执行完成之前(死亡之前)，状态可能会在就绪和运行之间来回切换</p>
<p>就绪和运行之间的状态变化由 CPU 负责，程序员不能干预</p>
<p>阻塞</p>
<p>当满足某个预定条件时，可以使用休眠或锁阻塞线程执行</p>
<ul>
<li><p>(void)sleepUntilDate:(NSDate *)date;</p>
</li>
<li><p>(void)sleepForTimeInterval:(NSTimeInterval)ti;</p>
</li>
</ul>
<p>@synchronized(self)：互斥锁死亡:+ (void)exit</p>
<p>正常死亡</p>
<p>线程执行完毕</p>
<p>非正常死亡</p>
<p>当满足某个条件后，在线程内部自己中止执行(自杀),[NSThread exit];</p>
<p>当满足某个条件后，在主线程给其它线程打个死亡标记(下圣旨),让子线程自行了断.(被逼着死亡)</p>
<p>注意:在终止线程之前，应该注意释放之前分配的对象!<br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/11/14/IOS开发之多线程技术小结2/" data-id="cipiddz4l0001113zj447yqwa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-IOS开发之多线程技术小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/11/07/IOS开发之多线程技术小结/" class="article-date">
  <time datetime="2013-11-07T12:55:56.000Z" itemprop="datePublished">2013-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/07/IOS开发之多线程技术小结/">IOS开发之多线程技术小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>一、什么是多线程<br>多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程，进而提升整体处理性能。具有这种能力的系统包括对称多处理机、多核心处理器以及芯片级多处理（Chip-level multithreading）或同时多线程（Simultaneous multithreading）处理器。在一个程序中，这些独立运行的程序片段叫作“线程”（Thread），利用它编程的概念就叫作“多线程处理（Multithreading）”。具有多线程能力的计算机因有硬件支持而能够在同一时间执行多于一个线程（台湾译作“执行绪”），进而提升整体处理性能。</p>
<p>1) 多线程执行原理</p>
<p>a. （单核CPU）同一时间，cpu只能处理1个线程，只有1个线程在执行</p>
<p>b. 多线程同时执行：是CPU快速的在多个线程之间的切换</p>
<p>c. cpu调度线程的时间足够快，就造成了多线程的”同时”执行</p>
<p>d. 如果线程数非常多，cpu会在n个线程之间切换，消耗大量的cpu资源</p>
<p>i. 每个线程被调度的次数会降低，线程的执行效率降低</p>
<p>2）线程与进程<br>每个正在系统上运行的程序都是一个进程。每个进程包含一到多个线程。进程也可能是整个程序或者是部分程序的动态执行。线程是一组执行的集合，或者是程序的特殊段，它可以在程序里独立执行。也可以把它理解为代码运行的上下文。所以线程基本上是轻量级的进程，它负责在单个程序里执行多任务。通常由操作系统负责多个线程的调度和执行。</p>
<p>线程是程序中一个单一的顺序控制流程，在单个程序中同时运行多个线程完成不同的工作，称为多线程。</p>
<p>线程和进程的区别在于，子进程和父进程有不同的代码和数据空间，而多个线程则共享数据空间，每个线程有自己的执行堆栈和程序计数器为其执行上下文，多线程主要是为了节约CPU时间，发挥利用，根据具体情况而定。线程的运行中需要使用计算机的内存资源和CPU。</p>
<p>3）多线程的优缺点<br>优点：</p>
<p>1、使用线程可以把占据时间长的程序中的任务放到后台去处理。</p>
<p>2、用户界面可以更加吸引人，这样比如用户点击了一个按钮去触发某些事件的处理，可以弹出一个进度条来显示处理的进度。</p>
<p>3、程序的运行速度可能加快。</p>
<p>4、在一些等待的任务实现上如用户输入、文件读写和网络收发数据等，线程就比较有用了。在这种情况下可以释放一些珍贵的资源如内存占用等等。</p>
<p>5、线程上的任务执行完成后，线程会自动销毁。</p>
<p>缺点：</p>
<p>1、线程越多，cpu在调用线程上的开销就越大，如果有大量的线程，会影响性能，因为操作系统需要在它们之间切换。</p>
<p>2、开启线程需要占用一定的内存空间（默认情况下，每一个线程都占512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能，更多的线程需要更多的内存空间。</p>
<p>3、程序设计更加复杂，比如线程间的通信、多线程的数据共享，可能会给程序带来更多的BUG，因此要小心使用。</p>
<p>4、线程的中止需要考虑其对程序运行的影响。</p>
<p>5、通常块模型数据是在多个线程间共享的，需要一个合适的锁系统替换掉数据共享。</p>
<p>注意：iOS 8.0后主线程的默认堆栈大小也是 512K，官方文档标注错误。</p>
<p>二、我们为什么要用多线程编程技术<br>在大多数研究领域内是要求线程调度程序要能够快速选择其中一个已就绪线程去运行，而不是一个一个运行而降低效率。所以要让调度程序去分辨线程的优先级是很重要的。在移动开发过程中，一切均已用户体验作为首要任务，这时多线程的重要性不言而喻。</p>
<p>一个程序运行后，默认会开启1个线程，称为“主线程”或“UI线程”，主线程一般用来刷新UI界面，处理UI事件（比如：点击、滚动、拖拽等事件）</p>
<p>主线程使用注意</p>
<p>别将耗时的操作放到主线程中</p>
<p>耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种卡的坏体验</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/11/07/IOS开发之多线程技术小结/" data-id="cipiddz580007113z2a0c075b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="ios-集合的深复制与浅复制小结" class="article article-type-ios" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/10/28/集合的深复制与浅复制小结/" class="article-date">
  <time datetime="2013-10-28T12:51:18.000Z" itemprop="datePublished">2013-10-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/28/集合的深复制与浅复制小结/">集合的深复制与浅复制小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>原文出处： MicroCai<br>概念</p>
<p>对象拷贝有两种方式：浅复制和深复制。顾名思义，浅复制，并不拷贝对象本身，仅仅是拷贝指向对象的指针；深复制是直接拷贝整个对象内存到另一块内存中。</p>
<p>再简单些说：浅复制就是指针拷贝；深复制就是内容拷贝。</p>
<p>集合的浅复制 (shallow copy)</p>
<p>集合的浅复制有非常多种方法。当你进行浅复制时，会向原始的集合发送retain消息，引用计数加1，同时指针被拷贝到新的集合。</p>
<p>现在让我们看一些浅复制的例子：</p>
<p>Objective-C</p>
<p>NSArray <em>shallowCopyArray = [someArray copyWithZone:nil];<br>NSSet </em>shallowCopySet = [NSSet mutableCopyWithZone:nil];<br>NSDictionary *shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:NO];<br>集合的深复制 (deep copy)</p>
<p>集合的深复制有两种方法。可以用 initWithArray:copyItems: 将第二个参数设置为YES即可深复制，如</p>
<p>Objective-C</p>
<p>NSDictionary shallowCopyDict = [[NSDictionary alloc] initWithDictionary:someDictionary copyItems:YES];<br>如果你用这种方法深复制，集合里的每个对象都会收到 copyWithZone: 消息。如果集合里的对象遵循 NSCopying 协议，那么对象就会被深复制到新的集合。如果对象没有遵循 NSCopying 协议，而尝试用这种方法进行深复制，会在运行时出错。copyWithZone: 这种拷贝方式只能够提供一层内存拷贝(one-level-deep copy)，而非真正的深复制。</p>
<p>第二个方法是将集合进行归档(archive)，然后解档(unarchive)，如：</p>
<p>Objective-C</p>
<p>NSArray *trueDeepCopyArray = [NSKeyedUnarchiver unarchiveObjectWithData:[NSKeyedArchiver archivedDataWithRootObject:oldArray]];<br>集合的单层深复制 (one-level-deep copy)<br>看到这里，有同学会问：如果在多层数组中，对第一层进行内容拷贝，其它层进行指针拷贝，这种情况是属于深复制，还是浅复制？对此，苹果官网文档有这样一句话描述</p>
<p>This kind of copy is only capable of producing a one-level-deep copy. If you only need a one-level-deep copy…</p>
<p>If you need a true deep copy, such as when you have an array of arrays…<br>从文中可以看出，苹果认为这种复制不是真正的深复制，而是将其称为单层深复制(one-level-deep copy)。因此，网上有人对浅复制、深复制、单层深复制做了概念区分。</p>
<p>浅复制(shallow copy)：在浅复制操作时，对于被复制对象的每一层都是指针复制。<br>深复制(one-level-deep copy)：在深复制操作时，对于被复制对象，至少有一层是深复制。<br>完全复制(real-deep copy)：在完全复制操作时，对于被复制对象的每一层都是对象复制。<br>当然，这些都是概念性的东西，没有必要纠结于此。只要知道进行拷贝操作时，被拷贝的是指针还是内容即可。</p>
<p>系统对象的copy与mutableCopy方法</p>
<p>不管是集合类对象，还是非集合类对象，接收到copy和mutableCopy消息时，都遵循以下准则：</p>
<p>copy返回imutable对象；所以，如果对copy返回值使用mutable对象接口就会crash；<br>mutableCopy返回mutable对象；<br>下面将针对非集合类对象和集合类对象的copy和mutableCopy方法进行具体的阐述</p>
<p>1、非集合类对象的copy与mutableCopy</p>
<p>系统非集合类对象指的是 NSString, NSNumber … 之类的对象。下面先看个非集合类immutable对象拷贝的例子</p>
<p>Objective-C</p>
<p>NSString <em>string = @”origin”;<br>NSString </em>stringCopy = [string copy];<br>NSMutableString *stringMCopy = [string mutableCopy];<br>通过查看内存，可以看到 stringCopy 和 string 的地址是一样，进行了指针拷贝；而 stringMCopy 的地址和 string 不一样，进行了内容拷贝；</p>
<p>再看mutable对象拷贝例子</p>
<p>Objective-C</p>
<p>NSMutableString <em>string = [NSMutableString stringWithString: @”origin”];<br>//copy<br>NSString </em>stringCopy = [string copy];<br>NSMutableString <em>mStringCopy = [string copy];<br>NSMutableString </em>stringMCopy = [string mutableCopy];<br>//change value<br>[mStringCopy appendString:@”mm”]; //crash<br>[string appendString:@” origion!”];<br>[stringMCopy appendString:@”!!”];<br>运行以上代码，会在第7行crash，原因就是 copy 返回的对象是 immutable 对象。注释第7行后再运行，查看内存，发现 string、stringCopy、mStringCopy、stringMCopy 四个对象的内存地址都不一样，说明此时都是做内容拷贝。</p>
<p>综上两个例子，我们可以得出结论：</p>
<p>在非集合类对象中：对immutable对象进行copy操作，是指针复制，mutableCopy操作时内容复制；对mutable对象进行copy和mutableCopy都是内容复制。用代码简单表示如下：</p>
<p>[immutableObject copy] // 浅复制<br>[immutableObject mutableCopy] //深复制<br>[mutableObject copy] //深复制<br>[mutableObject mutableCopy] //深复制<br>2、集合类对象的copy与mutableCopy</p>
<p>集合类对象是指NSArray、NSDictionary、NSSet … 之类的对象。下面先看集合类immutable对象使用copy和mutableCopy的一个例子：</p>
<p>Objective-C</p>
<p>NSArray <em>array = @[@[@”a”, @”b”], @[@”c”, @”d”];<br>NSArray </em>copyArray = [array copy];<br>NSMutableArray *mCopyArray = [array mutableCopy];<br>查看内容，可以看到copyArray和array的地址是一样的，而mCopyArray和array的地址是不同的。说明copy操作进行了指针拷贝，mutableCopy进行了内容拷贝。但需要强调的是：此处的内容拷贝，仅仅是拷贝array这个对象，array集合内部的元素仍然是指针拷贝。这和上面的非集合immutable对象的拷贝还是挺相似的，那么mutable对象的拷贝会不会类似呢？我们继续往下，看mutable对象拷贝的例子：</p>
<p>Objective-C</p>
<p>NSMutableArray <em>array = [NSMutableArray arrayWithObjects:[NSMutableString stringWithString:@”a”],@”b”,@”c”,nil];<br>NSArray </em>copyArray = [array copy];<br>NSMutableArray *mCopyArray = [array mutableCopy];<br>查看内存，如我们所料，copyArray、mCopyArray和array的内存地址都不一样，说明copyArray、mCopyArray都对array进行了内容拷贝。同样，我们可以得出结论：<br>在集合类对象中，对immutable对象进行copy，是指针复制，mutableCopy是内容复制；对mutable对象进行copy和mutableCopy都是内容复制。但是：集合对象的内容复制仅限于对象本身，对象元素仍然是指针复制。用代码简单表示如下：</p>
<p>[immutableObject copy] // 浅复制<br>[immutableObject mutableCopy] //单层深复制<br>[mutableObject copy] //单层深复制<br>[mutableObject mutableCopy] //单层深复制<br>这个代码结论和非集合类的非常相似。</p>
<p>这时候，是不是有人要问了，如果要对集合对象复制元素怎么办？有这疑问的同学不妨回头看看集合的深复制。</p>
<p>好了，深复制与浅复制就讲到这里。</p>
<p>最后说个题外的东西，在搜集资料的过程中，发现一个有可能犯错的点</p>
<p>Objective-C</p>
<p>NSString *str = @”string”;<br>str = @”newString”;<br>上面这段代码，在执行第二行代码后，内存地址发生了变化。乍一看，有点意外。按照 C 语言的经验，初始化一个字符串之后，字符串的首地址就被确定下来，不管之后如何修改字符串内容，这个地址都不会改变。但此处第二行并不是对 str 指向的内存地址重新赋值，因为赋值操作符左边的 str 是一个指针，也就是说此处修改的是内存地址。</p>
<p>所以第二行应该这样理解：将@”newStirng”当做一个新的对象，将这段对象的内存地址赋值给str。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/10/28/集合的深复制与浅复制小结/" data-id="cipiddz77000l113zm2wnq5il" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Objective-C内存管理教程和原理小结4" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/10/22/Objective-C内存管理教程和原理小结4/" class="article-date">
  <time datetime="2013-10-22T12:48:29.000Z" itemprop="datePublished">2013-10-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/22/Objective-C内存管理教程和原理小结4/">Objective-C内存管理教程和原理小结4</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>原文出处： Vince Yuan的博客<br>系统自动创建新的autorelease pool</p>
<p>在生成新的Run Loop的时候，系统会自动创建新的autorelease pool（非常感谢网友hhyytt和neogui的提醒）。注意，此处不同于xcode在新建项目时自动生成的代码中加入的autorelease pool，xcode生成的代码可以被删除，但系统自动创建的新的autorelease pool是无法删除的（对于无Garbage Collection的环境来说）。Objective-C没有给出实现代码，官方文档也没有说明，但我们可以通过小程序来证明。</p>
<p>在这个小程序中，我们先生成了一个autorelease pool，然后生成一个autorelease的ClassA的实例，再在一个新的run loop中生成一个autorelease的ClassB的对象（注意，我们并没有手动在新run loop中生成autorelease pool）。精简的示例代码如下，详细代码请见附件中的memman-run-loop-with-pool.m。</p>
<p>int main(int argc, char<em>*argv)<br>{<br>NSLog(@”create an autorelasePool\n”);<br>NSAutoreleasePool </em>pool = [[NSAutoreleasePool alloc] init];   </p>
<p>NSLog(@”create an instance of ClassA and autorelease\n”);<br>ClassA <em>obj1 = [[[ClassA alloc] init] autorelease];<br>NSDate </em>now = [[NSDate alloc] init];<br>NSTimer <em>timer = [[NSTimer alloc] initWithFireDate:now<br>interval:0.0<br>target:obj1<br>selector:@selector(createClassB)<br>userInfo:nil<br>repeats:NO];<br>NSRunLoop </em>runLoop = [NSRunLoop currentRunLoop];<br>[runLoop addTimer:timer forMode:NSDefaultRunLoopMode];<br>[timer release];<br>[now release];<br>[runLoop run]; //在新loop中调用一函数，生成ClassB的autorelease实例</p>
<p>NSLog(@”releasing autorelasePool\n”);<br>[pool release];<br>NSLog(@”autorelasePool is released\n”);<br>return 0;<br>}<br>输出如下：</p>
<p>create an autorelasePool<br>create an instance of ClassA and autorelease<br>create an instance of ClassB and autorelease<br>ClassB destroyed<br>releasing autorelasePool<br>ClassA destroyed<br>autorelasePool is released<br>注意在我们销毁autorelease pool之前，ClassB的autorelease实例就已经被销毁了。</p>
<p>有人可能会说，这并不能说明新的run loop自动生成了一个新的autorelease pool，说不定还只是用了老的autorelease pool，只不过后来drain了一次而已。我们可以在main函数中不生成autorelease pool。精简的示例代码如下，详细代码请见附件中的memman-run-loop-without-pool.m。</p>
<p>int main(int argc, char**argv)<br>{<br>NSLog(@”No autorelasePool created\n”);</p>
<p>NSLog(@”create an instance of ClassA\n”);<br>ClassA <em>obj1 = [[ClassA alloc] init];<br>NSDate </em>now = [[NSDate alloc] init];<br>NSTimer <em>timer = [[NSTimer alloc] initWithFireDate:now<br>interval:0.0<br>target:obj1<br>selector:@selector(createClassB)<br>userInfo:nil<br>repeats:NO];<br>NSRunLoop </em>runLoop = [NSRunLoop currentRunLoop];<br>[runLoop addTimer:timer forMode:NSDefaultRunLoopMode];<br>[timer release];<br>[now release];<br>[runLoop run]; //在新loop中调用一函数，生成ClassB的autorelease实例<br>NSLog(@”Manually release the instance of ClassA\n”);<br>[obj1 release];</p>
<p>return 0;<br>}<br>输出如下：</p>
<p>No autorelasePool created<br>create an instance of ClassA<br>create an instance of ClassB and autorelease<br>ClassB destroyed<br>Manually release the instance of ClassA<br>ClassA destroyed<br>我们可以看出来，我们并没有创建任何autorelease pool，可是ClassB的实例依然被自动销毁了，这说明新的run loop自动创建了一个autorelease pool，这个pool在新的run loop结束的时候会销毁自己（并自动release所包含的对象）。</p>
<p>补充说明</p>
<p>在研究retain count的时候，我不建议用NSString。因为在下面的语句中，</p>
<p>NSString *str1 = @”constant string”;</p>
<p>str1的retain count是个很大的数字。Objective-C对常量字符串做了特殊处理。</p>
<p>当然，如果你这样创建NSString，得到的retain count依然为1</p>
<p>NSString *str2 = [NSString stringWithFormat:@”123”];</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/10/22/Objective-C内存管理教程和原理小结4/" data-id="cipiddz560006113zrr2ud15i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Objective-C内存管理教程和原理小结3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/10/14/Objective-C内存管理教程和原理小结3/" class="article-date">
  <time datetime="2013-10-14T12:44:32.000Z" itemprop="datePublished">2013-10-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/14/Objective-C内存管理教程和原理小结3/">Objective-C内存管理教程和原理小结3</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>原文出处： Vince Yuan 的博客<br>@property (retain)和@synthesize的默认实现</p>
<p>在这里解释一下@property (retain) ClassB* objB;和@synthesize objB;背后到底发生了什么(retain property的默认实现)。property实际上是getter和setter，针对有retain参数的property，背后的实现如下（请参考附件中的memman-getter-setter.m，你会发现，结果和memman-property.m一样）：</p>
<p>@interface ClassA : NSObject<br>{<br>ClassB *objB;<br>}</p>
<p>-(ClassB <em>) getObjB;<br>-(void) setObjB:(ClassB </em>) value;<br>@end</p>
<p>@implementation ClassA<br>-(ClassB*) getObjB<br>{<br>return objB;<br>}</p>
<p>-(void) setObjB:(ClassB*) value<br>{<br>if (objB != value)<br>{<br>[objB release];<br>objB = [value retain];<br>}<br>}<br>在setObjB中，如果新设定的值和原值不同的话，必须要把原值对象release一次，这样才能保证retain count是正确的。</p>
<p>由于我们在class内部retain了一次（虽然是默认实现的），所以我们要在dealloc方法中release这个成员变量。</p>
<p>-(void) dealloc<br>{<br>[objB release];<br>[super dealloc];<br>}</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/10/14/Objective-C内存管理教程和原理小结3/" data-id="cipiddz4t0003113zrnzaz3lm" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Objective-C内存管理教程和原理小结2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/10/07/Objective-C内存管理教程和原理小结2/" class="article-date">
  <time datetime="2013-10-07T12:40:05.000Z" itemprop="datePublished">2013-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/10/07/Objective-C内存管理教程和原理小结2/">Objective-C内存管理教程和原理小结2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>原文出处： Vince Yuan 的博客<br>口诀与范式</p>
<ol>
<li>口诀</li>
</ol>
<p>1.1 谁创建，谁释放（类似于“谁污染，谁治理”）。如果你通过alloc、new或copy来创建一个对象，那么你必须调用release或autorelease。换句话说，不是你创建的，就不用你去释放。</p>
<p>例如，你在一个函数中alloc生成了一个对象，且这个对象只在这个函数中被使用，那么你必须在这个函数中调用release或autorelease。如果你在一个class的某个方法中alloc一个成员对象，且没有调用autorelease，那么你需要在这个类的dealloc方法中调用release；如果调用了autorelease，那么在dealloc方法中什么都不需要做。</p>
<p>1.2 除了alloc、new或copy之外的方法创建的对象都被声明了autorelease。</p>
<p>1.3 谁retain，谁release。只要你调用了retain，无论这个对象是如何生成的，你都要调用release。有时候你的代码中明明没有retain，可是系统会在默认实现中加入retain。不知道为什么苹果公司的文档没有强调这个非常重要的一点，请参考范式2.7和第三章。</p>
<p>2 范式<br>范式就是模板，就是依葫芦画瓢。由于不同人有不同的理解和习惯，我总结的范式不一定适合所有人，但我能保证照着这样做不会出问题。</p>
<p>2.1 创建一个对象。</p>
<p>ClassA *obj1 = [[ClassA alloc] init];<br>2.2 创建一个autorelease的对象。</p>
<p>ClassA *obj1 = [[[ClassA alloc] init] autorelease];<br>2.3 Release一个对象后，立即把指针清空。（顺便说一句，release一个空指针是合法的，但不会发生任何事情）</p>
<p>[obj1 release];</p>
<p>obj1 = nil;<br>2.4 指针赋值给另一个指针。</p>
<p>ClassA *obj2 = obj1;</p>
<p>[obj2 retain];</p>
<p>//do something</p>
<p>[obj2 release];</p>
<p>obj2 = nil;<br>2.5 在一个函数中创建并返回对象，需要把这个对象设置为autorelease</p>
<p>ClassA *Func1()</p>
<p>{</p>
<p>ClassA *obj = [[[ClassA alloc]init]autorelease];</p>
<p>return obj;</p>
<p>}<br>2.6 在子类的dealloc方法中调用基类的dealloc方法</p>
<p>-(void) dealloc</p>
<p>{</p>
<p>…</p>
<p>[super dealloc];</p>
<p>}<br>2.7 在一个class中创建和使用property。</p>
<p>2.7.1 声明一个成员变量。</p>
<p>ClassB *objB;<br>2.7.2  声明property，加上retain参数。</p>
<p>@property (retain) ClassB* objB;<br>2.7.3 定义property。（property的默认实现请看第三章）</p>
<p>@synthesize objB;<br>2.7.4 除了dealloc方法以外，始终用.操作符的方式来调用property。</p>
<p>self.objB 或者objA.objB<br>2.7.5 在dealloc方法中release这个成员变量。</p>
<p>[objB release];<br>示例代码如下（详细代码请参考附件中的memman-property.m，你需要特别留意对象是在何时被销毁的。）：</p>
<p>@interface ClassA : NSObject<br>{<br>ClassB* objB;<br>}</p>
<p>@property (retain) ClassB* objB;<br>@end</p>
<p>@implementation ClassA<br>@synthesize objB;<br>-(void) dealloc<br>{<br>[objB release];<br>[super dealloc];<br>}<br>@end<br>2.7.6 给这个property赋值时，有手动release和autorelease两种方式。</p>
<p>void funcNoAutorelease()<br>{<br>ClassB <em>objB1 = [[ClassB alloc]init];<br>ClassA </em>objA = [[ClassA alloc]init];<br>objA.objB = objB1;<br>[objB1 release];<br>[objA release];<br>}</p>
<p>void funcAutorelease()<br>{<br>ClassB <em>objB1 = [[[ClassB alloc]init] autorelease];<br>ClassA </em>objA = [[[ClassA alloc]init] autorelease];<br>objA.objB = objB1;<br>}</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/10/07/Objective-C内存管理教程和原理小结2/" data-id="cipiddz4y0004113zao2namvj" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/02/15/搞定iOS与js交互/">搞定iOS与js交互</a>
          </li>
        
          <li>
            <a href="/2016/01/28/移动直播开发技术介绍/">移动直播开发技术介绍</a>
          </li>
        
          <li>
            <a href="/2016/01/22/Bilibili开源的直播框架/">Bilibili开源的直播框架</a>
          </li>
        
          <li>
            <a href="/2016/01/14/iOS三种视屏录制方式/">iOS三种视屏录制方式</a>
          </li>
        
          <li>
            <a href="/2015/01/07/iOS-JSON解析四种方法/">iOS_JSON解析四种方法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>