<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>孙利峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="孙利峰">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="孙利峰">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孙利峰">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="孙利峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">孙利峰</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS中使用ZXing库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/20/iOS中使用ZXing库/" class="article-date">
  <time datetime="2014-01-20T14:02:30.000Z" itemprop="datePublished">2014-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/20/iOS中使用ZXing库/">iOS中使用ZXing库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>前言<br>ZXing(Github镜像地址)是一个开源的条码生成和扫描库（开源协议为Apache2.0)。它不但支持众多的条码格式，而且有各种语言的实现版本，它支持的语言包括：Java, C++, C#, Objective-C, ActionScript和Ruby。<br>我上周在iOS项目开发中使用了ZXing的扫描二维码功能。在此总结一下如何将ZXing集成到已有的iOS工程中，分享给大家。<br>集成步骤<br>首先去Google Code或Github将ZXing的代码下载下来，整个工程比较大，我们只需要其中涉及iOS的部分，所以最好做一些裁剪。简单来说，我们只需要保留cpp和iphone这2个文件夹，其余的全部删掉。如下图所示：</p>
<p>接着我们继续裁剪，对于cpp这个目录，只保留cpp/core/src/zxing下面的内容，其余内容也可以删掉了。但是整个目录结构必须保持原样。裁剪完后，整个目录结构如下所示：</p>
<p>接下来，我们把裁剪后的zxing目录整个移动到我们的iOS项目的目录下，并且把上图中可以看到的ZXingWidget.xcodeproj文件拖动到我们的iOS工程中。<br>下一步，我们需要设置ZXing项目和我们原本的iOS项目之间的依赖关系。在我们的iOS项目的设置中，点击build phases tab，然后增加 Target Dependencies 和 Link binary，并且增加这些framework依赖：<br>a. AVFoundation<br>b. AudioToolbox<br>c. CoreVideo<br>d. CoreMedia<br>e. libiconv<br>f. AddressBook<br>g. AddressBookUI</p>
<p>最后一步，在设置中增加如下2个header search path:<br>./zxing/iphone/ZXingWidget/Classes<br>./zxing/cpp/core/src<br>需要注意的是，第一个path要设置成循环查找子目录，而第二个不循环查找，如下图所示：</p>
<p>恭喜你，完成这步之后，你就已经完成ZXing库的集成了。下面谈谈如何使用ZXing库来做二维码识别。<br>二维码识别<br>ZXing的iOS版本提供2种方法来做二维码识别功能，第一种方法比较简单，第二种方法比较复杂。我在做Demo时使用了第一种方法，做真正项目开发的时候使用了第二种方法，所以都给大家介绍一下。<br>使用方法一<br>ZXing直接提供了一个扫描二维码的View Controller，即ZXingWidgetController。在需要使用的界面代码中，加入文件依赖：</p>
<p>#import <zxingwidgetcontroller.h></zxingwidgetcontroller.h></p>
<p>#import <qrcodereader.h><br><code>然后在需要扫描的时候，调用如下代码即可：</code> objc</qrcodereader.h></p>
<ul>
<li>(IBAction)scanPressed:(id)sender {<br>ZXingWidgetController <em>widController = [[ZXingWidgetController alloc] initWithDelegate:self showCancel:YES OneDMode:NO];<br>NSMutableSet </em>readers = [[NSMutableSet alloc ] init];<br>QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];<br>[readers addObject:qrcodeReader];<br>[qrcodeReader release];<br>widController.readers = readers;<br>[readers release];<br>[self presentModalViewController:widController animated:YES];<br>[widController release];<br>}<br>在ZXing扫描有结果时，会调用如下回调函数：</li>
</ul>
<p>@protocol ZXingDelegate</p>
<ul>
<li>(void)zxingController:(ZXingWidgetController<em>)controller didScanResult:(NSString </em>)result;</li>
<li>(void)zxingControllerDidCancel:(ZXingWidgetController*)controller;<br>@end<br>使用方法二<br>方法二与方法一的区别就相当于AVFoundation和UIImagePickerController的区别一样。简单来说，就是使用方法二比方法一更加麻烦，但是获得的可定制性更高。<br>使用方法二时，你需要自己用AVFoundation获得Camera返回的实时图象，然后转成UIImage，最后传给ZXing的Decoder类完成二维码的识别。由于使用AVFoundation涉及的代码略多，我写的示意代码如下：</li>
</ul>
<p>#import “Decoder.h”</p>
<p>#import “TwoDDecoderResult.h”</p>
<p>#import “QRCodeReader.h”</p>
<ul>
<li>(void)viewDidLoad {<br>// setup QR reader<br>self.qrReader = [[NSMutableSet alloc ] init];<br>QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];<br>[self.qrReader addObject:qrcodeReader];<br>self.scanningQR = NO;<br>self.step = STEP_QR;<br>}</li>
</ul>
<p>// AVFoundation的回调函数</p>
<ul>
<li>(void)captureOutput:(AVCaptureOutput <em>)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection </em>)connection {<br>// 第一步，将sampleBuffer转成UIImage<br>UIImage <em>image= [self getCaptureImage:sampleBuffer];<br>// 第二步，用Decoder识别图象<br>Decoder </em>d = [[Decoder alloc] init];<br>d.readers = self.qrReader;<br>d.delegate = self;<br>self.scanningQR = [d decodeImage:image] == YES ? NO : YES;<br>}<br>ZXing的Decoder类提供了以下回调函数获得识别结果：<br>@protocol DecoderDelegate<nsobject><br>@optional</nsobject></li>
<li>(void)decoder:(Decoder <em>)decoder willDecodeImage:(UIImage </em>)image usingSubset:(UIImage *)subset;</li>
<li>(void)decoder:(Decoder <em>)decoder didDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset withResult:(TwoDDecoderResult </em>)result {<br>NSLog(@”result = %@”, [result text]);<br>}</li>
<li>(void)decoder:(Decoder <em>)decoder failedToDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset reason:(NSString </em>)reason;</li>
<li>(void)decoder:(Decoder *)decoder foundPossibleResultPoint:(CGPoint)point;</li>
</ul>
<p>@end<br>Trouble Shoot &amp; Tips<br>我在使用中遇到了一些问题，主要是编译的问题。<br>一个是找不到 头文件。解决方法：把用到ZXing的源文件扩展名由.m改成.mm。<br>报错：Undefined symbols for architecture armv7s，解决方法：把ZXingWidget的一个build target参数：”Build Active Architecture Only” 修改成 “NO”.<br>报错：No such file or directory，出现该错误可能是你的Header Search Path写错了，或者就是你的zxing库的目录结构不是我上面强调的，好好检查一下吧。<br>如果你需要生成二维码做测试，推荐一个不错的在线生成二维码的网站：<a href="http://cli.im/" target="_blank" rel="external">http://cli.im/</a><br>ZXing和OpenCV的兼容问题<br>ZXing 2.1 和OpenCV 2.4.3的iOS库有一些兼容问题，他们对C++标准库的版本和编译器版本都有一些需求，造成满足一方了，另一方就编译不通过了。Stackoverflow上有人终于找到了一个让它们和平共处的方法，但是只适用于iOS5.0以上版本。正好我们的App只支持iOS5.0+，所以就搞定了。所以如果你也正好遇到这个问题，可以参考这个贴子。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/20/iOS中使用ZXing库/" data-id="cipjh2n8o000ldhs61334v8i8" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS应用内支付小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/14/iOS应用内支付小结/" class="article-date">
  <time datetime="2014-01-14T13:53:23.000Z" itemprop="datePublished">2014-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/14/iOS应用内支付小结/">iOS应用内支付小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>我们在今年春节后上线了新的在线智能题库：猿题库。这应该是我们在互联网教育这个创业领域尝试的第二个方向。<br>猿题库现在推出了公务员考试行测和申论 2 个产品，均包括 web, iOS 和 Android 三个平台。这次我们尝试做一个收费的产品，所以在 iOS 端集成了应用内支付（IAP）功能。在开发过程中和上线后，我们遇到了 IAP 中的一些坑，在此分享给各位。<br>IAP 审核相关的坑<br>IAP 开发的详细步骤我写在 另一篇博客 中了。在此主要介绍审核时遇到的问题。<br>IAP 类型错误<br>由于我们是按月付费的产品，所以在设置 IAP 类型时，我没有经验，只是简单设置成了可重复消费 (Consumable) 的 IAP 项目。但是我不知道，苹果对于这种按时间收费的产品，应该使用不可更新的定阅（Non-Renewing Subscription）类型。这个类型设置错误造成了我们 app 的一次审核被拒。<br>IAP 验证逻辑<br>由于苹果在 iOS5.0 以下有 IAP 的 bug，使得攻击者可以伪造支付成功的凭证。而 iOS6.0 的系统在越狱后同样可以伪造凭证，所以我们对于应用内支付，增加了服务器端的验证。<br>服务器端会将支付凭证发给苹果的服务器进行二次验证，以保证凭证是真实有效的。<br>在我们公司的测试服务器中，我们会连接苹果的测试服务器（ <a href="https://sandbox.itunes.apple.com/verifyReceipt" target="_blank" rel="external">https://sandbox.itunes.apple.com/verifyReceipt</a> ）验证。<br>在我们部署在线上的正式服务器中，我们会连接苹果的正式服务器（ <a href="https://buy.itunes.apple.com/verifyReceipt" target="_blank" rel="external">https://buy.itunes.apple.com/verifyReceipt</a> ）验证。<br>我们提交给苹果审核的是正式版，我们以为苹果审核时，我们应该连接苹果的线上验证服务器来验证购买凭证。结果我理解错了，苹果在审核 App 时，只会在 sandbox 环境购买，其产生的购买凭证，也只能连接苹果的测试验证服务器。但是审核的 app 又是连接的我们的线上服务器。所以我们这边的服务器无法验证通过 IAP 购买，造成我们 app 的又一次审核被拒。<br>解决方法是判断苹果正式验证服务器的返回 code，如果是 21007，则再一次连接测试服务器进行验证即可。苹果的 这一篇文档 上有对返回的 code 的详细说明。<br>IAP 上线后的遇到的情况<br>我们在服务器端增加了验证 IAP 是否有效的逻辑。在产品上线后，如我们所料，我们收到了大量的欺骗性购买，这些都被我们的服务器识别出来了，但是我们也遇到了以下这次没有想到的情况:<br>1、由于国内越狱用户的比例比较大 (2012 年底国内越狱比例是 42%), 所以虽然我们服务器会验证购买凭证，但是每天有超过 50% 以上的凭证都是伪造的。同时由于苹果的验证服务器在美国，凭证验证请求响应的时间比较慢，大量的伪造凭证发给苹果服务器，不知道会不会被苹果认为我们是在恶意进行 DDOS。至少我们发现有些时候，验证请求会超时。<br>2、由于国内有许多小白用户，他们的手机从购买时就被渠道商帮忙越狱过了并且安装了 IAP free 插件。所以对于这类用户，他们即使想付费购买，由于系统原有的 IAP 支付功能已经被破坏，所以他们是无法正常付费的。麻烦的是，他们会以为这是我们的 app 的问题，转而给我们的客服打电话投诉。这让我们非常郁闷。<br>3、苹果的验证服务器有时候会出问题，我们发现本来约定好返回的 JSON 数据在有几次返回的居然是一个 XML 格式的文件。造成我们将正常的付费 IAP 凭证验证失败。所以，在服务器记录下所有的验证凭证非常有必要，一来可以防止黑客多次提交同一个成功凭证的重放攻击，二来在需要时可以手工进行再验证。<br>越狱手机可能被黑客窃取购买凭证！！<br>我们发现有一部分用户反馈说已经收到苹果的扣费账单，但是我们从服务器的验证记录看，他上传的凭证却是虚假的。由于这些用户不太多，我们一开始以为是用户在恶意欺骗我们，后来我们让他将苹果的付费账单邮件转发给我们，以及将 itunes 的购买记录截图转发给我们，随着讨论的深入，我们越来越怀疑这里面有一个黑色的产业链。越狱手机的正常购买凭证可能被黑客的恶意程序截获，具体的攻击方式我们讨论了一下，其实就是被 中间人攻击，详细的过程如下:<br>越狱手机的在被破解后，可能从一些破解渠道安装了黑客的恶意程序。<br>黑客将越狱手机所有 https 请求都经过他的中间服务器。<br>当有支付请求时，黑客先将请求发给苹果服务器，待苹果将成功的凭证返回后，黑客将这个凭证替换成假的凭证，完全支付凭证的偷取。<br>或许有人会问，这个凭证拿来有什么用呢 ? 很简单 ，因为苹果为了保护用户的隐私，支付凭证中并不包含任何用户的 apple id 信息，所以我们的 app 和服务器无法知道这个凭证是谁买的，而只能知道这个凭证是真的还是假的。于是黑客就可以用这个凭证，在另外的账号中通知我们完成了购买，而发来的验证凭证又是真实的，所以我们的服务器就会误认为是黑客的账号完成了购买，继而把会员期算在黑客的账号上。<br>再举一个简单的例子，你拿 500 块钱买了顺风优选的 500 元购物券，由于这个购物券是不记名的，所以顺风优选无法知道是谁买的。如果这个购物券在发放过程中被人掉包，那么偷购物券的人就可以拿这个偷来的真购物券来购物，而顺风优选的卡因为是不记名的，所以也无法查证这件事情。在这个例子中，购物券的不记名和苹果的支付凭证无账号信息是同一个道理。<br>鉴于以上情况，考虑到越狱手机不但不能成功支付，还会有安全问题，所以我们在新版中取消了越狱手机中的 IAP 支付功能。<br>所以，请大家还是不要越狱自己的手机，iPhone 手机越狱后风险相当大。实在不值得为了免费玩几个游戏就丢掉安全性。<br>后记<br>中间人攻击的演示<br>iOS 独立开发者 王轲 _IndieBros 在他的博客文章 《使用 mitmproxy 获取 iTunes 11 的 Raw HTTPs Response》 中演示了如何使用中间人攻击来修改 Game Center 游戏数据。王轲还把我的例子白话翻译了一下（可见我还是说得太绕了，囧）：<br>坏人在购买过程中插了一腿，换走了用户的无记名发票（购物小票形象些），然后手持无记名小票伪装成真实顾客或者转手出售获利。<br>关于越狱与盗版<br>不少细心的同学评论纠正我，指出越狱并不等同于使用盗版。确实，如果说严格的定义，越狱只是让 iPhone 获得 root 权限，进而可以做任何事情。如果越狱的同学在越狱后不安装 IAP free 插件，不使用 app sync 插件，不使用任何国内的和非 bigboss 的 cydia 源，不使用任何盗版软件，所有应用都是从 app store 官方网站上下载的话，被黑客攻击的可能性会降低一些。<br>即使这样，由于手机已经被 root 了，苹果的沙盒安全机制失效，所以风险还是很大的。<br>关于越狱用户的比例<br>有同学提出我文章中写的越狱手机比例太高了，想询问数据来源。这个比例主要来自我们自己的 app 的统计信息，以及结合国内的统计工具友盟的 越狱手机比例统计，去年底国内的越狱比例是 42%。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/14/iOS应用内支付小结/" data-id="cipjh2n8c000hdhs6gnlcrpx7" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-从Facebook看iOS移动端的开发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/01/从Facebook看iOS移动端的开发/" class="article-date">
  <time datetime="2014-01-01T13:47:31.000Z" itemprop="datePublished">2014-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/01/从Facebook看iOS移动端的开发/">从Facebook看iOS移动端的开发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>从 Facebook 谈起<br>Facebook 最近绝对是互联网界的新闻明星。它首先是进行了大手笔的收购：2014 年 2 月，Facebook 以 160 亿美元现金加股票，以及 30 亿美元受限制股票福利的方式 收购移动 IM 应用 WhatsApp，总收购成本 190 亿美元。然后是继续发布了新产品：2014 年 2 月，Facebook 发布了一个新的移动端新闻阅读应用 Paper。最后，Facebook 最近还将自己使用的大量工具开源，包括开源了 Paper 的加载效果 Shimmer，LLDB 的增强工具 chisel，以及 Key-Value Observing 工具 KVOController，如果说这些开源工具让程序员如获至宝的话，那么 Facebook 将 Paper 的交互设计工具 Origami 免费开放，则是对广大设计师的福音，极大地方便了移动交互设计工作的开展。<br>2014 年对于 Facebook 来说也是一个值得纪念的日子。因为从 2004 年 2 月 4 日 Facebook 产品上线到现在，Facebook 刚刚走过 10 个年头。10 年前，Facebook 的创始人扎克伯格才 19 岁，是哈佛大学的一名学生。转眼间 10 年后，Facebook 已经成长为全球最大的社交网络，月活跃用户达到 12 亿，市值约 1200 亿美元。<br>业界内大多讨论的话题都围绕在 Facebook 收购 WhatsApp 这件事情上，而作为一个移动开发者，我更加看重 Facebook 发布 Paper 这件事情。因为 Paper 并不是一个简单的应用，它有着非常优秀的交互效果，并且在产品设计和技术上都使用了许多前沿的技术，那就让我们看看，Paper 的开发到底有何不同之处？<br>交互设计<br>我们首先从产品设计上看 Paper 的不同之处。Paper 虽然只是一个新闻客户端，但从大家对 Paper 的评价上，我们发现优秀的交互再一次成为大家关注的焦点。回想那些成功的应用，大多都有着令人心动的交互效果，例如：Tweetie 的下拉刷新，现在基本上成为 iPhone 上内容刷新的标准。Path 跳出来的红心让人心动，很多朋友甚至会没事点那个红心，欣赏那流畅的按钮散开效果。还有 Mailbox，用流畅的手势操作，将邮件管理与任务管理完美结合起来。<br>国外成功的优秀应用也在影响着国内。交互设计不同于平面设计，不能简单地用 Photoshop 展现，而交互设计对于移动应用的成功又异常关键，所以需要花费不少时间来设计，因此产品经理很难兼顾地做交互设计。所以，在国内的一线互联网公司里，交互设计师这个职位慢慢成了移动应用的标配。但是在大部分的非一线互联网公司里面，移动开发的设计仍然停留在由产品经理简单潦草的完成阶段。所以，Facebook 这次 Paper 的成功发布，再一次给移动开发的从业者指出了交互设计的重要性。<br>回顾中国互联网产业的发展我们可以发现，产品经理（Product Manager）这个职位也是最近五、六年才成为互联网公司的标配的，想必在不远的将来，除着交互设计越来越重要，移动交互设计师也会成为每一个互联网公司重要的必备职位。<br>另一方面，由于工具的欠缺，大量的交互设计师的工作效率非常低下，他们为了做出一个新颖的效果常常需要花费大量精力。这次 Facebook 免费开放出基于苹果 Quartz Composer 的增强工具集 Origami，使得交互设计工作得到更好的辅助。而且在 Facebook 的带动下，jQC 1.0 也出现了。jQC 是一个与 Facebook 之前开源的 Origami 兼容的工具，提供了 15 个新的 Patch 来提高 Quartz Composer 的功能。<br>不过另一方面，该工具仍然需要设计师具备一定的基础编码能力，所以对于广大设计师来说，交互设计工具 Origami 对设计师带来的既是机会，同时也是挑战。<br>移动开发技术<br>随着 iOS 依赖管理工具 Cocoapods 和大量第三方开源库成熟起来，业界积累了大量的优秀开源项目。这次 Facebook 开发 Paper 使用了 将近 100 个第三方开源库，极大地减化了自己的应用开发任务。相信随着移动开发的发展，移动开发的生态圈会越来越成熟，基础的开源组件也将将越来越丰富，广大开发者都将从中受益。<br>另一方面，Facebook 的工程师在 Quora 上反馈 说 Paper 在 Xcode 下打开需要 40 多秒钟，编译一次需要 30 分钟。这反映出大量的开源库的使用也给 iOS 集成编译环境 Xcode 提出了新的挑战，相信苹果会花大力气解决 Xcode 的性能问题。<br>总结<br>Facebook 发布的 Paper 让我看到了移动开发领域的快速发展，大量新的工具和开源技术给了设计师和程序员机会和挑战，相信在移动互联网快速发展的浪潮中，会涌现出越来越多优秀的移动应用。谁会是未来移动互联网的霸主？让我们拭目以待。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/01/从Facebook看iOS移动端的开发/" data-id="cipjh2n8l000jdhs6jrj1t8wt" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-用CocoaPods管理iOS程序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/30/用CocoaPods管理iOS程序/" class="article-date">
  <time datetime="2013-12-30T13:43:15.000Z" itemprop="datePublished">2013-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/30/用CocoaPods管理iOS程序/">用CocoaPods管理iOS程序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>CocoaPods 简介<br>每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如 Java 语言的 Maven，nodejs 的 npm。随着 iOS 开发者的增多，业界也出现了为 iOS 程序提供依赖管理的工具，它的名字叫做：CocoaPods。<br>CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，经过多年发展，现在已经成为 iOS 开发事实上的依赖管理标准工具。开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。<br>我在开发猿题库客户端时，使用了 24 个第三方开源库。在没有使用 CocoaPods 以前，我需要:<br>把这些第三方开源库的源代码文件复制到项目中，或者设置成 git 的 submodule。<br>对于这些开源库通常需要依赖系统的一些 framework，我需要手工地将这些 framework 分别增加到项目依赖中，比如通常情况下，一个网络库就需要增加以下 framework: CFNetwork, SystemConfiguration, MobileCoreServices, CoreGraphics, zlib。<br>对于某些开源库，我还需要设置-licucore或者 -fno-objc-arc等编译参数<br>管理这些依赖包的更新。<br>这些体力活虽然简单，但毫无技术含量并且浪费时间。在使用 CocoaPods 之后，我只需要将用到的第三方开源库放到一个名为 Podfile 的文件中，然后执行pod install。<br>CocoaPods 就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数。<br>CocoaPods 的安装和使用介绍<br>安装<br>安装方式异常简单 , Mac 下都自带 ruby，使用 ruby 的 gem 命令即可下载安装：<br>$ sudo gem install cocoapods<br>$ pod setup<br>如果你的 gem 太老，可能也会有问题，可以尝试用如下命令升级 gem:<br>sudo gem update –system<br>另外，ruby 的软件源 <a href="https://rubygems.org" target="_blank" rel="external">https://rubygems.org</a> 因为使用的是亚马逊的云服务，所以被墙了，需要更新一下 ruby 的源，使用如下代码将官方的 ruby 源替换成国内淘宝的源：<br>gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a><br>gem sources -a <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a><br>gem sources -l<br>还有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度。你也可以参考本文接下来的使用 cocoapods 的镜像索引一节的内容来提高下载速度。<br>使用 CocoaPods 的镜像索引<br>所有的项目的 Podspec 文件都托管在<a href="https://github.com/CocoaPods/Specs。第一次执行pod" target="_blank" rel="external">https://github.com/CocoaPods/Specs。第一次执行pod</a> setup时，CocoaPods 会将这些podspec索引文件更新到本地的 ~/.cocoapods/目录下，这个索引文件比较大，有 80M 左右。所以第一次更新时非常慢，笔者就更新了将近 1 个小时才完成。<br>一个叫 akinliu 的朋友在 gitcafe 和 oschina 上建立了 CocoaPods 索引库的镜像，因为 gitcafe 和 oschina 都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将 CocoaPods 设置成使用 gitcafe 镜像：</p>
<p>pod repo remove master<br>pod repo add master <a href="https://gitcafe.com/akuandev/Specs.git" target="_blank" rel="external">https://gitcafe.com/akuandev/Specs.git</a><br>pod repo update<br>将以上代码中的 <a href="https://gitcafe.com/akuandev/Specs.git" target="_blank" rel="external">https://gitcafe.com/akuandev/Specs.git</a> 替换成 <a href="http://git.oschina.net/akuandev/Specs.git" target="_blank" rel="external">http://git.oschina.net/akuandev/Specs.git</a> 即可使用 oschina 上的镜像。<br>使用 CocoaPods<br>使用时需要新建一个名为 Podfile 的文件，以如下格式，将依赖的库名字依次列在文件中即可<br>platform :ios<br>pod ‘JSONKit’,       ‘~&gt; 1.4’<br>pod ‘Reachability’,  ‘~&gt; 3.0.0’<br>pod ‘ASIHTTPRequest’<br>pod ‘RegexKitLite’<br>然后你将编辑好的 Podfile 文件放到你的项目根目录中，执行如下命令即可：<br>cd “your project home”<br>pod install<br>现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下 2 点即可：<br>使用 CocoaPods 生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。<br>每次更改了 Podfile 文件，你需要重新执行一次pod update命令。<br>查找第三方库<br>你如果不知道 cocoaPods 管理的库中，是否有你想要的库，那么你可以通过 pod search 命令进行查找，以下是我用 pod search json 查找到的所有可用的库：<br>$ pod search json</p>
<p>-&gt; AnyJSON (0.0.1)<br>Encode / Decode JSON by any means possible.</p>
<ul>
<li>Homepage: <a href="https://github.com/mattt/AnyJSON" target="_blank" rel="external">https://github.com/mattt/AnyJSON</a></li>
<li>Source:   <a href="https://github.com/mattt/AnyJSON.git" target="_blank" rel="external">https://github.com/mattt/AnyJSON.git</a></li>
<li>Versions: 0.0.1 [master repo]</li>
</ul>
<p>-&gt; JSONKit (1.5pre)<br>A Very High Performance Objective-C JSON Library.</p>
<ul>
<li>Homepage: <a href="https://github.com/johnezang/JSONKit" target="_blank" rel="external">https://github.com/johnezang/JSONKit</a></li>
<li>Source:   git://github.com/johnezang/JSONKit.git</li>
<li>Versions: 1.5pre, 1.4 [master repo]</li>
</ul>
<p>// … 以下省略若干行<br>关于 Podfile.lock<br>当你执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，Podfile.lock 应该加入到版本控制里面，不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致。<br>CocoaPods 的这篇 官方文档 也在What is a Podfile.lock一节中介绍了Podfile.lock的作用，并且指出：<br>This file should always be kept under version control.<br>为自己的项目创建 podspec 文件<br>我们可以为自己的开源项目创建podspec文件，首先通过如下命令初始化一个podspec文件：<br>pod spec create your_pod_spec_name<br>该命令执行之后，CocoaPods 会生成一个名为your_pod_spec_name.podspec的文件，然后我们修改其中的相关内容即可。<br>具体步骤可以参考这两篇博文中的相关内容：<br>《如何编写一个 CocoaPods 的 spec 文件》<br>《Cocoapods 入门》。<br>使用私有的 pods<br>我们可以直接指定某一个依赖的podspec，这样就可以使用公司内部的私有库。该方案有利于使企业内部的公共项目支持 CocoaPods。如下是一个示例：<br>pod ‘MyCommon’, :podspec =&gt; ‘<a href="https://yuantiku.com/common/myCommon.podspec" target="_blank" rel="external">https://yuantiku.com/common/myCommon.podspec</a>‘<br>不更新 podspec<br>CocoaPods 在执行pod install和pod update时，会默认先更新一次podspec索引。使用–no-repo-update参数可以禁止其做索引更新操作。如下所示：<br>pod install –no-repo-update<br>pod update –no-repo-update<br>生成第三方库的帮助文档<br>如果你想让 CococaPods 帮你生成第三方库的帮助文档，并集成到 Xcode 中，那么用 brew 安装 appledoc 即可：<br>brew install appledoc<br>关于 appledoc，我在另一篇博客 《使用 Objective-C 的文档生成工具:appledoc》 中有专门介绍。它最大的优点是可以将帮助文档集成到 Xcode 中，这样你在敲代码的时候，按住 opt 键单击类名或方法名，就可以显示出相应的帮助文档。<br>原理<br>大概研究了一下 CocoaPods 的原理，它是将所有的依赖库都放到另一个名为 Pods 项目中，然后让主项目依赖 Pods 项目，这样，源码管理工作都从主项目移到了 Pods 项目中。发现的一些技术细节有：<br>Pods 项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个 .a 文件即可。<br>对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh 的 bash 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。<br>CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖和参数。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/30/用CocoaPods管理iOS程序/" data-id="cipjh2n8u000odhs65a62llo9" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS开发如何提高" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/24/iOS开发如何提高/" class="article-date">
  <time datetime="2013-12-24T13:38:32.000Z" itemprop="datePublished">2013-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/24/iOS开发如何提高/">iOS开发如何提高</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>阅读博客<br>在现在这个碎片化阅读流行的年代，博客的风头早已被微博盖过。而我却坚持写作博客，并且大量地阅读同行的 iOS 开发博客。博客的文章长度通常在 3000 字左右，许多 iOS 开发知识都至少需要这样的篇幅才能完整地讲解清楚。并且博客相对于书籍来说，并没有较长的出版发行时间，所以阅读博客对于获取最新的 iOS 开发知识有着非常良好的效果。<br>我自己精心整理了国内 40 多位 iOS 开发博主的博客地址列表：<a href="https://github.com/tangqiaoboy/iOSBlogCN，希望大家都能培养起阅读博客的习惯。" target="_blank" rel="external">https://github.com/tangqiaoboy/iOSBlogCN，希望大家都能培养起阅读博客的习惯。</a><br>国外也有很多优秀的 iOS 开发博客，他们整体质量比中文的博客更高，以下是一些推荐的博客地址列表：<br>博客名                        博客地址<br>objc.io                       <a href="http://www.objc.io/" target="_blank" rel="external">http://www.objc.io/</a><br>Ray Wenderlich               <a href="http://www.raywenderlich.com" target="_blank" rel="external">http://www.raywenderlich.com</a><br>iOS Developer Tips           <a href="http://iosdevelopertips.com/" target="_blank" rel="external">http://iosdevelopertips.com/</a><br>iOS Dev Weekly               <a href="http://iosdevweekly.com/" target="_blank" rel="external">http://iosdevweekly.com/</a><br>NSHipster                   <a href="http://nshipster.com/" target="_blank" rel="external">http://nshipster.com/</a><br>Bartosz Ciechanowski       <a href="http://ciechanowski.me" target="_blank" rel="external">http://ciechanowski.me</a><br>Big Nerd Ranch Blog           <a href="http://blog.bignerdranch.com" target="_blank" rel="external">http://blog.bignerdranch.com</a><br>Nils Hayat    <a href="http://nilsou.com/" target="_blank" rel="external">http://nilsou.com/</a><br>另外，使用博客 RSS 聚合工具（例如 Feedly：<a href="http://www.feedly.com/）可以获得更好的博客阅读体验。手机上也有很多优秀的博客阅读工具（我使用的是" target="_blank" rel="external">http://www.feedly.com/）可以获得更好的博客阅读体验。手机上也有很多优秀的博客阅读工具（我使用的是</a> Newsify）。合理地使用这些工具也可以将你在地铁上、睡觉前等碎片时间充分利用上。<br>读书<br>博客的内容通常只能详细讲解一个知识点，而书籍则能成体系地介绍整个知识树。相比国外，中国的书籍售价相当便宜，所以这其实是一个非常划算的提高的方式。建议大家每年至少坚持读完 1 本高质量的 iOS 开发书籍。<br>去年出版的 《iOS 7 Programming Pushing the Limits》 以及 《Objective-C 高级编程：iOS 与 OS X 多线程和内存管理》 都算是不错的进阶方面的读物。顺便打个广告，我自己也在写一本 iOS 进阶方面的图书，年底前应该能上市。<br>看 WWDC 视频<br>由于 iOS 开发在快速发展，每年苹果都会给我们带来很多新的知识。而对于这些知识，第一手的资料就是 WWDC 的视频。<br>通常情况下，一个 iOS 开发的新知识首先会在 WWDC 上被苹果公开，然后 3 个月左右，会有国内外的博客介绍这些知识，再过半年左右，会有国外的图书介绍这些知识。所以如果想尽早地了解这些知识，那么只有通过 WWDC 的视频。<br>现在每年的 WWDC 视频都会在会议过程中逐步放出，重要的视频会带有英文字幕。坚持阅读这些视频不但可以获得最新的 iOS 开发知识，还可以提高英文听力水平。<br>看苹果的官方文档<br>苹果的官方文档相当详尽，对于不熟悉的 API，阅读官方文档也是最直接有效地方式。<br>苹果的文档比较海量，适合选一些重点来阅读，比如人机交互指南就是必读的，而其它的内容可以遇到的时候作为重点资源来查阅。<br>看开源项目的代码<br>大家一定有这样的感受，很多时候用文字讲解半天，还不如写几行代码来得直观。阅读优秀的开源项目代码，不但可以学习到 iOS 开发本身的基本知识，还能学习到设计模式等软件架构上的知识。<br>如果读者能够参与到开源项目的开发中，则能进一步提高自己的能力。<br>多写代码，多思考<br>知识的积累离不开实践和总结，我认为 iOS 代码量如果没有超过 10 万行，是不能称得上熟悉 iOS 开发的。某些在校的学生，仅仅做了几个 C++ 的大作业，就在求职简历里面写上 “精通 C++”，则真是让人哭笑不得。<br>在多写代码的同时，我们也要注意不要 “ 重复造轮子 “，尽量保证每次写的代码都能具有复用性。在代码结构因为业务需求需要变更时，及时重构，在不要留下技术债的同时，我们也要多思考如何设计应用架构，能够保证满足灵活多变的产品需求。<br>在多次重构和思考的过程中，我们就会慢慢积累出一类问题的 “最佳实践” 方式，成为自己宝贵的经验。<br>多和同行交流<br>有些时候遇到一些难解的技术问题，和同行的几句交流就可能让你茅塞顿开。。另外常见的技术问题通常都有人以前遇到过，简单指导几句就能让你一下子找到正确的解决方向。<br>国内开发者之间的交流，可以通过论坛，微博，QQ 群等方式来进行。另外各大公司有时候会办技术沙龙，这也是一个认识同行的好机会。<br>需要特别提醒的是，和国内开发者之前交流要注意讨论质量，有一些论坛和 QQ 群讨论质量相当低下，提的问题都是能通过简单 Google 获得的，这种社区一定要远离，以提高自己的沟通效率。<br>除了在国内的技术社区交流，建议读者可以去国外的 stackoverflow：<a href="http://www.stackoverflow.com" target="_blank" rel="external">http://www.stackoverflow.com</a> 上提问或回答问题。<br>分享<br>值得尝试的分享方式有：发起一个开源项目、写技术博客、在技术会议上做报告。这几种方式都比较有挑战，但是如果能大胆尝试，肯定会有巨大的收获。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/24/iOS开发如何提高/" data-id="cipjh2n8f000idhs611ueib9p" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="写ios-SDK注意问题小结" class="article article-type-写ios" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/14/SDK注意问题小结/" class="article-date">
  <time datetime="2013-12-14T13:35:15.000Z" itemprop="datePublished">2013-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/14/SDK注意问题小结/">SDK注意问题小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>我发现即使是像腾讯、小米这样的大厂提供的 SDK，在质量和规范上也有很多问题，而且包括我以及我身边的很多朋友都被恶心到了，所以我就把这些注意事项总结出来，希望大家不要犯同样的错误。<br>注意事项一：所有类名都应该加前缀<br>说明：没有前缀的类名有冲突的风险。<br>Bad Case：微信分享的 SDK，文件名：WXApiObject.h，代码如下，其中BaseReq类和BaseResp类都没有加前缀。<br>@interface BaseReq : NSObject</p>
<p>/<strong> 请求类型 */<br>@property (nonatomic, assign) int type;<br>/</strong> 由用户微信号和 AppID 组成的唯一标识，发送请求时第三方程序必须填写，用于校验微信用户是否换号登录 <em>/<br>@property (nonatomic, retain) NSString</em> openID;</p>
<p>@end</p>
<p>#pragma mark - BaseResp<br>/<em>! @brief 该类为微信终端 SDK 所有响应类的基类
</em><br><em>/<br>@interface BaseResp : NSObject<br>/** 错误码 </em>/<br>@property (nonatomic, assign) int errCode;<br>/<strong> 错误提示字符串 <em>/<br>@property (nonatomic, retain) NSString </em>errStr;<br>/</strong> 响应类型 */<br>@property (nonatomic, assign) int type;</p>
<p>@end<br>注意事项二：所有 category 方法加前缀<br>说明：category 方法如果不加前缀，有冲突的风险。<br>Bad Case：腾讯分享的 SDK，它为 NSArray 增加了一个 JSONArray 的 category，造成我们本身的同名 category 被覆盖。另外他们为 NSArray 增加的其它 category 和著名的 Cordova 开源库冲突，造成 Cordova 无法使用。<br>注意事项三：不要将第三方库打包进 SDK<br>说明：尽量不要将第三方库打包进 SDK，如果要打包，最好也要将该第三方库重命名，以避免冲突。<br>Bad Case：小米的推送 SDK，直接在 SDK 静态库里面编进去一个第三方依赖库，而且这个库还是 ASIHttpRequest。ASIHttp 当前已经处于无人维护状态，很多 Bug 都是大家自己在修复（例如网易就自己维护了一个 ASIHttpRequest 的分支）。在 SDK 中依赖这种库还是比较麻烦的。<br>注意事项四：做基本的检查和测试<br>说明：SDK 对外公布前应该进行基本的编译检查，不应该有编译器警告存在。<br>Bad Case：腾讯分享的 SDK。它的 CGIParamsWrap.o 和 TencentOAuth.o 文件里面的方法名冲突了，如下所示：<br>ld: warning: instance method ‘deleteAPIRequestBySeq:’ in category from /Users/tangqiao/work/iphone/solar-ios/lib_common/TencentOpenApi/TencentOpenAPI.framework/TencentOpenAPI(CGIParamsWrap.o) overrides method from class in /Users/tangqiao/work/iphone/solar-ios/lib_common/TencentOpenApi/TencentOpenAPI.framework/TencentOpenAPI(TencentOAuth.o)<br>注意事项五：文档完整并且正确<br>说明：这就不用解释了吧？<br>Bad Case: 微信官方的微信支付的示例代码，里面有各种错误，代码都无法编译成功。如下所示的是其中一个错误：</p>
<p>于是还有人专门帮微信另外制作了一个非官方的说明文档，地址在这里：<a href="https://github.com/gbammc/WechatPayDemo" target="_blank" rel="external">https://github.com/gbammc/WechatPayDemo</a><br>注意事项六：支持最新的 CPU 版本<br>说明：去年苹果的一次 Bug，造成上传应用必须支持 arm64 的 CPU 版本，结果众多应用因为依赖的 SDK 不支持 arm64 而无法更新。当然，这次 Bug 出来之后，各 SDK 厂商都紧急做了更新。但是我觉得这种事情如果要做得专业，就应该一开始就紧跟技术更新，及时更新，而不是被迫更新。<br>总结<br>以上 6 点是我认为写一个 SDK 的最最基本的要求，希望被点名批评的同学能尽快改正哟～<br>如果大家在使用其它 SDK 时也发现了类似的问题，欢迎在文章下面留言。希望通过这种方式给开发相关 SDK 的同学一些压力，让他们好好改一下。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/14/SDK注意问题小结/" data-id="cipjh2n7f0006dhs6fb9odec9" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-培训出来的iOS学员怎么了？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/06/培训出来的iOS学员怎么了？/" class="article-date">
  <time datetime="2013-12-06T13:27:43.000Z" itemprop="datePublished">2013-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/06/培训出来的iOS学员怎么了？/">培训出来的iOS学员怎么了？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>今天就想和大家聊聊这个沉重的话题。<br>诚信的恶性循环<br>首先我们说说简历造假吧。在我看来，简历造假还是时常遇到的。我认识礼物说的 CTO，我们 iOS 群里常常有朋友面试时遇到说自己在礼物说工作过的候选人，为什么呢？还不是网上有一堆高仿礼物说的 APP，自己下载下来看看，然后就可以假装是自己做的了。<br>为什么很多候选人选择造假呢？除了简历不够好之外，造假很多时候确实有用。对于很多小公司来说，面试官自己也不懂如何面试 iOS 开发，那么就特别容易被忽悠。<br>但是，一个公司里面有 iOS 开发者，然后再稍微懂一些面试技巧的话，简历造假是很容易发现的。关于怎么在面试中鉴别造假，我们在下一节聊。<br>我们先聊聊看造假会造成什么危机呢？对于面试公司来说，如果他发现面试的效率特别低，或者招进来的人干活不行时，他会怎么办呢？<br>我觉得他会很直接地开地图炮，把一类人直接刷掉，不再给面试机会。这类人是哪些人？简历雷同的、培训机构培训出来的人。<br>这样公平吗？对候选人肯定不公平，但是公司招人也需要讲效率的，面试候选人其实成本特别高。<br>所以造假这个行为，最终伤害的是候选人本人，以及培训机构的信誉。<br>如何在面试中鉴别造假<br>其实挺简单的，首先面试的时候不要设置固定问题，然后根据候选人的回答情况来深入问细节。<br>就比如说一个候选人说他做过礼物说，那就有很多可以深入问的，比如问他：<br>礼物说有几个 iOS 开发<br>大家是如何分工的<br>你负责的那块最主要的难点在哪里<br>团队整个协作的过程<br>在开发的时候有没有遇到需求变更<br>功能上线后大概的数据是什么样的<br>你觉得哪些地方还需要改进<br>你们主要的竞争对手是谁，他们在哪些技术方面比你们做得好<br>一个谎话要编容易，难的是每一个细节都编得面面俱到，所以深入细节问，很容易就会露馅。<br>我是培训机构学员怎么办<br>简单地说，公司招一个人最终级的目的还是把活干好。如果一个培训机构的学员，没有实际的工作能力，单凭几个月的培训就想一劳永逸地找一份好工作，这是不现实的。<br>互联网技术日新月异，iOS 开发每年技术都在更新，如果指望所有知识都是从培训机构那儿获得，那么早晚都会被淘汰。<br>所以，即使你当前是培训机构出来的学员，也必须培养自己实际解决问题的能力和自学能力。这样才能一点点地增强自己的实力。<br>另外说一个残酷的现实，公司一般不会给你大块的上班时间用来学习新知识的。所以大多数学习充电过程只能是在下班后或周末。<br>我们应该怎么看待培训机构学员<br>我自己就招过一个培训机构出来的学员，她还是一个女生，现在工作得挺棒的。她是非计算机专业毕业的，参加培训机构学了 3 个月就来我们公司面试。她能通过面试，很大程度上是因为她不止参加了培训班的课，而且自己在网上学习了计算机数据结构和算法的基础知识，而且是看的国外的课程。<br>当时面试时我完全没有考查她 iOS 知识，因为她承认只参加了 3 个月的培训。所以我考查了一下她自学数据结构和算法的情况。结果让我觉得她是一个自学能力还不错的女生，所以我就把她招了进来。<br>刚进来带她做 iOS 费了一些精力，但是很快她就可以上手自己做事情了。现在，我已经完全把小猿搜题的 iOS 端交给她来负责。我想她就是一个培训机构出来学员的成功案例。<br>我们并不鄙视培训机构的学生，但是我们不认同那些没有自学能力，认为参加 3 个月培训就可以拿高薪的「投机者」。这个行业虽然高薪，但是也很辛苦，如果没有兴趣和毅力，是没办法做好的。<br>搞 iOS 开发到底需要什么核心能力<br>大家看了我上次采访的 YYKit 作者的文章 后，或许就能明白，其实一个人核心的能力就是学习能力。有强大的学习能力，那么就可以像 YYKit 作者那样，才接触 iOS 开发一年多就可以开源出大量优秀的作品。<br>基本上，一个人在一个领域坚持投入大量的时间，很难做得不好。所以你是一个培训机构的学员，苦于找不到工作。与其简历造假拿到面试机会，倒不如再多花花精力，自己多专研一些代码，写一些 App，不要那么急功近利，我想结果都会好很多。<br>愿培训机构出来的 iOS 学员都能找一份好工作。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/06/培训出来的iOS学员怎么了？/" data-id="cipjh2n8m000kdhs65ezvv7kh" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-Runtime全方位装逼小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/11/27/iOS-Runtime全方位装逼小结/" class="article-date">
  <time datetime="2013-11-27T13:10:55.000Z" itemprop="datePublished">2013-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/27/iOS-Runtime全方位装逼小结/">iOS_Runtime全方位装逼小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>楔子<br>Runtime是什么？见名知意，其概念无非就是“因为 Objective-C 是一门动态语言，所以它需要一个运行时系统……这就是 Runtime 系统”云云。对博主这种菜鸟而言，Runtime 在实际开发中，其实就是一组C语言的函数。胡适说：“多研究些问题，少谈些主义”，云山雾罩的概念听多了总是容易头晕，接下来我们直接从代码入手学习 Runtime。</p>
<p>1、由objc_msgSend说开去：<br>Objective-C 中的方法调用，不是简单的方法调用，而是发送消息，也就是说，其实 [receiver message] 会被编译器转化为: objc_msgSend(receiver, selector)，何以证明？新建一个类 MyClass，其.m文件如下：</p>
<p>#import “MyClass.h”<br>@implementation MyClass</p>
<p>-(instancetype)init{<br>if (self = [super init]) {<br>[self showUserName];<br>}<br>return self;<br>}</p>
<p>-(void)showUserName{<br>NSLog(@”Dave Ping”);<br>}<br>使用 clang 重写命令:</p>
<p>$ clang -rewrite-objc MyClass.m<br>然后在同一目录下会多出一个 MyClass.cpp 文件，双击打开，可以看到 init 方法已经被编译器转化为下面这样：</p>
<p>static instancetype _I_MyClass_init(MyClass <em> self, SEL _cmd) {<br>if (self = ((MyClass </em>(<em>)(__rw_objc_super </em>, SEL))(void <em>)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(“MyClass”))}, sel_registerName(“init”))) {<br>((void (</em>)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(“showUserName”));<br>}<br>return self;<br>}<br>我们要找的就是它：</p>
<p>((void (<em>)(id, SEL))(void </em>)objc_msgSend)((id)self, sel_registerName(“showUserName”))<br>objc_msgSend 函数被定义在 objc/message.h 目录下，其函数原型是酱紫滴：</p>
<p>OBJC_EXPORT void objc_msgSend(void /<em> id self, SEL op, … </em>/ )<br>该函数有两个参数，一个 id 类型，一个 SEL 类型。</p>
<p>2、SEL<br>SEL 被定义在 objc/objc.h 目录下：</p>
<p>typedef struct objc_selector *SEL;<br>其实它就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获得一个 SEL 类型的方法选择器。</p>
<p>3、id<br>与 SEL 一样，id 也被定义在 objc/objc.h 目录下：</p>
<p>typedef struct objc_object *id;<br>id 是一个结构体指针类型，它可以指向 Objective-C 中的任何对象。objc_object 结构体定义如下：</p>
<p>struct objc_object { Class isa OBJC_ISA_AVAILABILITY;};<br>我们通常所说的对象，就长这个样子，这个结构体只有一个成员变量 isa，对象可以通过 isa 指针找到其所属的类。isa 是一个 Class 类型的成员变量，那么 Class 又是什么呢？</p>
<p>4、Class<br>Class 也是一个结构体指针类型：</p>
<p>typedef struct objc_class *Class;<br>objc_class 结构体是酱紫滴：</p>
<p>struct objc_class {<br>Class isa  OBJC_ISA_AVAILABILITY;</p>
<p>#if !<strong>OBJC2</strong><br>Class super_class                                        OBJC2_UNAVAILABLE;<br>const char <em>name                                         OBJC2_UNAVAILABLE;<br>long version                                             OBJC2_UNAVAILABLE;<br>long info                                                OBJC2_UNAVAILABLE;<br>long instance_size                                       OBJC2_UNAVAILABLE;<br>struct objc_ivar_list </em>ivars                             OBJC2_UNAVAILABLE;<br>struct objc_method_list <em>*methodLists                    OBJC2_UNAVAILABLE;<br>struct objc_cache </em>cache                                 OBJC2_UNAVAILABLE;<br>struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</p>
<p>#endif</p>
<p>} OBJC2_UNAVAILABLE;<br>我们通常说的类就长这样子：<br>·Class 也有一个 isa 指针，指向其所属的元类（meta）.<br>·super_class：指向其超类.<br>·name：是类名.<br>·version：是类的版本信息.<br>·info：是类的详情.<br>·instance_size：是该类的实例对象的大小.<br>·ivars：指向该类的成员变量列表.<br>·methodLists：指向该类的实例方法列表，它将方法选择器和方法实现地址联系起来。methodLists 是指向 ·objc_method_list 指针的指针，也就是说可以动态修改 *methodLists 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因.<br>·cache：Runtime 系统会把被调用的方法存到 cache 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高.<br>·protocols：指向该类的协议列表.</p>
<p>说到这里有点乱了，我们来捋一下，当我们调用一个方法时，其运行过程大致如下：</p>
<p>首先，Runtime 系统会把方法调用转化为消息发送，即 objc_msgSend，并且把方法的调用者，和方法选择器，当做参数传递过去.</p>
<p>此时，方法的调用者会通过 isa 指针来找到其所属的类，然后在 cache 或者 methodLists 中查找该方法，找得到就跳到对应的方法去执行.</p>
<p>如果在类中没有找到该方法，则通过 super_class 往上一级超类查找（如果一直找到 NSObject 都没有找到该方法的话，这种情况，我们放到后面消息转发的时候再说）.</p>
<p>前面我们说 methodLists 指向该类的实例方法列表，实例方法即-方法，那么类方法（+方法）存储在哪儿呢？类方法被存储在元类中，Class 通过 isa 指针即可找到其所属的元类.</p>
<p>上图实线是 super_class 指针，虚线是 isa 指针。根元类的超类是NSObject，而 isa 指向了自己。NSObject 的超类为 nil，也就是它没有超类。</p>
<p>5、使用objc_msgSend<br>前面我们使用 clang 重写命令，看到 Runtime 是如何将方法调用转化为消息发送的。我们也可以依样画葫芦，来学习使用一下 objc_msgSend。新建一个类 TestClass，添加如下方法：</p>
<p>-(void)showAge{<br>NSLog(@”24”);<br>}</p>
<p>-(void)showName:(NSString *)aName{<br>NSLog(@”name is %@”,aName);<br>}</p>
<p>-(void)showSizeWithWidth:(float)aWidth andHeight:(float)aHeight{<br>NSLog(@”size is %.2f * %.2f”,aWidth, aHeight);<br>}</p>
<p>-(float)getHeight{<br>return 187.5f;<br>}</p>
<p>-(NSString *)getInfo{<br>return @”Hi, my name is Dave Ping, I’m twenty-four years old in the year, I like apple, nice to meet you.”;<br>}<br>我们可以像下面这样，使用 objc_msgSend 依次调用这些方法：</p>
<p>TestClass *objct = [[TestClass alloc] init];</p>
<p>((void (*) (id, SEL)) objc_msgSend) (objct, sel_registerName(“showAge”));</p>
<p>((void (<em>) (id, SEL, NSString </em>)) objc_msgSend) (objct, sel_registerName(“showName:”), @”Dave Ping”);</p>
<p>((void (*) (id, SEL, float, float)) objc_msgSend) (objct, sel_registerName(“showSizeWithWidth:andHeight:”), 110.5f, 200.0f);</p>
<p>float f = ((float (*) (id, SEL)) objc_msgSend_fpret) (objct, sel_registerName(“getHeight”));<br>NSLog(@”height is %.2f”,f);</p>
<p>NSString <em>info = ((NSString</em> (*) (id, SEL)) objc_msgSend) (objct, sel_registerName(“getInfo”));<br>NSLog(@”%@”,info);<br>也许你已经注意到，objc_msgSend 在使用时都被强制转换了一下，这是因为 objc_msgSend 函数可以hold住各种不同的返回值以及多个参数，但默认情况下是没有参数和返回值的。如果我们把调用 showAge 方法改成这样：</p>
<p>objc_msgSend(objct, sel_registerName(“showAge”));<br>Xcode 就会报错：</p>
<p>Too many arguments to function call, expected 0, have 2.<br>完整的 objc_msgSend 使用代码在这里。</p>
<p>6、objc_msgSendSuper<br>编译器会根据情况在 objc_msgSend，objc_msgSend_stret，objc_msgSendSuper，objc_msgSendSuper_stret 或 objc_msgSend_fpret 五个方法中选择一个来调用。如果消息是传递给超类，那么会调用 objc_msgSendSuper 方法，如果消息返回值是数据结构，就会调用 objc_msgSendSuper_stret 方法，如果返回值是浮点数，则调用 objc_msgSend_fpret 方法。</p>
<p>这里我们重点说一下 objc_msgSendSuper，objc_msgSendSuper 函数原型如下：</p>
<p>OBJC_EXPORT void objc_msgSendSuper(void /<em> struct objc_super </em>super, SEL op, … */ )<br>当我们调用 [super selector] 时，Runtime 会调用 objc_msgSendSuper 方法，objc_msgSendSuper 方法有两个参数，super 和 op，Runtime 会把 selector 方法选择器赋值给 op。而 super 是一个 objc_super 结构体指针，objc_super 结构体定义如下：</p>
<p>struct objc_super {<br>/// Specifies an instance of a class.<br>__unsafe_unretained id receiver;</p>
<p>/// Specifies the particular superclass of the instance to message. </p>
<p>#if !defined(<strong>cplusplus)  &amp;  !</strong>OBJC2<strong><br>/<em> For compatibility with old objc-runtime.h header </em>/
</strong>unsafe_unretained Class class;</p>
<p>#else<br>__unsafe_unretained Class super_class;</p>
<p>#endif<br>/<em> super_class is the first class to search </em>/<br>};<br>Runtime 会创建一个 objc_spuer 结构体变量，将其地址作为参数（super）传递给 objc_msgSendSuper，并且将 self 赋值给 receiver：super—&gt;receiver=self.<br>举个栗子，问下面的代码输出什么：</p>
<p>@implementation Son : Father</p>
<ul>
<li>(id)init<br>{<br>self = [super init];<br>if (self)<br>{<br>NSLog(@”%@”, NSStringFromClass([self class]));<br>NSLog(@”%@”, NSStringFromClass([super class]));<br>}<br>return self;<br>}<br>@end<br>答案是全部输出 Son.<br>使用 clang 重写命令，发现上述代码被转化为:</li>
</ul>
<p>NSLog((NSString <em>)&amp;<strong>NSConstantStringImpl</strong>var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (</em>)(id, SEL))(void <em>)objc_msgSend)((id)self, sel_registerName(“class”))));<br>NSLog((NSString </em>)&amp;<strong>NSConstantStringImpl</strong>var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (<em>)(__rw_objc_super </em>, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass(“Son”)) }, sel_registerName(“class”))));<br>当调用 [super class] 时，会转换成 objc_msgSendSuper 函数：</p>
<p>第一步先构造 objc_super 结构体，结构体第一个成员就是 self。第二个成员是 (id)class_getSuperclass(objc_getClass(“Son”)).</p>
<p>第二步是去 Father 这个类里去找 – (Class)class，没有，然后去 NSObject 类去找，找到了。最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class)) 去调用，此时已经和 [self class] 调用相同了，所以两个输出结果都是 Son。</p>
<p>7、对象关联<br>对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：</p>
<p>OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) <strong>OSX_AVAILABLE_STARTING(</strong>MAC_10_6, __IPHONE_3_1);<br>·object 是源对象.<br>·value 是被关联的对象.<br>·key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.<br>·policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：</p>
<p>typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {<br>OBJC_ASSOCIATION_ASSIGN = 0,           /**<br>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：</p>
<p>objc_setAssociatedObject(self, associatedKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>objc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.<br>举个栗子，假如我们要给 UIButton 添加一个监听单击事件的 block 属性，新建 UIButton 的 Category，其.m文件如下：</p>
<p>#import “UIButton+ClickBlock.h”</p>
<p>#import </p>
<p>static const void *associatedKey = “associatedKey”;</p>
<p>@implementation UIButton (ClickBlock)</p>
<p>//Category中的属性，只会生成setter和getter方法，不会生成成员变量</p>
<p>-(void)setClick:(clickBlock)click{<br>objc_setAssociatedObject(self, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>[self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];<br>if (click) {<br>[self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];<br>}<br>}</p>
<p>-(clickBlock)click{<br>return objc_getAssociatedObject(self, associatedKey);<br>}</p>
<p>-(void)buttonClick{<br>if (self.click) {<br>self.click();<br>}<br>}</p>
<p>@end<br>然后在代码中，就可以使用 UIButton 的属性来监听单击事件了：</p>
<p>UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];<br>button.frame = self.view.bounds;<br>[self.view addSubview:button];<br>button.click = ^{<br>NSLog(@”buttonClicked”);<br>};<br>完整的对象关联代码点这里</p>
<p>8、自动归档<br>博主在学习 Runtime 之前，归档的时候是酱紫写的：</p>
<ul>
<li><p>(void)encodeWithCoder:(NSCoder *)aCoder{<br>[aCoder encodeObject:self.name forKey:@”name”];<br>[aCoder encodeObject:self.ID forKey:@”ID”];<br>}</p>
</li>
<li><p>(id)initWithCoder:(NSCoder *)aDecoder{<br>if (self = [super init]) {<br>self.ID = [aDecoder decodeObjectForKey:@”ID”];<br>self.name = [aDecoder decodeObjectForKey:@”name”];<br>}<br>return self;<br>}<br>那么问题来了，如果当前 Model 有100个属性的话，就需要写100行这种代码：</p>
</li>
</ul>
<p>[aCoder encodeObject:self.name forKey:@”name”];<br>想想都头疼，通过 Runtime 我们就可以轻松解决这个问题：<br>1.使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.<br>2.使用 ivar_getName 方法获取成员变量的名称.<br>3.通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.</p>
<p>举个栗子，新建一个 Model 类，其.m文件如下：</p>
<p>#import “TestModel.h”</p>
<p>#import </p>
<p>#import </p>
<p>@implementation TestModel</p>
<ul>
<li>(void)encodeWithCoder:(NSCoder <em>)aCoder{<br>unsigned int outCount = 0;<br>Ivar </em>vars = class_copyIvarList([self class], &amp;outCount);<br>for (int i = 0; i<br>完整的自动归档代码在这里</li>
</ul>
<p>9、字典与模型互转<br>最开始博主是这样用字典给 Model 赋值的：</p>
<p>-(instancetype)initWithDictionary:(NSDictionary *)dict{<br>if (self = [super init]) {<br>self.age = dict[@”age”];<br>self.name = dict[@”name”];<br>}<br>return self;<br>}<br>可想而知，遇到的问题跟归档时候一样（后来使用MJExtension），这里我们稍微来学习一下其中原理，字典转模型的时候：<br>1.根据字典的 key 生成 setter 方法.<br>2.使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.</p>
<p>模型转字典的时候：<br>1.调用 class_copyPropertyList 方法获取当前 Model 的所有属性.<br>2.调用 property_getName 获取属性名称.<br>3.根据属性名称生成 getter 方法.<br>4.使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.</p>
<p>代码如下：</p>
<p>#import “NSObject+KeyValues.h”</p>
<p>#import </p>
<p>#import </p>
<p>@implementation NSObject (KeyValues)</p>
<p>//字典转模型<br>+(id)objectWithKeyValues:(NSDictionary <em>)aDictionary{<br>id objc = [[self alloc] init];<br>for (NSString </em>key in aDictionary.allKeys) {<br>id value = aDictionary[key];</p>
<p>/<em>判断当前属性是不是Model</em>/<br>objc_property_t property = class_getProperty(self, key.UTF8String);<br>unsigned int outCount = 0;<br>objc_property_attribute_t <em>attributeList = property_copyAttributeList(property, &amp;outCount);<br>objc_property_attribute_t attribute = attributeList[0];<br>NSString </em>typeString = [NSString stringWithUTF8String:attribute.value];<br>if ([typeString isEqualToString:@”@”TestModel””]) {<br>value = [self objectWithKeyValues:value];<br>}<br>/<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>/</p>
<p>//生成setter方法，并用objc_msgSend调用<br>NSString <em>methodName = [NSString stringWithFormat:@”set%@%@:”,[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];<br>SEL setter = sel_registerName(methodName.UTF8String);<br>if ([objc respondsToSelector:setter]) {<br>((void (</em>) (id,SEL,id)) objc_msgSend) (objc,setter,value);<br>}<br>}<br>return objc;<br>}</p>
<p>//模型转字典<br>-(NSDictionary <em>)keyValuesWithObject{<br>unsigned int outCount = 0;<br>objc_property_t </em>propertyList = class_copyPropertyList([self class], &amp;outCount);<br>NSMutableDictionary *dict = [NSMutableDictionary dictionary];<br>for (int i = 0; i<br>完整代码在这里</p>
<p>10、动态方法解析<br>前面我们留下了一点东西没说，那就是如果某个对象调用了不存在的方法时会怎么样，一般情况下程序会crash，错误信息类似下面这样：</p>
<p>unrecognized selector sent to instance 0x7fd0a141afd0<br>但是在程序crash之前，Runtime 会给我们动态方法解析的机会，消息发送的步骤大致如下：</p>
<p>1.检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数了.</p>
<p>2.检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉.</p>
<p>3.如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行.<br>如果 cache 找不到就找一下方法分发表.</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/11/27/iOS-Runtime全方位装逼小结/" data-id="cipjh2n82000cdhs61xclr1lm" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS多线程编程基础小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/11/20/iOS多线程编程基础小结/" class="article-date">
  <time datetime="2013-11-20T13:06:30.000Z" itemprop="datePublished">2013-11-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/20/iOS多线程编程基础小结/">iOS多线程编程基础小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>一、基本概念<br>计算机操作系统都有的基本概念，以下概念简单方式来描述。</p>
<p>进程： 一个具有一定独立功能的程序关于某个数据集合的一次运行活动。可以理解成一个运行中的应用程序。</p>
<p>线程： 程序执行流的最小单元，线程是进程中的一个实体。</p>
<p>同步： 只能在当前线程按先后顺序依次执行，不开启新线程。</p>
<p>异步： 可以在当前线程开启多个新线程执行，可不按顺序执行。</p>
<p>队列： 装载线程任务的队形结构。</p>
<p>并发： 线程执行可以同时一起进行执行。</p>
<p>串行： 线程执行只能依次逐一先后有序的执行。</p>
<p>注意:</p>
<p>一个进程可有多个线程。</p>
<p>一个进程可有多个队列。</p>
<p>队列可分并发队列和串行队列。</p>
<p>二、iOS多线程对比</p>
<ol>
<li>NSThread</li>
</ol>
<p>每个NSThread对象对应一个线程，真正最原始的线程。</p>
<p>1）优点：NSThread 轻量级最低，相对简单。</p>
<p>2）缺点：手动管理所有的线程活动，如生命周期、线程同步、睡眠等。</p>
<ol>
<li>NSOperation</li>
</ol>
<p>自带线程管理的抽象类。</p>
<p>1）优点：自带线程周期管理，操作上可更注重自己逻辑。</p>
<p>2）缺点：面向对象的抽象类，只能实现它或者使用它定义好的两个子类：NSInvocationOperation 和 NSBlockOperation。</p>
<ol>
<li>GCD</li>
</ol>
<p>Grand Central Dispatch (GCD)是Apple开发的一个多核编程的解决方法。</p>
<p>1）优点：最高效，避开并发陷阱。</p>
<p>2）缺点：基于C实现。</p>
<ol>
<li>选择小结</li>
</ol>
<p>1）简单而安全的选择NSOperation实现多线程即可。</p>
<p>2）处理大量并发数据，又追求性能效率的选择GCD。</p>
<p>3）NSThread本人选择基本上是在做些小测试上使用，当然也可以基于此造个轮子。</p>
<p>三、场景选择<br>图片异步加载。这种常见的场景是最常见也是必不可少的。异步加载图片有分成两种来说明一下。</p>
<p>第一种，在UI主线程开启新线程按顺序加载图片，加载完成刷新UI。</p>
<p>第二种，依然是在主线程开启新线程，顺序不定地加载图片，加载完成个字刷新UI。</p>
<p>创作工具上的异步。 这个跟上边任务调度道理，只是为了丰富描述，有助于“举一反三”效果。如下描述的是app创作小说。</p>
<p>场景一，app本地创作10个章节内容未成同步服务器，同时发表这10个章节产生的一系列动作，其中上传内容，获取分配章节Id，如何后台没有做处理最好方式做异步按顺序执行。</p>
<p>场景二，app本地创作列表中有3本小说为发表，同时发表创作列表中的3本小说，自然考虑并行队列执行发表。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/11/20/iOS多线程编程基础小结/" data-id="cipjh2n8a000gdhs6zwc3x7z1" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-IOS开发之多线程技术小结2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/11/14/IOS开发之多线程技术小结2/" class="article-date">
  <time datetime="2013-11-14T12:59:47.000Z" itemprop="datePublished">2013-11-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/14/IOS开发之多线程技术小结2/">IOS开发之多线程技术小结2</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>三、如何使用多线程技术<br>ios中多线程实现的多种技术方案：</p>
<p>POSIX 表示可移植操作系统接口（Portable Operating System Interface )—–pthread</p>
<p>1）pthread技术：<br>pthread 是 POSIX 多线程开发框架，由于是跨平台的 C 语言框架，在苹果的头文件中并没有详细的注释要查阅 pthread 有关资料，可以访问 <a href="http://baike.baidu.com" target="_blank" rel="external">http://baike.baidu.com</a></p>
<p>// 创建线程，并且在线程中执行 demo 函数</p>
<ul>
<li>(void)pthreadDemo {</li>
</ul>
<p>/<em>*<br>参数：<br>1&gt; 指向线程标识符的指针，C 语言中类型的结尾通常 _t/Ref，而且不需要使用 </em><br>2&gt; 用来设置线程属性<br>3&gt; 新建立的线程执行代码的函数<br>4&gt; 运行函数的参数</p>
<p>返回值：</p>
<ul>
<li>若线程创建成功，则返回0</li>
<li>若线程创建失败，则返回出错编号</li>
</ul>
<p>在混合开发时，如果在 C 和 OC 之间传递数据，需要使用 __bridge 进行桥接，桥接的目的就是为了告诉编译器如何管理内存<br><em>/<br>pthread_t threadId = NULL;<br>NSString </em>str = @”Hello Pthread”;</p>
<p>int result = pthread_create(&amp;threadId, NULL, demo, (__bridge void *)(str));</p>
<p>result ? NSLog(@”为其他任何值时代表开辟子线程失败”) : NSLog(@”当result为0时表示开辟子线程成功”);<br>}</p>
<p>// 后台线程调用函数<br>void <em>demo(void </em>params) {<br>NSString <em>str = (__bridge NSString </em>)(params);</p>
<p>NSLog(@”%@ - %@”, [NSThread currentThread], str);</p>
<p>return NULL;<br>}</p>
<p>C语言中pthread.h里pthread实现多线程<br>2）NSThread技术：</p>
<ul>
<li>(void)viewDidLoad {<br>[super viewDidLoad];</li>
</ul>
<p>NSLog(@”主线程%@”, [NSThread currentThread]);<br>/<em>*<br>多个线程之间的执行顺序是随机的
</em>/</p>
<p>// 方式1：通过NSThread的对象方法<br>NSThread *thread = [[NSThread alloc] initWithTarget:self selector:@selector(demo:) object:@”方式1”];<br>[thread start];</p>
<p>// 方式2：没有thread字眼，隐式创建并启动线程，所有 NSObject 都可以使用此方法，在其他线程执行方法<br>[self performSelectorInBackground:@selector(demo:) withObject:@”方式2”];</p>
<p>// 方式3：detachNewThreadSelector 类方法不需要启动，会自动创建线程并执行 @selector 方法<br>[NSThread detachNewThreadSelector:@selector(demo:) toTarget:self withObject:@”方式3”];</p>
<p>}</p>
<ul>
<li>(void)demo:(NSString *)str {<br>NSLog(@”%@, %@”, str, [NSThread currentThread]);<br>}</li>
</ul>
<p>通过NSThread创建线程的三种方式<br>2.1）线程属性</p>
<ol>
<li><p>name - 线程名称</p>
</li>
<li><p>threadPriority - 线程优先级</p>
</li>
</ol>
<p>取值范围从 0~1.0</p>
<p>1.0表示优先级最高</p>
<p>0.0表示优先级最低</p>
<p>默认优先级是0.5</p>
<ol>
<li><p>stackSize - 栈区大小</p>
</li>
<li><p>isMainThread - 是否主线程</p>
</li>
</ol>
<p>2.2）资源共享(抢夺)<br>1块资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源，比如多个线程访问同一个对象、同一个变量、同一个文件当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题。如购买火车票问题：</p>
<p>解决方案:</p>
<p>#pragma mark</p>
<p>#pragma mark - 模拟卖票系统</p>
<ul>
<li>(void)sellTicket {</li>
</ul>
<p>_count = 50;</p>
<p>NSThread *thread1 = [[NSThread alloc] initWithTarget:self selector:@selector(ticket) object:nil];<br>thread1.name = @”t1”;<br>[thread1 start];</p>
<p>NSThread *thread2 = [[NSThread alloc] initWithTarget:self selector:@selector(ticket) object:nil];<br>thread2.name = @”t2”;<br>[thread2 start];<br>}</p>
<ul>
<li>(void)ticket {</li>
</ul>
<p>while (YES) {</p>
<p>// 被加锁的对象<br>@synchronized(self) {<br>if (_count &gt; 0) {<br>_count = self.count - 1;<br>NSLog(@”剩余票数%ld ——%@”, _count, [NSThread currentThread]);<br>} else {<br>NSLog(@”票卖没了倒霉蛋”);<br>break;<br>}<br>}<br>}</p>
<p>}</p>
<p>卖票系统线程同步解决线程不安全问题<br>互斥锁 ：如果发现有其他线程正在执行锁定的代码，线程会 进入休眠状态 ，等待其他线程执行完毕，打开锁之后，线程会被 唤醒<br>自旋锁 ：如果发现有其他线程正在执行锁定的代码，线程会以 死循环 的方式，一直等待锁定代码执行完成<br>线程安全</p>
<p>多个线程进行读写操作时，仍然能够得到正确结果，被称为线程安全，要实现线程安全，必须要用到锁、为了得到更佳的用户体验，UIKit 不是线程安全的，所以更新 UI 的操作都必须主线程上执行！因此，主线程又被称为UI 线程。</p>
<p>3）GCD技术<br>为保证篇幅不过与杂糅，请见“IOS开发之多线程技术——GCD篇”</p>
<p>4) NSOperation技术<br>为保证篇幅不过与杂糅，请见“IOS开发之多线程技术——NSOperation篇”</p>
<p>四、线程的生命周期（线程状态）<br>新建</p>
<p>实例化线程对象</p>
<p>就绪</p>
<ul>
<li>(void)start;</li>
</ul>
<p>向线程对象发送 start 消息，线程对象被加入 可调度线程池 等待 CPU 调度</p>
<p>detachNewThreadSelector 方法和 performSelectorInBackground 方法会直接实例化一个线程对象并加入 可调度线程池</p>
<p>运行</p>
<p>CPU 负责调度可调度线程池中线程的执行</p>
<p>线程执行完成之前(死亡之前)，状态可能会在就绪和运行之间来回切换</p>
<p>就绪和运行之间的状态变化由 CPU 负责，程序员不能干预</p>
<p>阻塞</p>
<p>当满足某个预定条件时，可以使用休眠或锁阻塞线程执行</p>
<ul>
<li><p>(void)sleepUntilDate:(NSDate *)date;</p>
</li>
<li><p>(void)sleepForTimeInterval:(NSTimeInterval)ti;</p>
</li>
</ul>
<p>@synchronized(self)：互斥锁死亡:+ (void)exit</p>
<p>正常死亡</p>
<p>线程执行完毕</p>
<p>非正常死亡</p>
<p>当满足某个条件后，在线程内部自己中止执行(自杀),[NSThread exit];</p>
<p>当满足某个条件后，在主线程给其它线程打个死亡标记(下圣旨),让子线程自行了断.(被逼着死亡)</p>
<p>注意:在终止线程之前，应该注意释放之前分配的对象!<br></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/11/14/IOS开发之多线程技术小结2/" data-id="cipjh2n6w0000dhs64p44md1j" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/02/15/搞定iOS与js交互/">搞定iOS与js交互</a>
          </li>
        
          <li>
            <a href="/2016/01/28/移动直播开发技术介绍/">移动直播开发技术介绍</a>
          </li>
        
          <li>
            <a href="/2016/01/22/Bilibili开源的直播框架/">Bilibili开源的直播框架</a>
          </li>
        
          <li>
            <a href="/2016/01/14/iOS三种视屏录制方式/">iOS三种视屏录制方式</a>
          </li>
        
          <li>
            <a href="/2015/11/23/iOS-通讯录写法/">iOS_通讯录写法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>