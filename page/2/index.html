<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>孙利峰的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="孙利峰的技术博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="孙利峰的技术博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孙利峰的技术博客">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="孙利峰的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">孙利峰的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天幕红尘</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS-20款插件的优缺点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/11/07/iOS-20款插件的优缺点/" class="article-date">
  <time datetime="2015-11-07T08:29:26.000Z" itemprop="datePublished">2015-11-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/11/07/iOS-20款插件的优缺点/">iOS_20款插件的优缺点</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>本文大致整理了自己用过的一些插件的使用感想（就是好不好用）。 在那之前先简单贴两条插件须知，知道的可以忽略。</p>
<p>1、Alcatraz</p>
<p>类似于管理第三方库的cocoapods，管理插件也有个Alcatraz。 </p>
<p>安装的方法也很简单，如果你以前没有安装过那执行下面指令</p>
<p>curl -fsSL <a href="https://raw.github.com/alcatraz/Alcatraz/master/Scripts/install.sh" target="_blank" rel="external">https://raw.github.com/alcatraz/Alcatraz/master/Scripts/install.sh</a> | sh<br>如果之前安装过但是Xcode最新版本不能用了，那就先卸载旧的再安装下新的。</p>
<p>卸载的方法是：</p>
<p>rm -rf ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins/Alcatraz.xcplugin<br>rm -rf ~/Library/Application\ Support/Alcatraz/<br>注：也许并不是所有人都使用了Alcatraz，而是平时都喜欢上github下载一个跑一下 然后load Bundle这种方法的， 如果之前安装了很多插件，现在刚刚使用Alcatraz的也没问题，安装Alcatraz之后之前安装的也会自动集成进来不用担心。</p>
<p>还有就算你使用了这个工具xcode也是需要重启才能应用插件的并不能把这一步给省了。</p>
<p>2、更新插件</p>
<p>不管你是用直接download zip的方法安装插件的还是用Alcatraz安装的插件如果插件本身没有最新xcode的支持，那在你的Xcode更新一个版本后，Xcode插件就会失效了。 这个问题就是没有把最新版本xcode的DVTPlugInCompatibilityUUID配到插件的支持列表中。</p>
<p>先获取，终端中输入</p>
<p>defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID<br>然后按照如下目录~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins</p>
<p>找到插件列表，选中对应的插件显示包内容，并打开info.plist文件 在这个数组中添加最新的UUID即可</p>
<p>也有更犀利的做法就是：</p>
<p>find ~/Library/Application\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add UUID<br>最后面的UUID是前面获取到的。</p>
<p>推荐插件<br>下面进入正题，说说我喜欢用的插件，基本算是一个使用心得吧。 全都附上了连接，没贴动图以免太乱，基本连接的github中都有效果图。</p>
<p>1.VVDocumenter-Xcode 三道杠添加文档注释<br><a href="https://github.com/onevcat/VVDocumenter-Xcode" target="_blank" rel="external">https://github.com/onevcat/VVDocumenter-Xcode</a></p>
<p>所有插件里这个是我最早使用的也应该是排第一的。 使用也非常方便但是用久了也许会发现自动生成的注释是每一个参数和返回值都会弹出一个块，而我们日常开发中大部分的参数和返回值都是一眼见分晓的，并不需要逐个标注，这也就使得我每次敲三道杠都还要手动删除一部分，比较麻烦。 如果作者能提供下一种是现有的，另一种敲法是只有Description的那我会非常方便。  或者有个更烧脑的猜想，就是在现有基础上判断参数是否是基本数据类型还是特殊类型，特殊类型的参数才生成注释代码块。返回值如果是instancetype那就不需要生成注释代码块，或者判断参数名如果是一个常用单词（time）还是组合词（categoryID），常用单词就不生成注释了也许会更好。也许是我想多了，反正这个插件是必用的，更何况现在连swift都支持了。</p>
<ol>
<li>SCXcodeMiniMap  右边显示小地图</li>
</ol>
<p><a href="https://github.com/stefanceriu/SCXcodeMiniMap" target="_blank" rel="external">https://github.com/stefanceriu/SCXcodeMiniMap</a></p>
<p>这是类似于sublime的功能，这是非常好用的。 并且右边的代码迷你地图提供了很多可配置的地方，而且会高亮显示宏和注释部分，小地图中点击任何地方也会自动滚动至此。这在有的类代码特别长时你写着写着都不知道自己在哪里了 会很有用。（如果你经常用 pragma mark那你当我没说）</p>
<p>3.FuzzyAutocomplete  代码补全支持模糊查询<br><a href="https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin" target="_blank" rel="external">https://github.com/FuzzyAutocomplete/FuzzyAutocompletePlugin</a></p>
<p>代码补全时可以不用从头开始敲，只要记得某个特定词汇就能匹配到。 并且对于项目中有好几种前缀的比如我们以前有的事MT前缀有的是MTB前缀，这种就算你前缀敲漏了只要后面对了也能匹配的到。 当然也有弊端就是你敲一个很普通的方法下面都会匹配一大长串，看着有点冗余而且xcode会比较卡，并且敲出来是好好地如果你想用delete一个个字符往回删就可能会出现xcode,crash了（也许是和其他某个插件产生了冲突，我错怪他了）。用不用看个人喜好吧，因为苹果有很多诡异的api，比如Rect 他是CGRectMake ，但是到了Range 他又是NSMakeRange 用了这个插件就不会被他坑了。<br>4.KSImageNamed  用图片时自动显示图片缩略图</p>
<p><a href="https://github.com/ksuther/KSImageNamed-Xcode" target="_blank" rel="external">https://github.com/ksuther/KSImageNamed-Xcode</a></p>
<p>也是非常残暴的一个功能，在开发中我们的图片名称都是fb_poinum_high类似的，用这个插件敲出前缀就能够看到对应的一批图片缩略图再上下选择非常方便。 不足之处也有，那就是已经敲完的代码想看到图片缩略图必须先把imageNamed删掉 再重新敲一次才能看到缩略图，如果在@”fb_poinum_high” 图片名中一修改就能看到图片列表就更好了。<br>5.HOStringSense  可以在弹出框写NSString，所见及所得</p>
<p><a href="https://github.com/holtwick/HOStringSense-for-Xcode" target="_blank" rel="external">https://github.com/holtwick/HOStringSense-for-Xcode</a></p>
<p>之前有几次需求要写换行的msg，有时候对不准，用这个插件非常方便。在弹出框里写完就是所见即所得。而且光标点到字符串的时候还会显示字符串的长度，这个功能我也很常用。</p>
<p>6.GitDiff  简单直观的标记本次commit修改的部位</p>
<p><a href="https://github.com/johnno1962/GitDiff" target="_blank" rel="external">https://github.com/johnno1962/GitDiff</a></p>
<p>这个插件在企业级App的开发中，使用率非常高，效果非常好。 坐标文件列表中的M,D,A,A+,? 可以很快的显示你有哪些文件修改了。 但是精确到文件里 这个插件就能很好的展示，默认是新增的位置显示绿色，修改的位置显示红色。 当然这些也都是可配置的。 （虽然xcode或终端也有很多方法能对比看diff但是没有这样简单直观）<br>7.xvim  把xcode的编辑页面可支持vim操作</p>
<p><a href="https://github.com/JugglerShu/XVim" target="_blank" rel="external">https://github.com/JugglerShu/XVim</a></p>
<p>引入这个插件之后，在xcode的正常代码页面的光标就会变成vim里面的方块了，熟悉vim指令的骨灰级攻城狮应该特别喜欢这款插件，dd直接删除一行，dw删一个单词 用着的确是很爽。 用了一段时间发现其实对xcode的、原始的编码方式改动（这里也可以说是侵入性）并不大，因为按下s就是编辑啊 就和xcode原来一样了任何功能都不少，按下esc又切换到vim非常犀利。总之是特别好用，而且看github点星也有3000+吧，并且不断有人提issue，现在已经非常完善了。</p>
<p>8.XAlign   提供各种自动对齐方案</p>
<p><a href="https://github.com/qfish/XAlign" target="_blank" rel="external">https://github.com/qfish/XAlign</a></p>
<p>这个插件实现了很多种自动对齐的功能，非常残暴。支持“=” “@” 和property 的自动对齐。 安装之后就赶紧把项目所有牵扯到的地方都用快捷键敲一下吧。说意见的话就是暂时还不支持大括号和缩进自动对齐。</p>
<ol>
<li>BBUDebuggerTuckAway   敲代码时debug视图自动隐藏</li>
</ol>
<p><a href="https://github.com/neonichu/BBUDebuggerTuckAway" target="_blank" rel="external">https://github.com/neonichu/BBUDebuggerTuckAway</a></p>
<p>提供微操的插件，功能简单，但是非常实用。敲代码敲快了的人，或者是在改Bug时，RUN一下再调试几行这种操作是会循环多次进行的。这个时候就会了解到这么不起眼的功能带来了多大的惊喜。</p>
<p>10.Backlight-for-XCode  高亮显示正在编辑的行<br><a href="https://github.com/limejelly/Backlight-for-XCode" target="_blank" rel="external">https://github.com/limejelly/Backlight-for-XCode</a></p>
<p>也是一个微操的插件，功能简单，就是你正在编辑的这行代码高亮显示。并且这个颜色和显示方案都是可配置的。这个插件有两个很大的好处一是在滚轮上下寻找代码时有一个方向指引知道自己正在编辑的方法在什么位置，二是有的一行代码很长折行成了两三行但是实际上还是一行代码，那这一坨都会高亮显示。不足之处就是作者可能没有设定好默认值，你刚安装后发现没有效果，要去菜单把功能打开才有效果并且坐着设置的默认高亮色是白色 =。=</p>
<ol>
<li>cocoapods-xcode-plugin  pod相关的操作可以在xcode菜单进行</li>
</ol>
<p><a href="https://github.com/kattrali/cocoapods-xcode-plugin" target="_blank" rel="external">https://github.com/kattrali/cocoapods-xcode-plugin</a></p>
<p>一般App在pod稳定了之后应该会很少修改，但是这个库提供的功能也是极好的，可以实现pod install，新建/修改 podfile，新建/修改 podspec文件。用习惯了终端iterm的人可能不太适应，习惯用source tree的人可能会觉得这个插件很爽~</p>
<p>12.ColorSense  输入颜色时有一个色板给你选</p>
<p><a href="https://github.com/omz/ColorSense-for-Xcode" target="_blank" rel="external">https://github.com/omz/ColorSense-for-Xcode</a></p>
<p>在使用colorWithRGB的时候，可以点出一个颜色选择框直接选择颜色，但是这个功能在使用了Wonderful或是企业级App里用处不大，因为是个项目都有视觉规范，应该都写成一个特定的宏了，就算没有视觉规范，那好歹也有个RGB(r,g,b,a) 这种宏吧。 [UIColor colorWithRed:233/255.0 Green:213/255.0 Blue:12/255.0 alpha] 这种代码还是很不美观的。如果是测试demo之类的用这个插件可以。</p>
<p>13.SCXcodeSwitchExpander   switch枚举的时候会自动生成代码</p>
<p><a href="https://github.com/stefanceriu/SCXcodeSwitchExpander" target="_blank" rel="external">https://github.com/stefanceriu/SCXcodeSwitchExpander</a></p>
<p>如果你的项目中有使用枚举会非常方便，自动生成了所有可能，并且每种里面都包含代码块，可以直接tab切换。  虽然使用率不会特别高但是用到的时候还是非常方便的。以前偷懒时我都写case：1 case：2  现在可以走向规范了。</p>
<p>14.DerivedData Exterminator   一键删除Derived Data</p>
<p><a href="https://github.com/kattrali/deriveddata-exterminator" target="_blank" rel="external">https://github.com/kattrali/deriveddata-exterminator</a></p>
<p>使用此插件之后，view菜单里多了一些操作，可以一键删除Derived Data。有时候在调试，启动图，launch screen，navgationBar appearance，之类的功能可能需要经常删derived data来调试。以前的方案应该是需要打开xcode偏好 locations 里面去删除，现在方便了不少。 不足之处就是删除这个项目的Derived Data 和删除All Derived Data 直接放在一起，手一滑就点错了。有的人电脑性能慢，项目大你一下把别的项目的Derived Data也删了 以后重新Build一下就太慢了。还有记得以前有小工具就是能够把正在运行的工程的主目录在find中显示，用来调试数据缓存的，这个库如果集成了这个功能就更好了。</p>
<p>15.XcodeColors  控制台打印彩色log</p>
<p><a href="https://github.com/robbiehanson/XcodeColors" target="_blank" rel="external">https://github.com/robbiehanson/XcodeColors</a></p>
<p>有的人会说彩色log 可以用DDLog啊，这个插件和DDLog是可以共同作用的， 也可以只用这个插件。 至少我用这个插件还是觉得挺好用的。自定义一个宏就可以在适当的敌地方彩色答应了 比较轻量级。不足之处也有，就是如果你项目中写了很多这样的代码，但是如果用别人没有装这个插件的xcode来跑 那就没有效果了啊。不过也无妨顶多就是调试栏不显示颜色罢了。</p>
<p>16.OMQuickHelp  option+点击会直接用dash打开</p>
<p><a href="https://github.com/omz/Dash-Plugin-for-Xcode" target="_blank" rel="external">https://github.com/omz/Dash-Plugin-for-Xcode</a></p>
<p>dash是一个非常强大的查看api和文档的工具，在这个里面能下载和看到各个平台的文档。 普通的option+点击会弹出一个小悬浮窗显示api相关信息，如果用了这个插件会直接在dash中打开相应的文档，前提是dash中已经下载过xcode对应的文档，再前提是你得安装了dash。 dash在苹果商店是卖几十块钱的，而且中国区域也搜不到dash。这里提供一个dash破解版的下载地址：<a href="http://share.weiyun.com/6fe485efbd9fc160dbc815639b65085b" target="_blank" rel="external">http://share.weiyun.com/6fe485efbd9fc160dbc815639b65085b</a> (密码：xzGP) (你要是问我为什么不用百度云？ 我想说百度云呵呵)</p>
<p>17.DXXcodeConsoleUnicodePlugin  debug栏打印时自动把/ueo6转化成汉字</p>
<p><a href="https://github.com/dhcdht/DXXcodeConsoleUnicodePlugin" target="_blank" rel="external">https://github.com/dhcdht/DXXcodeConsoleUnicodePlugin</a></p>
<p>在我们前后端联调接口的时候，一般都是url贴到浏览器json数据到了chrome自动转化（前提是你安装了jsonformater插件）。但是有时候比如POST请求结果不能在浏览器中看到，只能在debug中打断点了打印了如果遇到 msg:/ue06/ud07/ug08 这种会很蛋疼。这个插件安装后就是能让你在debug的console里面把这些uinicode转化成汉字显示。 这里说到了console的优化 我也顺便提个小技巧就是让console里可以po出 id类型的信息（正常情况你po id类型的对象会显示error）在终端依次输入下面三行指令</p>
<p>touch ~/.lldbinit<br>echo display @import UIKit &gt;&gt; ~/.lldbinit<br>echo target stop-hook add -o \”target stop-hook disable\” &gt;&gt; ~/.lldbinit</p>
<p>18.XToDo  快捷键标记，和统一查看<br><a href="https://github.com/trawor/XToDo" target="_blank" rel="external">https://github.com/trawor/XToDo</a></p>
<p>之前设置TODO 和标记某处??? 我都是手敲一个特定的符号，然后找的时候再去全文搜索。 有了这个插件，可以用快捷键添加TODO 和 FIXME （额这里如果用代码块也是可以相同实现的）。然后提供了TODOList 快速查看自己各处的标记。等于是省去了一个搜索的步骤。 但是不足就是，ToDoList的对话框是一个悬浮的而不是像上面的SCXcodeMiniMap或是GitDiff那样是嵌入在xcode里面的，这样在来回点的时候xcode的焦点和对话框的焦点会来回切换，虽然你是置顶的但还是比较影响体验。我用搜索的话就不用来回切焦点了。 但是这个插件本身还是很不错的。<br>19.XActivatePowerMode  敲代码时屏幕抖动火花迸溅效果<br><a href="https://github.com/qfish/XActivatePowerMode" target="_blank" rel="external">https://github.com/qfish/XActivatePowerMode</a></p>
<p>这是装逼插件，模仿sublime的一款 敲代码火花迸溅效果的插件。也许有的人觉得只有火花不需要有抖动，当然这些效果都可以在菜单里打开和关闭。但是有问题就是，这个插件和上面的FuzzyAutocomplete共同作用时，会很卡，直接xcodecrash，所以慎入。</p>
<p>20.ActivatePowerMode  敲代码时屏幕抖动火花迸溅效果</p>
<p><a href="https://github.com/poboke/ActivatePowerMode" target="_blank" rel="external">https://github.com/poboke/ActivatePowerMode</a></p>
<p>功能和上面的相似并且更狠，还带响声。但是让xcode变卡的问题同样存在。 而且这个插件比上面高端之处在于迸溅的火花的颜色和编辑位置的代码颜色相同，作者找到了配色方案返回颜色的私有api得到代码颜色。 迸溅效果更接近sublime上的效果。有人因为又用机械键盘 又带响导致手被剁了，所以这个也慎入。<br>其实还有一些插件也很火，比如codepilot3相当于xcode中的Aifred但是升级xcode7之后就不能使用了，也许是按键冲突还是什么，他们官网就是无脑CMD+Shift+x打开搜索框。但是如果按下无效呢？也没有个菜单让这个快捷键可以设置，看代码库也的确是很久没更新了； 还有插件能让你的xcode直接跳到github显示代码对比这些，感觉并没有必要啊，而且有时候github打开很慢，很没有连贯性啊； 还有插件能够你在.m写完方法的实现之后自动给你在.h文件生成方法声明，也是觉得画蛇添足 这些等等可能是我个人用起来不爽这里就都不提了。<br>还有插件不建议装的太多，觉得从上面挑些自己有用的装5~8个即可，多了xcode会很卡，而且会经常crash。如果真的遇到xcode经常crash的问题也没事不用担心，把那个插件目录下的插件全部清除，无需重装xcode也是可以恢复正常的。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/11/07/iOS-20款插件的优缺点/" data-id="cipjtn9jl0009sis6o78kjevc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-上传自己写的库到cocoaPods" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/10/20/上传自己写的库到cocoaPods/" class="article-date">
  <time datetime="2015-10-20T08:42:45.000Z" itemprop="datePublished">2015-10-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/20/上传自己写的库到cocoaPods/">上传自己写的库到cocoaPods</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>1.首先你需要有一个自我感觉写的差不多的库。</p>
<p>2.注册trunk</p>
<p>$sudo gem install cocoapods<br>pod trunk register dantesx2012@gmail.com ‘dsxniubility’  –verbose<br>第一个指令是更新一下cocoapods不管你现在是什么版本，这个指令也都没有坏处，他会升级到目前最高的正式版。</p>
<p>第二个指令建议邮箱名和用户名与自己的github同步，之后去自己的邮箱中找到该邮件点击验证的链接完成注册。</p>
<p>如果你不是在董铂然博客园看到本文，请点击查看原文。</p>
<p>完成之后再次进入终端查看自己注册信息</p>
<p>pod trunk me<br>如果成功的话可以看到如下图所示<br>3.配置自己的podspec文件</p>
<p>这是最重要的一步，配置里面的信息必须按照要求填写，否则会各种让你不通过。</p>
<p>这里有两种方案，一是自动生成,二是找一个现成的podspec文件改改。</p>
<p>这里建议第二种，因为第一种自动生成的东西里面会有很多用不到。第二种可以去github上找一些优秀代码把podspec打开看看再修改，这里我直接把我的贴出来了，免得去找了。建议使用sublime打开或vim修改，因为用普通的txt打开的话会出现诸如中英文单引号等一些列问题十分蛋疼。<br>Pod::Spec.new do |s|<br>s.name = ‘SXWaveAnimate’<br>s.version = ‘1.3.6’<br>s.license = ‘MIT’<br>s.summary = ‘An Animate Water view on iOS.’<br>s.homepage = ‘<a href="https://github.com/dsxNiubility/SXWaveAnimate" target="_blank" rel="external">https://github.com/dsxNiubility/SXWaveAnimate</a>‘<br>s.authors = { ‘董尚先’ =&gt; ‘dantesx2012@gmail.com’ }<br>s.source = { :git =&gt; ‘<a href="https://github.com/dsxNiubility/SXWaveAnimate.git" target="_blank" rel="external">https://github.com/dsxNiubility/SXWaveAnimate.git</a>‘, :tag =&gt; s.version.to_s }<br>s.requires_arc = true<br>s.ios.deployment_target = ‘8.0’<br>s.source_files = ‘SXWaveAnimate/<em>.{h,m}’<br>s.resources = ‘SXWaveAnimate/images/</em>.{png,xib}’<br>end<br>这里的每一行感觉都是顾名思义很容易理解，需要注意的是最下方的source_files 和 resources 一定要分清，需要编译器编译的放在前者，资源文件放在后者。我之前坑了一次，把xib放在前者了，后面的步骤一路畅通，但是到最后pod install自己代码下来就会遇到编译不通过的问题。</p>
<p>如果你需要直接把自己demo程序中Images.xcassets里的图片取出来当资源文件可以这么写</p>
<p>s.resources = [‘SXWaveAnimate/<em>.xib’, ‘SXWaveAnimateDemo/</em>.xcassets’]<br>4.上传代码<br>把自己的项目提一次commit到github上。</p>
<p>再打一下tag<br>git tag ‘1.0.0’<br>git push –tags<br>tag和commit是两个不同的机制，就算commit全被reset了通过tag也可以找回代码。</p>
<p>5.提交自己的podspec文件</p>
<p>找到podspec的根目录下，再执行下面的指令</p>
<p>pod trunk push SXWaveAnimate.podspec<br>这一行代码做了很多之前步骤中的工作。包括检测podspec是否合法，转成json格式传输，上传到trunk服务器，再转到github的cocoapods库。<br>失败的原因基本都是podspec文件里面的格式错误或者路径写错了，这里不要急慢慢来，没人限制你说只给你一次机会。</p>
<p>出现上面成功的情况就是交给cocoapods团队审核了，这个过程是很快的，从几小时到一个两个工作日不等。建议今天成功了明天下午再来看看，用不着一直刷新。</p>
<p>6.随便看看</p>
<p>执行搜索操作就能看到自己写的库摆在那里了<br>如果隔了很久还搜是不到自己的库，建议把仓库更新一下，再搜。</p>
<p>如果感觉自己的pod速度太慢，可以更换淘宝的ruby源，具体操作可见唐巧大神的一片博客：<a href="http://www.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/。" target="_blank" rel="external">http://www.devtang.com/blog/2014/05/25/use-cocoapod-to-manage-ios-lib-dependency/。</a></p>
<p>只要你为cocoapods提供了代码就能在你github的右边有个cocoaPods/Specs<br>并且你回头看你的代码，代码所使用的语言占比也会出现Ruby<br>我传的库是一个关于灌水动画的，有兴许的可以去看看或者pod install一下。<a href="https://github.com/dsxNiubility/SXWaveAnimate" target="_blank" rel="external">https://github.com/dsxNiubility/SXWaveAnimate</a></p>
<p>SXWaveAnimate<br>7.更新库</p>
<p>更新基本没有什么特殊操作，重复第4，5两步，记得把podspec和tag 都加1点，如果tag不变也是不允许的。</p>
<p>更新库的话速度很快，我记得当时好像10分钟就能刷出来了，如果你发现你pod search 时自己是1.3.6版本 但是pod install后仍是1.3.5版本，并且在podfile文件中你也并没有指定固定的版本号，那就把podfile.lock删除就好了。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/10/20/上传自己写的库到cocoaPods/" data-id="cipjtn9ku000usis6cka55z55" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-抽屉效果三方库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/24/iOS-抽屉效果三方库/" class="article-date">
  <time datetime="2015-09-24T08:53:43.000Z" itemprop="datePublished">2015-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/24/iOS-抽屉效果三方库/">iOS_抽屉效果三方库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>现对当下比较火的几大热门抽屉效果的第三方库进行了调研。代码全部选自github</p>
<p>一.RESideMenu<br><a href="https://github.com/romaonthego/RESideMenu" target="_blank" rel="external">https://github.com/romaonthego/RESideMenu</a></p>
<p>支持iOS7+</p>
<p>优点：</p>
<p>1.里面的文件较少，不需要使用cocoapods即可运行。</p>
<p>2.里面自定义API也比较多，可以设置变小的抽屉效果或者不变小。</p>
<p>3.里面有两个事例程序，一个是纯手码，一个是Storyboard得。可见作者也非常喜欢IB开发，此框架用IB开发应该可以完美兼容。</p>
<p>4.可以使用手势拖来拖去。</p>
<p>5.项目里各个文件不需要继承，导入头文件就行。<br>缺点：</p>
<p>1.左边显示的菜单可选项是固定的几个button，暂时想把左边换成tableView还不知道可不可行。（现已解决，可以改）</p>
<p>2.不能实现状态栏右移。（董铂然博客园）</p>
<p>3.暂时没找到两边控制器的占比怎么自定义。（现已解决，可以改）</p>
<p>二.Mutual Mobile Drawer Controller<br><a href="https://github.com/mutualmobile/MMDrawerController" target="_blank" rel="external">https://github.com/mutualmobile/MMDrawerController</a></p>
<p>示例程序内存跑到15M<br>优点。</p>
<p>1.里面有9个文件比上面的略多。但也还凑合吧</p>
<p>2.虽然没有缩小抽屉的动画，但是在平向切入时，leftVC有几种转场动画可选。</p>
<p>3.左边已经是tableVIew。</p>
<p>4.自定义的接口挺多。</p>
<p>5.作者最近还在更新</p>
<p>缺点。</p>
<p>1.相比于上面的，这个项目是用纯手码写的。</p>
<p>2.现在有一个抽搐的小bug，不过感觉我应该能改好。</p>
<p>3.在设置左右占比时，用的是固定数值，这样的话4s和6的手机界面显示是不一样的。（应该能改成百分比）</p>
<p>4.依旧状态栏不能右移。</p>
<p>5.项目内各个文件需要继承工具类。</p>
<p>三.PPRevealSideViewController<br><a href="https://github.com/ipup/PPRevealSideViewController" target="_blank" rel="external">https://github.com/ipup/PPRevealSideViewController</a><br>iOS6+</p>
<p>测试效果一般。</p>
<p>优点：</p>
<p>1.支持iOS6</p>
<p>2.基本的自定义也都是支持的。</p>
<p>3.页面大部分是Storyboard搭建。</p>
<p>4.导入头文件，而不是继承。</p>
<p>缺点：</p>
<p>1.也是支持iOS6，导致界面始终控制的必须有一个黑条。并且在切换的时候太低端了。</p>
<p>2.除了自己的PPRSVC，还必须使用cocoapods依赖了另一个库，PPHelpMe。这个库有29个文件。</p>
<p>3.手势支持做的不怎么好，能拉出来但不能拉回去。（董铂然博客园）<br>四.SWRevealViewController<br><a href="https://github.com/John-Lluch/SWRevealViewController" target="_blank" rel="external">https://github.com/John-Lluch/SWRevealViewController</a><br>非常干净的界面也没有图片，为什么内存会跑到28M?</p>
<p>iOS7+</p>
<p>测试的效果一般</p>
<p>优点：</p>
<p>1.使用的是导入头文件，而不是继承。</p>
<p>2.非常干净，基本只有核心功能，只有两个文件一个.h一个.m</p>
<p>3.可以实现三层抽屉。</p>
<p>4.支持手势的各种操作。</p>
<p>5.里面使用了不少xib文件。</p>
<p>6.左右占比控制的很好。<br>缺点：</p>
<p>1.能够自定义的接口不是很多。（但改源码的话应该也不会很难）</p>
<p>2.横屏时的屏幕适配需要再改进下。</p>
<p>2.貌似没有缺点了。</p>
<p>五.ECSlidingViewController （现在用的）<br><a href="https://github.com/ECSlidingViewController/ECSlidingViewController" target="_blank" rel="external">https://github.com/ECSlidingViewController/ECSlidingViewController</a></p>
<p>支持iOS5</p>
<p>测试效果一般。</p>
<p>优点：</p>
<p>1.除了星多，貌似没有优点（和上面几个相比的话）<br>缺点：</p>
<p>1.用了13个文件，但是貌似只是实现了最基本的抽屉效果功能。</p>
<p>2.缩在右边时还向右边拉，会产生bug。</p>
<p>3.用的是继承。每个文件都要继承。</p>
<p>4.去年8月以后就停止更新了。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/24/iOS-抽屉效果三方库/" data-id="cipjtn9ks000tsis64mjfyiwo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-对UITableView三种计算动态行高的方法分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/09/09/iOS-对UITableView三种计算动态行高的方法分析/" class="article-date">
  <time datetime="2015-09-09T08:47:25.000Z" itemprop="datePublished">2015-09-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/09/09/iOS-对UITableView三种计算动态行高的方法分析/">iOS_对UITableView三种计算动态行高的方法分析</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>tableView是一个神奇的东西，可以这么说，就算是一个初学者如果能把tableView玩的很6，那编一般的iOS的需求都问题不大了。tableView是日常开发中用烂了的控件，但是关于tableView中的自定义cell的动态行高，还是有一些玄机的。笔者本次主要是因为预估行高的方法的问题作为了一个契机顺带写了此文对几种动态行高方法的分析。</p>
<p>如果你不是在董铂然博客园看到本文，请点击查看原文。</p>
<p>旧方法<br>现在常规的动态行高的计算方法还是用</p>
<p>[str boundingRectWithSize:size options:NSStringDrawingUsesLineFragmentOrigin attributes:attrs context:nil].size<br>这其中需要先传入一个最大尺寸和一个属性字典，特殊的格式要求都写在属性字典中。</p>
<p>NSDictionary *attrs = @{NSFontAttributeName : font};<br>整个流程的基本思想大概就是：用一个字符串对象来调用此方法，中间需要传入一个属性字典来告知字体和样式，然后根据字符串长度的多少来算出应该给多大的frame。前面传进的size一般可以设置最大宽度。 此方法一般写成分类便于调用。</p>
<p>#import “NSString+Size.h”</p>
<p>@implementation NSString (Size)</p>
<p>/**</p>
<ul>
<li>类方法计算size大小<br>*/</li>
</ul>
<ul>
<li>(CGSize)sizeWithString:(NSString <em>)str andFount:(UIFont </em>)font andMaxSize:(CGSize)size<br>{<br>NSDictionary *attrs = @{NSFontAttributeName : font};<br>return [str boundingRectWithSize:size options:NSStringDrawingUsesLineFragmentOrigin attributes:attrs context:nil].size;<br>}</li>
</ul>
<p>/**</p>
<ul>
<li>对象方法计算size大小<br>*/</li>
</ul>
<ul>
<li>(CGSize)sizeWithFount:(UIFont <em>)font andMaxSize:(CGSize)size;<br>{<br>NSDictionary </em>attrs = @{NSFontAttributeName : font};<br>return [self boundingRectWithSize:size options:NSStringDrawingUsesLineFragmentOrigin attributes:attrs context:nil].size;<br>}<br>@end<br>这些方法从字面上看也比较容易理解。</li>
</ul>
<p>调用时的代码基本就是取到一个字符串，传入一个font和一个最大size，如下把宽设置成了270就是最大宽度为270高度往下顺延的话就把高度写成MAXFLOAT</p>
<p>NSString *text = _message.text;<br>CGSize textSize = [text sizeWithFount:[UIFont systemFontOfSize:14] andMaxSize:CGSizeMake(270, MAXFLOAT)];<br>然后在frame中取到最下面一个空间的maxY，从而让每一个cell在set方法中就得到自己的行高 ，然后通过cell的类方法返回。</p>
<p>新方法<br>随着iOS8的自动布局和Interface builder越来越成熟，逐渐衍生出了一种先用storyboard或xib界面再算自定义行高的方法。</p>
<p>这种方法一般需要先搭建一个图形化界面。如下图大概搭一个比较复杂的cell。</p>
<p>首先可以清晰的看出，用IB搭建看上去很快就能搭建完毕，并且有的图片或是view的背景设置了之后能看出界面大概的感觉。这里需要注意的就是label设置约束的方法，普通控件一般都要设置四个约束才能固定位置，label和button只设置两个约束（只需要写固定位置的两条约束，不需要写自身宽高的约束）也不会报错，但是需要在editor中设置sizeToFit，这样可以根据字数自动给你分配一个控件的大小。</p>
<p>一般评论类的label肯定都是字数比较多的，这时2条约束就不够了需要再设置一个最大宽度的约束，如图1我设置的方法是，把评论label与左右边界的间隙给设定了，这个在IB中叫Leading（前）和Training（后），高的约束我们没有写如果字数超过了一行他就会自己往下顺延。 这么写相较于把宽度约束写死的好处是会自动根据屏幕适配不管屏幕多大都是左右空出若干像素。这样做也有局限性，就是假设给这个label设置一个背景色，如果字数就5个字背景色也会延伸到一整行。如果QQ聊天页面也这样做，不管是几个字都是一整行的聊天气泡那会很丑。于是有了一种少则背景也少，多也不超过最大宽度的做法，就是设置label的width的less than来设置最大宽度。这么做如果字数不足一行的话，约束也会自动缩到与label长度匹配。</p>
<p>如果这个页面用纯手码写，可想而知会非常麻烦。</p>
<p>用IB页面做自定义行高的计算方法也更简单。也就是里面模型的set方法正常写，给自己的UI控件赋值。然后在tableView的行高方法heightForRow中，先给cell的模型赋值，然后再使用一次</p>
<p>[cell layoutIfNeeded];<br>他会自动根据填进去数值来布局，然后我们直接在这个方法中返回最下面一个控件的bottom位置+若干间隙，以此来作为行高即可。</p>
<p>真正的布局其实也就是用了这一行代码，并且可以做到屏幕适配不用if判断各种frame。但这样写也有一些问题，首先就是这么写从结构上来看不合理。这个行高方法中不应该写这些赋值语句。官方还是其他大神说不合理的原因，应该是这个方法应该仅仅是用来算出行高并显示的，会调用多次，如果在这里赋值性能会很差。这么说有道理，把这里面的每行代码都看一遍，能看出性能较差的方法主要就是这两行：1.给cell里模型赋值  2.layoutIfNeed 。如果调用多次这个方法那这两行也会执行多次，所以这应该是不科学的。　　我实际的做法是在其中设置一个行高缓存字典，并且找一个肯定不会重复的标识来做key值。每一行cell计算行高前都先拿自己的id去行高缓存字典里取一下看有没有值，如果有则直接返回对应的value，如果没有再计算。这样可以使这性能比较差得两行代码只执行一次。达到优化效果。</p>
<p>MTFBNoReplyCell *feedbackNoreplyCell = [MTFBNoReplyCell cell];</p>
<p>NSString *thisId =[NSString stringWithFormat:@”%d”, feedbackModel.feedbackid];</p>
<p>//            MTLog(@”%@”,[self.cellHeightCache valueForKey:thisId]);<br>CGFloat cacheHeight = [[self.cellHeightCache valueForKey:thisId] doubleValue];<br>if (cacheHeight) {<br>//            MTLog(@”返回缓存的行高”);<br>return cacheHeight;<br>}<br>//            MTLog(@”耗性能的行高”);<br>feedbackNoreplyCell.feedbackDetailModel = feedbackModel;<br>[feedbackNoreplyCell layoutIfNeeded];</p>
<p>[self.cellHeightCache setValue:@(feedbackNoreplyCell.replyBtn.bottom+16) forKey:thisId];</p>
<p>return feedbackNoreplyCell.replyBtn.bottom+16;<br>大概的思想如上所示。 如果这个tableView的数据不会随时改变较为固定的话，可以把取到的模型作为value以indexpath.row为key存一个缓存字典这样也能优化一些。行高方法里取过了，cellForRow就可以直接用了。</p>
<p>预估行高方法<br>这里我想重点说一下这个预估行高的方法estimatedHeightForRowAtIndexPath 。这个方法可能大部分人一说到这个，就说这个方法好啊，预估行高方法可以减少heightForRow的调用次数，使得性能达到优化。 孰不知实际运用中是存在着一定问题的。</p>
<p>就拿整个tableView来说 他是继承自scrowView的，scrowView能够滚动是因为它有contentSize。tableView在初次加载的时候也需要算出自己的contentSize（而且会算不止一次），也就是说需要调一下所有的行高方法然后自己内部给他累加一下算出整个contentSize。如果在行高方法里设置一个打印会看到方法会调用很多次。这时如果有一个预估方法return 100。那它就能很快算出总值了。就会减少行高方法的调用，在实际用到某一行时再调用。</p>
<p>但是可能会出现如下左图的问题。</p>
<p>问题的原因就是，一开始预估方法给每行预估了一个行高，然后后面实际加载的行高与预估的行高不合时，会出现cell上下的“窜动”给人卡卡的感觉。对此我的思想是，如果是动态的且cell的复杂度较高，行与行之间差距大的时候，就直接不要写预估行高方法了吧，让他自己算吧哪怕多调用几次，毕竟上面已经写过缓存行高字典了，性能姑且是可以hold住了，并且不会出现“窜动”情况。如右图所示。</p>
<p>但是如果是固定行高有一种或是三种不同的cell，行高分别是120，150，200。你在预估行高了写个return 150。遇到行高与预估不等时，却也不会出现“窜动”。我推测应该是estimatedHeightForRow不能和HeightForRow里面的layoutIfNeed同时存在，这两者同时存在才会出现“窜动”的bug。所以我的建议是：只要是固定行高就写预估行高来减少行高调用次数提升性能。如果是动态行高就不要写预估方法了，用一个行高的缓存字典来减少代码的调用次数即可。</p>
<p>关于上面行高的新方法和旧方法的对比，我的总结是：首先新方法肯定性能上是比旧方法要差一些的。具体体现在两个方面，1是在IB页面开发的东西，程序一启动就会全部加载进内存由系统托管，以至于有的界面你已经把导航控制器的栈顶控制器给pop了，发现内存还没有下降。2是新方法和旧方法有一个本质的区别，旧方法是直接算，算你需要多大的尺寸就告诉你，新方法则是先强制布局然后看你占了多大的尺寸再告诉你，这两者一对比，新方法就是多了一个强制布局的过程，这肯定是会对性能造成一定影响的，那具体影响多少？关于滑动计算行高我还不知道有什么可以明确一个数据的对比，我只能用肉眼看屏幕的滑动来区分对比，我的感觉就是基本没差别，如果要说有的话新方法可能会非常轻微的卡顿，换而言之就是同一个页面，旧方法编完需要10小时，新方法编完需要3小时，但是新方法的性能略差于旧方法。就看你自己怎么衡量了。当然非常庞大的项目还是建议用旧方法，毕竟一点一点的“略差于”积累在一起就是很差了。</p>
<p>关于iOS8新的行高特性<br>首先是有了一个新的用法。写在viewdidload里</p>
<p>self.tableView.estimatedRowHeight = 50.0f;<br>self.tableView.rowHeight = UITableViewAutomaticDimension;<br>这就没什么好说的了，苹果自己帮你把动态行高计算了，所有乱七八糟的都不用管了。 但是暂时说这些基本没用，因为现在还看不到哪个公司的项目不适配iOS7，就算出了iOS9感觉也不会让你直接适配iOS8的，iOS7还会存在相当长一段时间，毕竟以后新系统版本改变应该都不会有iOS6到7变化那么大了，除非啥时候苹果总设计师乔纳森伊夫下台了。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/09/09/iOS-对UITableView三种计算动态行高的方法分析/" data-id="cipjtn9ka000ksis60azu1jou" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-关于XMPP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/08/24/关于XMPP/" class="article-date">
  <time datetime="2015-08-24T08:59:30.000Z" itemprop="datePublished">2015-08-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/24/关于XMPP/">关于XMPP</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>xmpp整理笔记：聊天信息的发送与显示  <a href="http://www.cnblogs.com/dsxniubility/p/4307073.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/4307073.html</a></p>
<p>xmpp整理笔记：环境的快速配置(附安装包)  <a href="http://www.cnblogs.com/dsxniubility/p/4304570.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/4304570.html</a></p>
<p>xmpp整理笔记：xmppFramework框架的导入和介绍  <a href="http://www.cnblogs.com/dsxniubility/p/4307057.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/4307057.html</a></p>
<p>xmpp整理笔记：用户网络连接及好友管理 <a href="http://www.cnblogs.com/dsxniubility/p/4307066.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/4307066.html</a></p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/08/24/关于XMPP/" data-id="cipjtn9kx000wsis6z5g938fr" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-多线程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/07/03/iOS-多线程/" class="article-date">
  <time datetime="2015-07-03T09:04:49.000Z" itemprop="datePublished">2015-07-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/03/iOS-多线程/">iOS_多线程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>本文是对以往学习的多线程中知识点的一个整理。</p>
<p>多线程中的队列有：串行队列，并发队列，全局队列，主队列。</p>
<p>执行的方法有：同步执行和异步执行。那么两两一组合会有哪些注意事项呢？</p>
<p>如果不是在董铂然博客园看到这边文章请 点击查看原文</p>
<p>提到多线程，也就是四种，pthread，NSthread，GCD，NSOperation  </p>
<p>其中phtread是跨平台的。GCD和NSOperation都是常用的，后者是基于前者的。</p>
<p>但是两者区别：GCD的核心概念是将一个任务添加到队列，指定任务执行的方法，然后执行。 NSOperation则是直接将一个操作添加到队列中。</p>
<ol>
<li><p>开不开线程，取决于执行任务的函数，同步不开，异步开。</p>
</li>
<li><p>开几条线程，取决于队列，串行开一条，并发开多条(异步)</p>
</li>
<li><p>主队列：  专门用来在主线程上调度任务的”队列”，主队列不能在其他线程中调度任务！</p>
</li>
<li><p>如果主线程上当前正在有执行的任务，主队列暂时不会调度任务的执行！主队列同步任务，会造成死锁。原因是循环等待</p>
</li>
<li><p>同步任务可以队列调度多个异步任务前，指定一个同步任务，让所有的异步任务，等待同步任务执行完成，这是依赖关系。</p>
</li>
<li><p>全局队列：并发，能够调度多个线程，执行效率高，但是相对费电。 串行队列效率较低，省电省流量，或者是任务之间需要依赖也可以使用串行队列。</p>
</li>
<li><p>也可以通过判断当前用户的网络环境来决定开的线程数。WIFI下6条，3G/4G下2～3条。</p>
</li>
</ol>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/07/03/iOS-多线程/" data-id="cipjtn9kc000msis6p8zwzk75" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-几种常见的加密方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/05/27/iOS-几种常见的加密方法/" class="article-date">
  <time datetime="2015-05-27T09:18:49.000Z" itemprop="datePublished">2015-05-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/05/27/iOS-几种常见的加密方法/">iOS_几种常见的加密方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>一.MD5</p>
<p>MD5编码是最常用的编码方法之一，是从一段字符串中通过相应特征生成一段32位的数字字母混合码。</p>
<p>MD5主要特点是 不可逆，相同数据的MD5值肯定一样，不同数据的MD5值不一样（也不是绝对的，但基本是不能一样的）。<br>MD5算法还具有以下性质：<br>1、压缩性：任意长度的数据，算出的MD5值长度都是固定的。<br>2、容易计算：从原数据计算出MD5值很容易。<br>3、抗修改性：对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。<br>4、弱抗碰撞：已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。<br>5、强抗碰撞：想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。</p>
<p>MD5虽然说是不可逆的 但是由于有网站<a href="http://www.cmd5.com的存在，专门用来查询MD5码" target="_blank" rel="external">http://www.cmd5.com的存在，专门用来查询MD5码</a> 所以有的简单的MD5码是可以在这里搜到源码的。<br>为了让MD5码更加安全 涌现了很多其他方法 如加盐。 盐要足够长足够乱 得到的MD5码就很难查到。</p>
<p>终端代码：<br>$ md5 -s “abc”      给字符串abc加密<br>$ echo -n abc|openssl md5        给字符串abc加密  </p>
<p>二.HMAC加密</p>
<p>此加密方法需要先生成密钥，然后再对密码进行MD5和HMAC加密，数据库中需要存放当时使用的密钥和密码加密后的密文<br>在用户登陆时 再次对填入的密码用密钥进行加密 并且还要加上当前时间（精确到分钟） 再次HMAC加密，服务器里也会拿出以前存放的密文加上时间再次加密。所以就算黑客在中途截取了密码的密文 也在能在1分钟只能破译才能有效，大大加强了安全性。服务器为了考虑到网络的延迟一般会多算一种答案，如23分过来的密码 他会把23分和22分的都算一下和用户匹配只要对上一个就允许登陆。<br>三.base64编码<br>在MIME格式的电子邮件中，base64可以用来将binary的字节序列数据编码成ASCII字符序列构成的文本。使用时，在传输编码方式中指定base64。使用的字符包括大小写字母各26个，加上10个数字，和加号“+”，斜杠“/”，一共64个字符，等号“=”用来作为后缀用途。</p>
<p>完整的base64定义可见RFC 1421和RFC 2045。编码后的数据比原始数据略长，为原来的4/3。<br>终端指令<br>先cd 找到当前目录<br>加密： $ base64 abc.png -o abc.txt<br>解密： $ base64 abc.txt -o 123.png -D</p>
<p>四.对称加密算法<br>优点：算法公开、计算量小、加密速度快、加密效率高、可逆<br>缺点：双方使用相同钥匙，安全性得不到保证<br>现状：对称加密的速度比公钥加密快很多，在很多场合都需要对称加密，<br>相较于DES和3DES算法而言，AES算法有着更高的速度和资源使用效率，安全级别也较之更高了，被称为下一代加密标准</p>
<p>nECB ：电子代码本，就是说每个块都是独立加密的<br>nCBC ：密码块链，使用一个密钥和一个初始化向量 (IV)对数据执行加密转换</p>
<p>ECB和CBC区别：CBC更加复杂更加安全，里面加入了8位的向量（8个0的话结果等于ECB）。在明文里面改一个字母，ECB密文对应的那一行会改变，CBC密文从那一行往后都会改变。</p>
<p>ECB终端命令：<br>$ openssl enc -des-ecb -K 616263 -nosalt -in msg1.txt -out msg1.bin<br>CBC终端命令：<br>$ openssl enc -des-cbc -K 616263 -iv 0000000000000000 -nosalt -in msg1.txt -out msg2.bin</p>
<p>五.RSA加密<br>RSA非对称加密算法<br>非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）<br>公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密<br>特点：<br>非对称密码体制的特点：算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快<br>对称密码体制中只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥。所以保证其安全性就是保证密钥的安全，而非对称密钥体制有两种密钥，其中一个是公开的，这样就可以不需要像对称密码那样传输对方的密钥了<br>基本加密原理：<br>(1)找出两个“很大”的质数：P &amp; Q<br>(2)N = P <em> Q<br>(3)M = (P – 1) </em> (Q – 1)<br>(4)找出整数E，E与M互质，即除了1之外，没有其他公约数<br>(5)找出整数D，使得E<em>D除以M余1，即 (E </em> D) % M = 1<br>经过上述准备工作之后，可以得到：<br>E是公钥，负责加密<br>D是私钥，负责解密<br>N负责公钥和私钥之间的联系<br>加密算法，假定对X进行加密<br>(X ^ E) % N = Y<br>n根据费尔马小定义，根据以下公式可以完成解密操作<br>(Y ^ D) % N = X</p>
<p>但是RSA加密算法效率较差，对大型数据加密时间很长，一般用于小数据。<br>常用场景：<br>分部要给总部发一段报文，先对报文整个进行MD5得到一个报文摘要，再对这个报文摘要用公钥加密。然后把报文和这个RSA密文一起发过去。<br>总部接收到报文之后要先确定报文是否在中途被人篡改，就先把这个密文用私钥解密得到报文摘要，再和整个报文MD5一下得到的报文摘要进行对比 如果一样就是没被改过。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/05/27/iOS-几种常见的加密方法/" data-id="cipjtn9jx000gsis6ow1vzmpk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-在label中添加图片" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/16/iOS-在label中添加图片/" class="article-date">
  <time datetime="2015-03-16T09:01:48.000Z" itemprop="datePublished">2015-03-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/16/iOS-在label中添加图片/">iOS_在label中添加图片</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>这个需求其实是有的，比如QQ聊天界面里面发送的信息，可以用label来显示文字（也可以用button显示），但是有时候用户可能会发送图片。如果能让Label遇到文字就显示文字，遇到图片就显示图片就好了。可能有的人会说用Quartz2D,直接在Label的drawinrect 里面用上下文画上去。但这感觉太刻意去弄了，而且比较麻烦。</p>
<p>如果你不是在董铂然博客园看到本文，请点击查看原文</p>
<p>推荐一种用Label系统的属性来做。</p>
<p>UIImage *image = [UIImage imageNamed:@”321.jpg”];</p>
<p>// 1&gt; 生成文本附件<br>NSTextAttachment *textAttach = [[NSTextAttachment alloc] init];<br>textAttach.image = image;</p>
<p>// 2&gt; 使用文本附件创建属性文本<br>NSAttributedString *strA = [NSAttributedString attributedStringWithAttachment:textAttach];</p>
<p>self.lblChat.attributedText = strA;<br>里面的lblChat是一个成员变量 在storyboard里拖得一个label。</p>
<p>所有人都知道label.Text 但应该不是全都知道label.attributedText </p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/16/iOS-在label中添加图片/" data-id="cipjtn9jz000hsis61c5o6gv6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-关于蒲公英" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/07/iOS-关于蒲公英/" class="article-date">
  <time datetime="2015-03-07T07:50:33.000Z" itemprop="datePublished">2015-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/iOS-关于蒲公英/">iOS_关于蒲公英</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>蒲公英托管平台网站<a href="http://www.pgyer.com/" target="_blank" rel="external">http://www.pgyer.com/</a></p>
<p>首先说一下蒲公英是干什么的，蒲公英就是你程序希望给别的用户测试，但是他手机又没有在的开发者账号列表下，那么就需要企业账号打包才可以给用户进行安装，但是安装你又需要架设一个网页，等等其他麻烦事情，所以使用蒲公英可以简单做到这些事情，你无须有企业账号，只需要能打包成ipa文件即可，然后上传到蒲公英平台上，之后蒲公英就给你一个连接你发送给客户，或者做成二维码扫描即可</p>
<p>原理​</p>
<p>那么你奇怪为什么我随便打个包给他，别人就能下载了，从原理上分析，蒲公英提供了大量的企业级开发者账号，也就是299美金那种，然后你上传ipa文件，他服务器自动把ipa文件拆包，更换里面的签名文件，替换为企业级开发者账号的签名文件，之后在把这个ipa文件的地址发送给你，你下载就是299美金授权那种，这也就解释了​有的时候你在蒲公英上面一段时间后就不行的原因，因为被人举报了，蒲公英要启动一个新的账号，所以那个授权就过期了</p>
<p>注：最新版本的蒲公英需要用户自己提供299美金账号打包了，他不在提供修改ipa文件帮你修改了，这点需要注意​</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/07/iOS-关于蒲公英/" data-id="cipjtn9k2000isis6i0yo96h8" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-关于判断VPN小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/17/iOS-关于判断VPN小结/" class="article-date">
  <time datetime="2015-02-17T07:44:09.000Z" itemprop="datePublished">2015-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/17/iOS-关于判断VPN小结/">iOS_关于判断VPN小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>需要判断是否开启了VPN方法的代码</p>
<p>头文件需要添加</p>
<p>#include</p>
<p>#include</p>
<p>代码部分</p>
<ul>
<li>(BOOL)isVPNConnected<br>{<br>struct ifaddrs <em>interfaces = NULL;<br>struct ifaddrs </em>temp_addr = NULL;<br>int success = 0;</li>
</ul>
<p>// retrieve the current interfaces - returns 0 on success<br>success = getifaddrs(&amp;interfaces);<br>if (success == 0) {<br>// Loop through linked list of interfaces<br>temp_addr = interfaces;<br>while (temp_addr != NULL) {<br>NSString *string = [NSString stringWithFormat:@”%s” , temp_addr-&gt;ifa_name];<br>if ([string rangeOfString:@”tap”].location != NSNotFound ||<br>[string rangeOfString:@”tun”].location != NSNotFound ||<br>[string rangeOfString:@”ppp”].location != NSNotFound){<br>return YES;<br>}</p>
<p>temp_addr = temp_addr-&gt;ifa_next;<br>}<br>}</p>
<p>// Free memory<br>freeifaddrs(interfaces);<br>return NO;</p>
<p>}</p>
<p>直接调用即可<br>BOOL isSucceess =[self isVPNConnected];</p>
<p>YES为开启了VPN，NO为关闭了VPN</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/02/17/iOS-关于判断VPN小结/" data-id="cipjtn9k9000jsis6lmhva9qp" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/06/14/WWDC——2016/">WWDC——2016</a>
          </li>
        
          <li>
            <a href="/2016/04/17/openGL学习/">openGL学习</a>
          </li>
        
          <li>
            <a href="/2016/04/03/MVC/">MVC</a>
          </li>
        
          <li>
            <a href="/2016/03/21/UITableView的应用和其中js与oc交互/">UITableView的应用和其中js与oc交互</a>
          </li>
        
          <li>
            <a href="/2016/02/15/搞定iOS与js交互/">搞定iOS与js交互</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>