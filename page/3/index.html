<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>孙利峰的技术博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="孙利峰的技术博客">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="孙利峰的技术博客">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孙利峰的技术博客">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="孙利峰的技术博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">孙利峰的技术博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天幕红尘</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS-关于蒲公英" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/03/07/iOS-关于蒲公英/" class="article-date">
  <time datetime="2015-03-07T07:50:33.000Z" itemprop="datePublished">2015-03-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/03/07/iOS-关于蒲公英/">iOS_关于蒲公英</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>蒲公英托管平台网站<a href="http://www.pgyer.com/" target="_blank" rel="external">http://www.pgyer.com/</a></p>
<p>首先说一下蒲公英是干什么的，蒲公英就是你程序希望给别的用户测试，但是他手机又没有在的开发者账号列表下，那么就需要企业账号打包才可以给用户进行安装，但是安装你又需要架设一个网页，等等其他麻烦事情，所以使用蒲公英可以简单做到这些事情，你无须有企业账号，只需要能打包成ipa文件即可，然后上传到蒲公英平台上，之后蒲公英就给你一个连接你发送给客户，或者做成二维码扫描即可</p>
<p>原理​</p>
<p>那么你奇怪为什么我随便打个包给他，别人就能下载了，从原理上分析，蒲公英提供了大量的企业级开发者账号，也就是299美金那种，然后你上传ipa文件，他服务器自动把ipa文件拆包，更换里面的签名文件，替换为企业级开发者账号的签名文件，之后在把这个ipa文件的地址发送给你，你下载就是299美金授权那种，这也就解释了​有的时候你在蒲公英上面一段时间后就不行的原因，因为被人举报了，蒲公英要启动一个新的账号，所以那个授权就过期了</p>
<p>注：最新版本的蒲公英需要用户自己提供299美金账号打包了，他不在提供修改ipa文件帮你修改了，这点需要注意​</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/03/07/iOS-关于蒲公英/" data-id="cipthkkfq000kwcs6qjf7xmmk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-关于判断VPN小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/17/iOS-关于判断VPN小结/" class="article-date">
  <time datetime="2015-02-17T07:44:09.000Z" itemprop="datePublished">2015-02-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/17/iOS-关于判断VPN小结/">iOS_关于判断VPN小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>需要判断是否开启了VPN方法的代码</p>
<p>头文件需要添加</p>
<p>#include</p>
<p>#include</p>
<p>代码部分</p>
<ul>
<li>(BOOL)isVPNConnected<br>{<br>struct ifaddrs <em>interfaces = NULL;<br>struct ifaddrs </em>temp_addr = NULL;<br>int success = 0;</li>
</ul>
<p>// retrieve the current interfaces - returns 0 on success<br>success = getifaddrs(&amp;interfaces);<br>if (success == 0) {<br>// Loop through linked list of interfaces<br>temp_addr = interfaces;<br>while (temp_addr != NULL) {<br>NSString *string = [NSString stringWithFormat:@”%s” , temp_addr-&gt;ifa_name];<br>if ([string rangeOfString:@”tap”].location != NSNotFound ||<br>[string rangeOfString:@”tun”].location != NSNotFound ||<br>[string rangeOfString:@”ppp”].location != NSNotFound){<br>return YES;<br>}</p>
<p>temp_addr = temp_addr-&gt;ifa_next;<br>}<br>}</p>
<p>// Free memory<br>freeifaddrs(interfaces);<br>return NO;</p>
<p>}</p>
<p>直接调用即可<br>BOOL isSucceess =[self isVPNConnected];</p>
<p>YES为开启了VPN，NO为关闭了VPN</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/02/17/iOS-关于判断VPN小结/" data-id="cipthkkfo000jwcs6dkn4xjxh" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-FMDB" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/02/10/FMDB/" class="article-date">
  <time datetime="2015-02-10T14:38:53.000Z" itemprop="datePublished">2015-02-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/02/10/FMDB/">FMDB</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>SQLite (<a href="http://www.sqlite.org/docs.html" target="_blank" rel="external">http://www.sqlite.org/docs.html</a>) 是一个轻量级的关系数据库。iOS SDK 很早就支持了 SQLite，在使用时，只需要加入 libsqlite3.dylib 依赖以及引入 sqlite3.h 头文件即可。但是，原生的 SQLite API 在使用上相当不友好，在使用时，非常不便。于是，开源社区中就出现了一系列将 SQLite API 进行封装的库，而 FMDB (<a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">https://github.com/ccgus/fmdb</a>) 则是开源社区中的优秀者。<br>FMDB 在使用上相当方便。以下是一个简单的例子：<br>NSString<em> docsdir = [NSSearchPathForDirectoriesInDomains( NSDocumentDirectory, NSUserDomainMask, YES) lastObject];<br>NSString</em> dbpath = [docsdir stringByAppendingPathComponent:@”user.sqlite”];<br>FMDatabase<em> db = [FMDatabase databaseWithPath:dbpath];<br>[db open];<br>FMResultSet </em>rs = [db executeQuery:@”select * from people”];<br>while ([rs next]) {<br>NSLog(@”%@ %@”,<br>[rs stringForColumn:@”firstname”],<br>[rs stringForColumn:@”lastname”]);<br>}<br>[db close];<br>可以看到，使用 FMDB 后的数据库代码清晰明了，比原生的 API 优雅多了。另外，FMDB 同时兼容 ARC 和非 ARC 工程，会自动根据工程配置来调整相关的内存管理代码。</p>
<p>使用说明<br>该使用说明主要翻译自 fmdb 的 github 项目说明文档: <a href="https://github.com/ccgus/fmdb" target="_blank" rel="external">https://github.com/ccgus/fmdb</a><br>引入相关文件<br>首先将 FMDB 从 github 上 clone 下来，然后将以下文件 copy 到你的工程中：<br>FMDatabase.h<br>FMDatabase.m<br>FMDatabaseAdditions.h<br>FMDatabaseAdditions.m<br>FMDatabasePool.h<br>FMDatabasePool.m<br>FMDatabaseQueue.h<br>FMDatabaseQueue.m<br>FMResultSet.h<br>FMResultSet.m<br>建立数据库<br>建立数据库只需要如下一行即可 , 当该文件不存在时，fmdb 会自己创建一个。如果你传入的参数是空串：@”” ，则 fmdb 会在临时文件目录下创建这个数据库，如果你传入的参数是 NULL，则它会建立一个在内存中的数据库。<br>FMDatabase *db = [FMDatabase databaseWithPath:@”/tmp/tmp.db”];<br>打开数据库<br>使用如下语句，如果打开失败，可能是权限不足或者资源不足。通常打开完操作操作后，需要调用 close 方法来关闭数据库。<br>if (![db open]) {<br>// error<br>return;<br>}<br>// some operation<br>// …</p>
<p>[db close];<br>执行更新操作<br>除了 Select 操作之外，其它的都是更新操作。更新操作使用如下方法，如果有错误，可以用 error 参数中获得。<br>-[FMDatabase executeUpdate:error:withArgumentsInArray:orVAList:]<br>执行查询操作<br>查询操作示例如下。注意：即使操作结果只有一行，也需要先调用 FMResultSet 的 next 方法。<br>FMResultSet <em>s = [db executeQuery:@”SELECT </em> FROM myTable”];<br>while ([s next]) {<br>//retrieve values for each record<br>}</p>
<p>FMResultSet <em>s = [db executeQuery:@”SELECT COUNT(</em>) FROM myTable”];<br>if ([s next]) {<br>int totalCount = [s intForColumnIndex:0];<br>}<br>FMDB 提供如下多个方法来获取不同类型的数据：<br>intForColumn:<br>longForColumn:<br>longLongIntForColumn:<br>boolForColumn:<br>doubleForColumn:<br>stringForColumn:<br>dateForColumn:<br>dataForColumn:<br>dataNoCopyForColumn:<br>UTF8StringForColumnIndex:<br>objectForColumn:<br>通常情况下，你并不需要关闭 FMResultSet，因为相关的数据库关闭时，FMResultSet 也会被自动关闭。<br>数据参数<br>通常情况下，你可以按照标准的 SQL 语句，用 ? 表示执行语句的参数，如：<br>INSERT INTO myTable VALUES (?, ?, ?)<br>然后，可以我们可以调用 executeUpdate 方法来将 ? 所指代的具体参数传入，通常是用变长参数来传递进去的，如下：<br>NSString <em>sql = @”insert into User (name, password) values (?, ?)”;<br>[db executeUpdate:sql, user.name, user.password];<br>这里需要注意的是，参数必须是 NSObject 的子类，所以象 int,double,bool 这种基本类型，需要封装成对应的包装类才行，如下所示：<br>// 错误，42 不能作为参数<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, 42];<br>// 正确，将 42 封装成 NSNumber 类<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:42]];<br>线程安全<br>如果我们的 app 需要多线程操作数据库，那么就需要使用 FMDatabaseQueue 来保证线程安全了。<br>切记不能在多个线程中共同一个 FMDatabase 对象并且在多个线程中同时使用，这个类本身不是线程安全的，这样使用会造成数据混乱等问题。<br>使用 FMDatabaseQueue 很简单，首先用一个数据库文件地址来初使化 FMDatabaseQueue，然后就可以将一个闭包 (block) 传入 inDatabase 方法中。<br>在闭包中操作数据库，而不直接参与 FMDatabase 的管理。<br>// 创建，最好放在一个单例的类中<br>FMDatabaseQueue </em>queue = [FMDatabaseQueue databaseQueueWithPath:aPath];</p>
<p>// 使用<br>[queue inDatabase:^(FMDatabase *db) {<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:1]];<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:2]];<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:3]];</p>
<p>FMResultSet <em>rs = [db executeQuery:@”select </em> from foo”];<br>while ([rs next]) {<br>// …<br>}<br>}];</p>
<p>// 如果要支持事务<br>[queue inTransaction:^(FMDatabase <em>db, BOOL </em>rollback) {<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:1]];<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:2]];<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:3]];</p>
<p>if (whoopsSomethingWrongHappened) {<br>*rollback = YES;<br>return;<br>}<br>// etc…<br>[db executeUpdate:@”INSERT INTO myTable VALUES (?)”, [NSNumber numberWithInt:4]];<br>}];<br>工具<br>为了查看 Sqlite 中的数据，一个好的图形化界面的数据库管理程序是必不可少的。mysql 有 phpMyAdmin，那么 sqlite 呢？<br>我主要使用的是 Firefox 的一个名为 SQLite Manager 的插件，安装此插件后，可以直接打开后缀名为 sqlite 的数据库文件。SQLite Manager 提供一个图形化的界面来执行数据查询或更改操作。如下图所示：</p>
<p>总结<br>FMDB 将 SQLite API 进行了很友好的封装，使用上非常方便，对于那些使用纯 Sqlite API 来进行数据库操作的 app，可以考虑将其迁移到基于 FMDB 上，这对于以后数据库相关功能的开发维护，可以提高不少效率。<br>我在学习 fmdb 的时候做了一个小工程用于练习，我把它放到 github 上了。感兴趣的可以自行下载：<a href="https://github.com/tangqiaoboy/FmdbSample" target="_blank" rel="external">https://github.com/tangqiaoboy/FmdbSample</a></p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/02/10/FMDB/" data-id="cipthkkdi0001wcs62ssxf43i" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-JSON解析四种方法" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2015/01/07/iOS-JSON解析四种方法/" class="article-date">
  <time datetime="2015-01-07T14:00:23.000Z" itemprop="datePublished">2015-01-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/01/07/iOS-JSON解析四种方法/">iOS_JSON解析四种方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>相关链接：<a href="http://blog.csdn.net/enuola/article/details/7903632" target="_blank" rel="external">http://blog.csdn.net/enuola/article/details/7903632</a></p>
<p>从IOS5开始，APPLE提供了对json的原生支持（NSJSONSerialization），但是为了兼容以前的iOS版本，可以使用第三方库来解析Json。</p>
<p>本文将介绍TouchJson、 SBJson 、JSONKit 和 iOS5所支持的原生的json方法，解析国家气象局API，TouchJson和SBJson需要下载他们的库</p>
<p>TouchJson包下载： <a href="http://download.csdn.net/detail/enuola/4523169" target="_blank" rel="external">http://download.csdn.net/detail/enuola/4523169</a></p>
<p>SBJson 包下载： <a href="http://download.csdn.net/detail/enuola/4523177" target="_blank" rel="external">http://download.csdn.net/detail/enuola/4523177</a></p>
<p>JSONKit包下载：<a href="http://download.csdn.net/detail/enuola/4523160" target="_blank" rel="external">http://download.csdn.net/detail/enuola/4523160</a></p>
<p>下面的完整程序源码包下载：<a href="http://download.csdn.net/detail/enuola/4523223" target="_blank" rel="external">http://download.csdn.net/detail/enuola/4523223</a></p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2015/01/07/iOS-JSON解析四种方法/" data-id="cipthkkf3000ewcs6jgrt5nbw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Objective－C中的深浅拷贝" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/06/18/Objective－C中的深浅拷贝/" class="article-date">
  <time datetime="2014-06-18T03:44:01.000Z" itemprop="datePublished">2014-06-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/06/18/Objective－C中的深浅拷贝/">Objective－C中的深浅拷贝</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>浅拷贝</p>
<p>浅拷贝就是对内存地址的复制，让目标对象指针和源对象指向同一片内存空间。如：</p>
<p>char<em> str = (char</em>)malloc(100);<br>char* str2 = str;<br>浅拷贝只是对对象的简单拷贝，让几个对象共用一片内存，当内存销毁的时候，指向这片内存的几个指针需要重新定义才可以使用，要不然会成为野指针。</p>
<p>iOS 里面的浅拷贝：</p>
<p>在 iOS 里面， 使用retain 关键字进行引用计数，就是一种更加保险的浅拷贝。他既让几个指针共用同一片内存空间，又可以在release 由于计数的存在，不会轻易的销毁内存，达到更加简单使用的目的。</p>
<p>深拷贝：</p>
<p>深拷贝是指拷贝对象的具体内容，而内存地址是自主分配的，拷贝结束之后，两个对象虽然存的值是相同的，但是内存地址不一样，两个对象也互不影响，互不干涉。</p>
<p>copy 与 retain 的区别：</p>
<p>copy 是创建一个新对象，retain 是创建一个指针，引用对象计数加一。 copy属性标识两个对象内容相同，新的对象retain count为1, 与旧有对象引用计数无关，旧有对象没有变化。copy减少对象对上下文的依赖。</p>
<p>iOS里的深拷贝：</p>
<p>iOS提供了copy和mutableCopy方法，顾名思义，copy就是复制了一个imutable的对象，而mutableCopy就是复制了一个mutable的对象。以下将举几个例子来说明。<br>这里指的是NSString, NSNumber等等一类的对象。</p>
<p>NSString <em>string = @”dddd”;<br>NSString </em>stringCopy = [string copy];<br>NSMutableString *stringDCopy = [string mutableCopy];<br>[stringMCopy appendString:@”!!”];<br>查看内存可以发现，string和stringCopy指向的是同一块内存区域(weak reference),引用计数没有发生改变。而stringMCopy则是我们所说的真正意义上的复制，系统为其分配了新内存，是两个独立的字符串内容是一样的。</p>
<p>拷贝构造：</p>
<p>当然在 ios 中并不是所有的对象都支持copy，mutableCopy，遵守NSCopying协议的类可以发送copy消息，遵守NSMutableCopying协议的类才可以发送mutableCopy消息。</p>
<p>假如发送了一个没有遵守上诉两协议而发送copy或者 mutableCopy,那么就会发生异常。但是默认的ios类并没有遵守这两个协议。如果想自定义一下copy 那么就必须遵守NSCopying,并且实现 copyWithZone: 方法，如果想自定义一下mutableCopy 那么就必须遵守NSMutableCopying,并且实现 mutableCopyWithZone: 方法。</p>
<p>如果是我们定义的对象，那么我们自己要实现NSCopying , NSMutableCopying这样就能调用copy和mutablecopy了。举个例子：</p>
<p>@interface MyObj : NSObject<nscopying, nsmutablecopying="">{<br>NSMutableString <em>_name;<br>NSString </em> _imutableStr ;<br>int _age;<br>}<br>@property (nonatomic, retain) NSMutableString <em>name;<br>@property (nonatomic, retain) NSString </em>imutableStr;<br>@property (nonatomic) int age;<br>copy拷贝构造：</nscopying,></p>
<ul>
<li><p>(id)copyWithZone:(NSZone <em>)zone{<br>MyObj </em>copy = [[[self class] allocWithZone :zone] init];<br>copy-&gt;name = [_name copy];<br>copy-&gt;imutableStr = [_imutableStr copy];<br>copy-&gt;age = age;<br>return copy;<br>}<br>mutableCopy拷贝构造：</p>
</li>
<li><p>(id)mutableCopyWithZone:(NSZone <em>)zone{<br>MyObj </em>copy = NSCopyObject(self, 0, zone);<br>copy-&gt;name = [_name mutableCopy];<br>copy-&gt;age = age;<br>return copy;<br>}</p>
</li>
</ul>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/06/18/Objective－C中的深浅拷贝/" data-id="cipthkket000awcs608zp63ig" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-三种途径实现一方法有多个返回值" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/03/24/iOS-三种途径实现一方法有多个返回值/" class="article-date">
  <time datetime="2014-03-24T08:24:39.000Z" itemprop="datePublished">2014-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/03/24/iOS-三种途径实现一方法有多个返回值/">iOS_三种途径实现一方法有多个返回值</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>以前觉得这种标题有点偏向于理论，实际开发中怎么会有这种诡异的需求，但是真正遇到了这种硬需求时觉得还是有那么点价值的，理论付诸了实践在此也就做了个整理。</p>
<p>以我私下开发中的一处代码为例，本意是希望有这么一个方法：能够传入一个开始标记（NSString<em>）一个结束标记（NSString</em>）一段文字（NSString*）  然后内部在文字中扫描并返回标记包裹内容的范围（NSRange这个范围是忽视标记的）这个范围可能会有多个所以返回的应该是一个装着range的数组。并且顺便把原来字符串中的开始和结束标记全过滤掉，把过滤后的字符串也返回出来。</p>
<p>举个例子就是：传入开始标记“&lt;” 结束标记“&gt;” 一段文字 “会议需要叫上&lt;彼得&gt;和&lt;罗宾&gt;”   然后希望返回一个数组 [{location:6,length:2},{location:9,length:2}] ，和返回处理后的字符串“会议需要叫上彼得和罗宾”。</p>
<p>代码希望能够写成这样，但是是不可能的。</p>
<p>1</p>
<ul>
<li>(NSArray <em>,NSMutableString </em>)scanBeginStr:(NSString <em>)beginstr endStr:(NSString </em>)endstr inText:(NSMutableString *)text</li>
</ul>
<p>好下面提供三种途径完成此需求。　　</p>
<p>1.使用字典</p>
<p>这种方法是最low但是最容易理解的，就是如果你需要返回多个对象，直接将多个对象塞在一个字典里面自己设置合理的key并返回字典，字典里面可以放任意数量的“返回值”。</p>
<ul>
<li>(NSDictionary <em>)scanBeginStr:(NSString </em>)beginstr endStr:(NSString <em>)endstr inText:(NSMutableString </em>)text{<br>NSRange range1,range2;<br>NSUInteger location =0,length=0;<br>range1.location = 0;<br>NSMutableArray *rangeArray = [NSMutableArray array];<br>while (range1.location != NSNotFound) {<br>range1 = [text rangeOfString:beginstr];<br>range2 = [text rangeOfString:endstr];<br>if (range1.location != NSNotFound) {<br>location = range1.location;<br>length = range2.location - range1.location - 1;<br>if (length &gt; 5000)break;<br>[text replaceOccurrencesOfString:beginstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range1.location + range1.length)];<br>[text replaceOccurrencesOfString:endstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range2.location + range2.length - 1)];<br>}<br>[rangeArray addObject:@{@”location”:@(location),@”length”:@(length)}];<br>}<br>return @{@”rangeArray”:rangeArray,@”text”:text};<br>}<br>这个方法在调用时也就是这样了，非常朴实的代码。</li>
</ul>
<p>NSDictionary<em> result = [self scanBegin2Str:@”&lt;” endStr:@”&gt;” inText:mutableText];<br>NSArray </em>rangeArray = result[@”rangeArray”];<br>NSMutableString *text = [result[@”text”] mutableCopy];<br>如果觉得字典不舒服也完全可以用模型，自定义一个对象然后给这个对象的各个属性赋值然后再把这个自定义对象返回回去，虽然代码看上去更科学一点但是需要写一些额外的代码并且不能实现任意可配置（每一种属性都必须要提前设定好），这个和上面算是一个相同的思路就不单独再列一条说了。 </p>
<p>2.使用指针的指针</p>
<p>这种方法是我实际使用的方法，就是把需要修改的text的指针的指针传进去，然后在方法的内部对这个实参取一下值得到text的指针。然后通过这个指针修改外部的变量的值。代码实现如下</p>
<ul>
<li>(NSArray <em>)scanBeginStr:(NSString </em>)beginstr endStr:(NSString <em>)endstr inText:(NSMutableString </em> <em>)textPointer{<br>NSRange range1,range2;<br>NSUInteger location =0,length=0;<br>range1.location = 0;<br>NSMutableString </em>text = <em>textPointer;<br>NSMutableArray </em>rangeArray = [NSMutableArray array];<br>while (range1.location != NSNotFound) {<br>range1 = [text rangeOfString:beginstr];<br>range2 = [text rangeOfString:endstr];<br>if (range1.location != NSNotFound) {<br>location = range1.location;<br>length = range2.location - range1.location - 1;<br>if (length &gt; 5000)break;<br>[text replaceOccurrencesOfString:beginstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range1.location + range1.length)];<br>[text replaceOccurrencesOfString:endstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range2.location + range2.length - 1)];<br>}<br>[rangeArray addObject:@{@”location”:@(location),@”length”:@(length)}];<br>}<br>return rangeArray;<br>}<br>这个方法在调用时就这么写了，因为mutabletext的修改是无声无息的。</li>
</ul>
<p>NSArray *rangeArray = [self scanBegin3Str:@”&lt;” endStr:@”&gt;” inText:&amp;mutableText];<br>// 董铂然博客园
　　</p>
<p>3.使用block回调</p>
<p>这种方法实际上严格意义来说不能算返回值，但是能够实现返回值的效果。</p>
<ul>
<li>(void)scanBeginStr:(NSString <em>)beginstr endStr:(NSString </em>)endstr inText:(NSMutableString <em>)text result:(void(^)(NSArray </em>rangeArray,NSMutableString <em>text))result{<br>NSRange range1,range2;<br>NSUInteger location =0,length=0;<br>range1.location = 0;<br>NSMutableArray </em>rangeArray = [NSMutableArray array];<br>while (range1.location != NSNotFound) {<br>range1 = [text rangeOfString:beginstr];<br>range2 = [text rangeOfString:endstr];<br>if (range1.location != NSNotFound) {<br>location = range1.location;<br>length = range2.location - range1.location - 1;<br>if (length &gt; 5000)break;<br>[text replaceOccurrencesOfString:beginstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range1.location + range1.length)];<br>[text replaceOccurrencesOfString:endstr withString:@”” options:NSCaseInsensitiveSearch range:NSMakeRange(0, range2.location + range2.length - 1)];<br>}<br>[rangeArray addObject:@{@”location”:@(location),@”length”:@(length)}];<br>}<br>result(rangeArray,text);<br>}<br>这个block在使用时可能比较特殊就这么写了</li>
</ul>
<p>[self scanBeginStr:@”&lt;” endStr:@”&gt;” inText:mutabletext result:^(NSArray <em>rangeArray, NSMutableString </em>text) {<br>NSLog(@”%@,%@”,rangeArray,text);<br>}];<br>如果把block的返回值写成一个字典或是模型也可以，但是那就多此一举了。 返回值不能尝试结构体类型，结构体内不能用OC对象只能用基本数据类型。</p>
<p>其实感觉还有别的方法，比如设置N个成员变量在方法内部计算后重新set也完全可以，但是可能大家也知道成员变量多了比较恶心。最近比较火的函数式编程一直在倡导“方法内不能产生副作用”“实现引用透明” ，如果这么看那后两种方法就不符合FP的规则了，但是用着也有自己的特色。</p>
<p>原文链接：<a href="http://www.cnblogs.com/dsxniubility/p/5122146.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/5122146.html</a></p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/03/24/iOS-三种途径实现一方法有多个返回值/" data-id="cipthkkfk000iwcs6w7nzbzkt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-APP上线性能检测" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/02/20/iOS-APP上线性能检测/" class="article-date">
  <time datetime="2014-02-20T08:16:38.000Z" itemprop="datePublished">2014-02-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/02/20/iOS-APP上线性能检测/">iOS_APP上线性能检测</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>相关链接：<a href="http://www.cnblogs.com/dsxniubility/p/5493117.html" target="_blank" rel="external">http://www.cnblogs.com/dsxniubility/p/5493117.html</a></p>
<p>在移动端开发者中最重要的KPI应该是崩溃率。当崩溃率稳定下来后，工作的重心就应该转移到性能优化上。那么问题来了，如果你的项目也没有接入任何性能监测SDK，没有量化的指标来衡量，那你说你优化了性能领导信么？</p>
<p>虽然现在市面上第三方性能检测平台已经很成熟，但笔者还是比较建议公司自己写自己的sdk，原因如下</p>
<ol>
<li><p>数据安全</p>
</li>
<li><p>避开费用，有的平台是MAU三万以下不收费，超出后费用极高。</p>
</li>
<li><p>可以自定义指标没有无用代码，一接别人SDK包体积增大不少，其实你只用到了个别几个功能。</p>
</li>
</ol>
<p>本文主要内容是给小项目团队自己写性能sdk的建议，也会提到当前的第三方平台。</p>
<p>1.页面的打开速度</p>
<p>关于页面的加载速度的测量有两个指标，一个是页面渲染速度，一个是页面加载速度。</p>
<p>页面渲染速度就是计算一个viewcontroller从viewdidload的第一行到viewdidappear的最后一行所用的时间。 这种方法可以适用于大多数相对静态的页面，一打开就直接加载的。  </p>
<p>页面加载速度相对比较麻烦，适用于有些页面并不是一进入就加载而是先发个请求，请求回调后才继续搭建页面的。加载时间应该是用户点开页面到用户能完全的看到内容才算加载完毕，这里就需要算进去请求消耗的时间了，对于源码级别的sdk，我们可以通过每发出一个请求就记到栈里，回调一个消除一个，当栈里的每一个请求都已经回调后才能认定是界面加载完毕。 业界也有一些黑盒的云测平台是录屏解析视频流，认定一个页面从打开到页面稳定后为加载时间。 个人认为肯定没有源码级别的准啊。 （董铂然博客园）</p>
<p>关于这种接入一个sdk直接hook每个页面生命周期方法也简单提一下吧，就是写一个类作为UIViewController的分类，增加几个方法如XXXviewdidload ， XXXviewdidappear等，然后使用这种swizzle的做法替换方法的实现</p>
<p><span style="font-family: 宋体; font-size: 13px;">    Method viewDidAppear = class_getInstanceMethod([UIViewController class], @selector(viewDidAppear:));<br>Method XXXViewDidAppear = class_getInstanceMethod([UIViewController class], @selector(XXXViewDidAppear:));<br>method_exchangeImplementations(viewDidAppear, XXXViewDidAppear);<br></span><br>对于一些新增的计量属性就使用运行时关联对象的那一套吧。 如果觉得要hook的方法太多或是太麻烦或是怕和别的hook冲突，可以使用埋点的方式，直接埋上你需要计算的开始和结束时间的采集点，这种更加灵活只关心自己关心的页面。</p>
<p>2.内存使用值</p>
<p>关于内存和cpu的获取方法业内基本都有统一的代码了，大致如下。</p>
<p><span style="font-family: 宋体; font-size: 13px;">+ (unsigned long)memoryUsage<br>{<br>struct task_basic_info info;<br>mach_msg_type_number_t size = sizeof(info);<br>kern_return_t kr = task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&amp;info, &amp;size);<br>if (kr != KERN_SUCCESS) {<br>return -1;<br>}<br>unsigned long memorySize = info.resident_size &gt;&gt; 10;</span></p>
<p>return memorySize;<br>}<br>需要先引入这两个头文件</p>
<p>1<br>2<br><span style="font-family: 宋体; font-size: 13px;">#include <mach task_info.h=""></mach></span></p>
<p>#include <mach mach.h=""><br>获取到了数据存入数组那接下来的事情就是上报策略的制定了。没必要每次获取数据都上报，可以设置每次启动上报上一次session的全部记录就好，启动后隔个10秒或20秒错开请求高峰期。上报时的数据结构也要尽可能的精简，因为不能对用户的流量造成太大的损失，也可以选择先压缩后再上传。 </mach></p>
<p>3.CPU占用率</p>
<p>同样需要内存的那两个头文件</p>
<p><span style="font-family: 宋体; font-size: 13px;">+ (CGFloat)cpuUsage<br>{<br>thread_array_t         thread_list;<br>mach_msg_type_number_t thread_count;<br>thread_info_data_t     thinfo;<br>mach_msg_type_number_t thread_info_count;<br>thread_basic_info_t basic_info_th;</span></p>
<p>// get threads in the task<br>kern_return_t kr = task_threads(mach_task_self(), &amp;thread_list, &amp;thread_count);<br>if (kr != KERN_SUCCESS) {<br>return -1;<br>}</p>
<p>CGFloat tot_cpu = 0;</p>
<p>for (int j = 0; j &lt; thread_count; j++)</p>
<p>{<br>thread_info_count = THREAD_INFO_MAX;<br>kr = thread_info(thread_list[j], THREAD_BASIC_INFO,(thread_info_t)thinfo, &amp;thread_info_count);<br>if (kr != KERN_SUCCESS) {<br>return -1;<br>}</p>
<p>basic_info_th = (thread_basic_info_t)thinfo;</p>
<p>if (!(basic_info_th-&gt;flags &amp; TH_FLAGS_IDLE)) {<br>tot_cpu = tot_cpu + basic_info_th-&gt;cpu_usage / (CGFloat)TH_USAGE_SCALE * 100.0;<br>}</p>
<p>} // for each thread<br>//free mem<br>kr = vm_deallocate(mach_task_self(), (vm_offset_t)thread_list, thread_count * sizeof(thread_t));<br>assert(kr == KERN_SUCCESS);<br>return tot_cpu;<br>}<br>关于采集数据的频率完全是自己制定的，而且大部分app都是在刚启动不久内cpu占用较大 之后就渐渐区域稳定，所以建议在刚开始采集间隔短一点比如1s，之后采集间隔逐渐加大最后稳定到5分钟获取一次。</p>
<p>4.页面的帧率</p>
<p><span style="font-family: 宋体; font-size: 13px;">_link = [CADisplayLink displayLinkWithTarget:self selector:@selector(tick:)];<br>[_link addToRunLoop:[NSRunLoop mainRunLoop] forMode:NSRunLoopCommonModes];</span></p>
<ul>
<li>(void)tick:(CADisplayLink *)link {<br>if (_lastTime == 0) {<br>_lastTime = link.timestamp;<br>return;<br>}<br>_count++;<br>NSTimeInterval delta = link.timestamp - _lastTime;<br>if (delta &lt; 1) return;<br>_lastTime = link.timestamp;<br>float fps = _count / delta;<br>_count = 0;<br>}　　<br>这个测量页面帧率的做法就是通过这个CADisplayLink刷帧方法的调用次数计算的，一般这个方法最快能每秒调用60次，如果是CPU或是GPU某个步骤耗时导致渲染错过了一次垂直信号，那这个方法就不会被调用了，之后统计的帧数也就随之降低了。 上面代码中的fps就是求出的这一时刻的帧率可以塞入数组再稍作处理上传。这里需要注意的是 性能监测平台自己对性能的影响，这个统计帧率的方法可能相对来说要耗性能一些，所以需要控制在某些时刻采集一定的样本就及时暂停。  这个数据建议hook每个页面加载时的方法如viewwillappear，或是tableview滑动时的代理方法，因为卡顿大多发生在这两个场景。 对帧率有兴趣的可以做一个悬浮窗测试帧率，我之前写过一个，但是还没有抽离成组件有兴趣的可以交流下。</li>
</ul>
<p>5.url响应时间监控</p>
<p>这里普通的做法就是继承NSURLProtocol 这个类写一个子类，然后在子类中实现NSURLConnectionDelegate 的那五个代理方法。 </p>
<p><span style="font-family: 宋体; font-size: 13px;">- (NSURLRequest <em>)connection:(NSURLConnection </em>)connection willSendRequest:(NSURLRequest <em>)request redirectResponse:(NSURLResponse </em>)response<br>//  这个方法里可以做计时的开始</span></p>
<ul>
<li><p>(void)connection:(NSURLConnection <em>)connection didReceiveResponse:(NSURLResponse </em>)response<br>//  这里可以得到返回包的总大小</p>
</li>
<li><p>(void)connection:(NSURLConnection <em>)connection didReceiveData:(NSData </em>)data<br>//  这里将每次的data累加起来，可以做加载进度圆环之类的</p>
</li>
<li><p>(void)connectionDidFinishLoading:(NSURLConnection *)connection<br>//  这里作为结束的时间</p>
</li>
<li><p>(void)connection:(NSURLConnection <em>)connection didFailWithError:(NSError </em>)error<br>//  错误的收集 <br>（经过调研connection在升级ipv6后还是可以使用的）你可以得到请求的url，建议只记录host和path，因为吧拼上的参数也上传第一不好快速分类，第二服务端还要做截取处理增加压力，第三浪费流量。 也可以得到response包的length。 响应时间可以根据结束方法中的时间减去开始方法中的时间得到，然后以key-value的方式上传。个人觉得请求没必要与viewcontroller关联，要考虑到管理页面栈还要考虑present和dismiss，收效甚微。并且想知道哪个url属于哪个页面还有很多可执行的方案。</p>
</li>
</ul>
<p>关于webView的url响应时间监控，比普通的native内url要复杂一些。 虽然上面说的统计方法也可以统计到webview的url响应时间，但是只能统计到完整url时间。webView的打开时可能会伴随一些302跳转之类的url，最后才到目标url。 如果一个url经历了三次跳转，响应时间很长，用上面说的统计方法只能统计总时间并不能定位到具体是哪一个子url异常。 这时就需要webView内特殊的时间统计了。</p>
<p>有的一个url会调多个不同团队维护的服务导致了重定向（图中ABC都是完整url的子url），分别在webView的两个代理方法中埋点计算差值，从A走了didstart到B走了didstart这个时间的差值为①就是A所消耗的时间，①+②+③是完整的时间。 通过这种分离统计的方法，可以把慢url明确定位到每一个服务，不对拖累好人。</p>
<p>6.请求错误码统计</p>
<p>如果没有做错误码统计的话，你服务器有问题或者某些地区被运营商劫持之类的，你app的界面可能显示的就是一直转菊花，这时是无法精确定位问题的。 所以将自己的请求都进行编号并收集错误码是非常有必要的。 我们所关注的错误码有三种：</p>
<ol>
<li><p>正常的HTTP Response code 比如200 ，404，500   </p>
</li>
<li><p>AFN（现在ASI用不了了，ipv6强制升级后 应该大部分人都是用AFN3.0了）指定的code 如 -1101, 1102等</p>
</li>
<li><p>你自己请求制定的errorcode。 如 errorcode : 7, message : “您还没有登录” 或 errorcode:10,message:”签名验证失败” </p>
</li>
</ol>
<p>还有很重要一点，就是将自己的所有接口做成一整套映射的编号， 举个例子67对应的是persondetail接口。出现了请求错误，上传的请求错误码应该包含两个部分：接口编号+错误编号。 错误编号建议优先使用自己制定的errcode，其次是AFNcode，最后才是HTTPresponsecode。</p>
<p>“67-10” “35-404” 如果以后上报了类似的错误码，当然比只看到转菊花要好定位的多。</p>
<p>最后提当下的第三方性能监控平台，有听云，OneApm，博睿。 这里就不一一对比每一个平台的优缺点了，因为大体上都是差不多的。</p>
<p>就拿oneapm来说吧，首先ui做的比其他今个平台都要好，让人感觉更专业一点。  接入的方式也是对代码侵入性较小，接一个SDK大小6M左右，加几个framework，然后main函数加一行代码，上传的token是注册后生成的。</p>
<p>我在自己github的一个库里接了这个sdk，后来发现用的人还不少。里面有demo和一些性能监测平台的截图有兴趣可以去看看</p>
<p><a href="https://github.com/dsxNiubility/SXNews" target="_blank" rel="external">https://github.com/dsxNiubility/SXNews</a>  </p>
<p>核心功能（这里说一下，我只用了这些平台的移动端功能）也就是包括：UI交互，url响应时间，用户的版本地域系统分布，及crash。 其中崩溃率如果需要统计的话需要手动上传dsym文件。  并且用着用着就遇到了我前面说的问题，有一些我们不需要的功能，并且也有一些我们需要他却没有的功能，比如帧率和webView中的子url响应时间。 优点内就是FE展示时指标内的图表很清晰，并且可以自定义定制仪表盘。这是一个小公司自己写sdk前期难以达到的。  还有一点就是可配置，在设置页面可以自行选择自己所关注的指标。 然后程序每次启动都会先有一个GET请求获取配置，哪些打开哪些关闭，然后测量和上传我们需要的（这里有一点可疑的是，他是真没测量还是全都测量上传了，只是在控制台里不给你展示罢了），我们自写的sdk做个可配置也是必要的。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/02/20/iOS-APP上线性能检测/" data-id="cipthkkev000bwcs6seqf7vvo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS中使用ZXing库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/20/iOS中使用ZXing库/" class="article-date">
  <time datetime="2014-01-20T14:02:30.000Z" itemprop="datePublished">2014-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/20/iOS中使用ZXing库/">iOS中使用ZXing库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>前言<br>ZXing(Github镜像地址)是一个开源的条码生成和扫描库（开源协议为Apache2.0)。它不但支持众多的条码格式，而且有各种语言的实现版本，它支持的语言包括：Java, C++, C#, Objective-C, ActionScript和Ruby。<br>我上周在iOS项目开发中使用了ZXing的扫描二维码功能。在此总结一下如何将ZXing集成到已有的iOS工程中，分享给大家。<br>集成步骤<br>首先去Google Code或Github将ZXing的代码下载下来，整个工程比较大，我们只需要其中涉及iOS的部分，所以最好做一些裁剪。简单来说，我们只需要保留cpp和iphone这2个文件夹，其余的全部删掉。如下图所示：</p>
<p>接着我们继续裁剪，对于cpp这个目录，只保留cpp/core/src/zxing下面的内容，其余内容也可以删掉了。但是整个目录结构必须保持原样。裁剪完后，整个目录结构如下所示：</p>
<p>接下来，我们把裁剪后的zxing目录整个移动到我们的iOS项目的目录下，并且把上图中可以看到的ZXingWidget.xcodeproj文件拖动到我们的iOS工程中。<br>下一步，我们需要设置ZXing项目和我们原本的iOS项目之间的依赖关系。在我们的iOS项目的设置中，点击build phases tab，然后增加 Target Dependencies 和 Link binary，并且增加这些framework依赖：<br>a. AVFoundation<br>b. AudioToolbox<br>c. CoreVideo<br>d. CoreMedia<br>e. libiconv<br>f. AddressBook<br>g. AddressBookUI</p>
<p>最后一步，在设置中增加如下2个header search path:<br>./zxing/iphone/ZXingWidget/Classes<br>./zxing/cpp/core/src<br>需要注意的是，第一个path要设置成循环查找子目录，而第二个不循环查找，如下图所示：</p>
<p>恭喜你，完成这步之后，你就已经完成ZXing库的集成了。下面谈谈如何使用ZXing库来做二维码识别。<br>二维码识别<br>ZXing的iOS版本提供2种方法来做二维码识别功能，第一种方法比较简单，第二种方法比较复杂。我在做Demo时使用了第一种方法，做真正项目开发的时候使用了第二种方法，所以都给大家介绍一下。<br>使用方法一<br>ZXing直接提供了一个扫描二维码的View Controller，即ZXingWidgetController。在需要使用的界面代码中，加入文件依赖：</p>
<p>#import <zxingwidgetcontroller.h></zxingwidgetcontroller.h></p>
<p>#import <qrcodereader.h><br><code>然后在需要扫描的时候，调用如下代码即可：</code> objc</qrcodereader.h></p>
<ul>
<li>(IBAction)scanPressed:(id)sender {<br>ZXingWidgetController <em>widController = [[ZXingWidgetController alloc] initWithDelegate:self showCancel:YES OneDMode:NO];<br>NSMutableSet </em>readers = [[NSMutableSet alloc ] init];<br>QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];<br>[readers addObject:qrcodeReader];<br>[qrcodeReader release];<br>widController.readers = readers;<br>[readers release];<br>[self presentModalViewController:widController animated:YES];<br>[widController release];<br>}<br>在ZXing扫描有结果时，会调用如下回调函数：</li>
</ul>
<p>@protocol ZXingDelegate</p>
<ul>
<li>(void)zxingController:(ZXingWidgetController<em>)controller didScanResult:(NSString </em>)result;</li>
<li>(void)zxingControllerDidCancel:(ZXingWidgetController*)controller;<br>@end<br>使用方法二<br>方法二与方法一的区别就相当于AVFoundation和UIImagePickerController的区别一样。简单来说，就是使用方法二比方法一更加麻烦，但是获得的可定制性更高。<br>使用方法二时，你需要自己用AVFoundation获得Camera返回的实时图象，然后转成UIImage，最后传给ZXing的Decoder类完成二维码的识别。由于使用AVFoundation涉及的代码略多，我写的示意代码如下：</li>
</ul>
<p>#import “Decoder.h”</p>
<p>#import “TwoDDecoderResult.h”</p>
<p>#import “QRCodeReader.h”</p>
<ul>
<li>(void)viewDidLoad {<br>// setup QR reader<br>self.qrReader = [[NSMutableSet alloc ] init];<br>QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];<br>[self.qrReader addObject:qrcodeReader];<br>self.scanningQR = NO;<br>self.step = STEP_QR;<br>}</li>
</ul>
<p>// AVFoundation的回调函数</p>
<ul>
<li>(void)captureOutput:(AVCaptureOutput <em>)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection </em>)connection {<br>// 第一步，将sampleBuffer转成UIImage<br>UIImage <em>image= [self getCaptureImage:sampleBuffer];<br>// 第二步，用Decoder识别图象<br>Decoder </em>d = [[Decoder alloc] init];<br>d.readers = self.qrReader;<br>d.delegate = self;<br>self.scanningQR = [d decodeImage:image] == YES ? NO : YES;<br>}<br>ZXing的Decoder类提供了以下回调函数获得识别结果：<br>@protocol DecoderDelegate<nsobject><br>@optional</nsobject></li>
<li>(void)decoder:(Decoder <em>)decoder willDecodeImage:(UIImage </em>)image usingSubset:(UIImage *)subset;</li>
<li>(void)decoder:(Decoder <em>)decoder didDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset withResult:(TwoDDecoderResult </em>)result {<br>NSLog(@”result = %@”, [result text]);<br>}</li>
<li>(void)decoder:(Decoder <em>)decoder failedToDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset reason:(NSString </em>)reason;</li>
<li>(void)decoder:(Decoder *)decoder foundPossibleResultPoint:(CGPoint)point;</li>
</ul>
<p>@end<br>Trouble Shoot &amp; Tips<br>我在使用中遇到了一些问题，主要是编译的问题。<br>一个是找不到 头文件。解决方法：把用到ZXing的源文件扩展名由.m改成.mm。<br>报错：Undefined symbols for architecture armv7s，解决方法：把ZXingWidget的一个build target参数：”Build Active Architecture Only” 修改成 “NO”.<br>报错：No such file or directory，出现该错误可能是你的Header Search Path写错了，或者就是你的zxing库的目录结构不是我上面强调的，好好检查一下吧。<br>如果你需要生成二维码做测试，推荐一个不错的在线生成二维码的网站：<a href="http://cli.im/" target="_blank" rel="external">http://cli.im/</a><br>ZXing和OpenCV的兼容问题<br>ZXing 2.1 和OpenCV 2.4.3的iOS库有一些兼容问题，他们对C++标准库的版本和编译器版本都有一些需求，造成满足一方了，另一方就编译不通过了。Stackoverflow上有人终于找到了一个让它们和平共处的方法，但是只适用于iOS5.0以上版本。正好我们的App只支持iOS5.0+，所以就搞定了。所以如果你也正好遇到这个问题，可以参考这个贴子。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/20/iOS中使用ZXing库/" data-id="cipthkkgp000vwcs6nyks0seg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS应用内支付小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/14/iOS应用内支付小结/" class="article-date">
  <time datetime="2014-01-14T13:53:23.000Z" itemprop="datePublished">2014-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/14/iOS应用内支付小结/">iOS应用内支付小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>我们在今年春节后上线了新的在线智能题库：猿题库。这应该是我们在互联网教育这个创业领域尝试的第二个方向。<br>猿题库现在推出了公务员考试行测和申论 2 个产品，均包括 web, iOS 和 Android 三个平台。这次我们尝试做一个收费的产品，所以在 iOS 端集成了应用内支付（IAP）功能。在开发过程中和上线后，我们遇到了 IAP 中的一些坑，在此分享给各位。<br>IAP 审核相关的坑<br>IAP 开发的详细步骤我写在 另一篇博客 中了。在此主要介绍审核时遇到的问题。<br>IAP 类型错误<br>由于我们是按月付费的产品，所以在设置 IAP 类型时，我没有经验，只是简单设置成了可重复消费 (Consumable) 的 IAP 项目。但是我不知道，苹果对于这种按时间收费的产品，应该使用不可更新的定阅（Non-Renewing Subscription）类型。这个类型设置错误造成了我们 app 的一次审核被拒。<br>IAP 验证逻辑<br>由于苹果在 iOS5.0 以下有 IAP 的 bug，使得攻击者可以伪造支付成功的凭证。而 iOS6.0 的系统在越狱后同样可以伪造凭证，所以我们对于应用内支付，增加了服务器端的验证。<br>服务器端会将支付凭证发给苹果的服务器进行二次验证，以保证凭证是真实有效的。<br>在我们公司的测试服务器中，我们会连接苹果的测试服务器（ <a href="https://sandbox.itunes.apple.com/verifyReceipt" target="_blank" rel="external">https://sandbox.itunes.apple.com/verifyReceipt</a> ）验证。<br>在我们部署在线上的正式服务器中，我们会连接苹果的正式服务器（ <a href="https://buy.itunes.apple.com/verifyReceipt" target="_blank" rel="external">https://buy.itunes.apple.com/verifyReceipt</a> ）验证。<br>我们提交给苹果审核的是正式版，我们以为苹果审核时，我们应该连接苹果的线上验证服务器来验证购买凭证。结果我理解错了，苹果在审核 App 时，只会在 sandbox 环境购买，其产生的购买凭证，也只能连接苹果的测试验证服务器。但是审核的 app 又是连接的我们的线上服务器。所以我们这边的服务器无法验证通过 IAP 购买，造成我们 app 的又一次审核被拒。<br>解决方法是判断苹果正式验证服务器的返回 code，如果是 21007，则再一次连接测试服务器进行验证即可。苹果的 这一篇文档 上有对返回的 code 的详细说明。<br>IAP 上线后的遇到的情况<br>我们在服务器端增加了验证 IAP 是否有效的逻辑。在产品上线后，如我们所料，我们收到了大量的欺骗性购买，这些都被我们的服务器识别出来了，但是我们也遇到了以下这次没有想到的情况:<br>1、由于国内越狱用户的比例比较大 (2012 年底国内越狱比例是 42%), 所以虽然我们服务器会验证购买凭证，但是每天有超过 50% 以上的凭证都是伪造的。同时由于苹果的验证服务器在美国，凭证验证请求响应的时间比较慢，大量的伪造凭证发给苹果服务器，不知道会不会被苹果认为我们是在恶意进行 DDOS。至少我们发现有些时候，验证请求会超时。<br>2、由于国内有许多小白用户，他们的手机从购买时就被渠道商帮忙越狱过了并且安装了 IAP free 插件。所以对于这类用户，他们即使想付费购买，由于系统原有的 IAP 支付功能已经被破坏，所以他们是无法正常付费的。麻烦的是，他们会以为这是我们的 app 的问题，转而给我们的客服打电话投诉。这让我们非常郁闷。<br>3、苹果的验证服务器有时候会出问题，我们发现本来约定好返回的 JSON 数据在有几次返回的居然是一个 XML 格式的文件。造成我们将正常的付费 IAP 凭证验证失败。所以，在服务器记录下所有的验证凭证非常有必要，一来可以防止黑客多次提交同一个成功凭证的重放攻击，二来在需要时可以手工进行再验证。<br>越狱手机可能被黑客窃取购买凭证！！<br>我们发现有一部分用户反馈说已经收到苹果的扣费账单，但是我们从服务器的验证记录看，他上传的凭证却是虚假的。由于这些用户不太多，我们一开始以为是用户在恶意欺骗我们，后来我们让他将苹果的付费账单邮件转发给我们，以及将 itunes 的购买记录截图转发给我们，随着讨论的深入，我们越来越怀疑这里面有一个黑色的产业链。越狱手机的正常购买凭证可能被黑客的恶意程序截获，具体的攻击方式我们讨论了一下，其实就是被 中间人攻击，详细的过程如下:<br>越狱手机的在被破解后，可能从一些破解渠道安装了黑客的恶意程序。<br>黑客将越狱手机所有 https 请求都经过他的中间服务器。<br>当有支付请求时，黑客先将请求发给苹果服务器，待苹果将成功的凭证返回后，黑客将这个凭证替换成假的凭证，完全支付凭证的偷取。<br>或许有人会问，这个凭证拿来有什么用呢 ? 很简单 ，因为苹果为了保护用户的隐私，支付凭证中并不包含任何用户的 apple id 信息，所以我们的 app 和服务器无法知道这个凭证是谁买的，而只能知道这个凭证是真的还是假的。于是黑客就可以用这个凭证，在另外的账号中通知我们完成了购买，而发来的验证凭证又是真实的，所以我们的服务器就会误认为是黑客的账号完成了购买，继而把会员期算在黑客的账号上。<br>再举一个简单的例子，你拿 500 块钱买了顺风优选的 500 元购物券，由于这个购物券是不记名的，所以顺风优选无法知道是谁买的。如果这个购物券在发放过程中被人掉包，那么偷购物券的人就可以拿这个偷来的真购物券来购物，而顺风优选的卡因为是不记名的，所以也无法查证这件事情。在这个例子中，购物券的不记名和苹果的支付凭证无账号信息是同一个道理。<br>鉴于以上情况，考虑到越狱手机不但不能成功支付，还会有安全问题，所以我们在新版中取消了越狱手机中的 IAP 支付功能。<br>所以，请大家还是不要越狱自己的手机，iPhone 手机越狱后风险相当大。实在不值得为了免费玩几个游戏就丢掉安全性。<br>后记<br>中间人攻击的演示<br>iOS 独立开发者 王轲 _IndieBros 在他的博客文章 《使用 mitmproxy 获取 iTunes 11 的 Raw HTTPs Response》 中演示了如何使用中间人攻击来修改 Game Center 游戏数据。王轲还把我的例子白话翻译了一下（可见我还是说得太绕了，囧）：<br>坏人在购买过程中插了一腿，换走了用户的无记名发票（购物小票形象些），然后手持无记名小票伪装成真实顾客或者转手出售获利。<br>关于越狱与盗版<br>不少细心的同学评论纠正我，指出越狱并不等同于使用盗版。确实，如果说严格的定义，越狱只是让 iPhone 获得 root 权限，进而可以做任何事情。如果越狱的同学在越狱后不安装 IAP free 插件，不使用 app sync 插件，不使用任何国内的和非 bigboss 的 cydia 源，不使用任何盗版软件，所有应用都是从 app store 官方网站上下载的话，被黑客攻击的可能性会降低一些。<br>即使这样，由于手机已经被 root 了，苹果的沙盒安全机制失效，所以风险还是很大的。<br>关于越狱用户的比例<br>有同学提出我文章中写的越狱手机比例太高了，想询问数据来源。这个比例主要来自我们自己的 app 的统计信息，以及结合国内的统计工具友盟的 越狱手机比例统计，去年底国内的越狱比例是 42%。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/14/iOS应用内支付小结/" data-id="cipthkkgi000twcs69ycoiydo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-从Facebook看iOS移动端的开发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/01/从Facebook看iOS移动端的开发/" class="article-date">
  <time datetime="2014-01-01T13:47:31.000Z" itemprop="datePublished">2014-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/01/从Facebook看iOS移动端的开发/">从Facebook看iOS移动端的开发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>从 Facebook 谈起<br>Facebook 最近绝对是互联网界的新闻明星。它首先是进行了大手笔的收购：2014 年 2 月，Facebook 以 160 亿美元现金加股票，以及 30 亿美元受限制股票福利的方式 收购移动 IM 应用 WhatsApp，总收购成本 190 亿美元。然后是继续发布了新产品：2014 年 2 月，Facebook 发布了一个新的移动端新闻阅读应用 Paper。最后，Facebook 最近还将自己使用的大量工具开源，包括开源了 Paper 的加载效果 Shimmer，LLDB 的增强工具 chisel，以及 Key-Value Observing 工具 KVOController，如果说这些开源工具让程序员如获至宝的话，那么 Facebook 将 Paper 的交互设计工具 Origami 免费开放，则是对广大设计师的福音，极大地方便了移动交互设计工作的开展。<br>2014 年对于 Facebook 来说也是一个值得纪念的日子。因为从 2004 年 2 月 4 日 Facebook 产品上线到现在，Facebook 刚刚走过 10 个年头。10 年前，Facebook 的创始人扎克伯格才 19 岁，是哈佛大学的一名学生。转眼间 10 年后，Facebook 已经成长为全球最大的社交网络，月活跃用户达到 12 亿，市值约 1200 亿美元。<br>业界内大多讨论的话题都围绕在 Facebook 收购 WhatsApp 这件事情上，而作为一个移动开发者，我更加看重 Facebook 发布 Paper 这件事情。因为 Paper 并不是一个简单的应用，它有着非常优秀的交互效果，并且在产品设计和技术上都使用了许多前沿的技术，那就让我们看看，Paper 的开发到底有何不同之处？<br>交互设计<br>我们首先从产品设计上看 Paper 的不同之处。Paper 虽然只是一个新闻客户端，但从大家对 Paper 的评价上，我们发现优秀的交互再一次成为大家关注的焦点。回想那些成功的应用，大多都有着令人心动的交互效果，例如：Tweetie 的下拉刷新，现在基本上成为 iPhone 上内容刷新的标准。Path 跳出来的红心让人心动，很多朋友甚至会没事点那个红心，欣赏那流畅的按钮散开效果。还有 Mailbox，用流畅的手势操作，将邮件管理与任务管理完美结合起来。<br>国外成功的优秀应用也在影响着国内。交互设计不同于平面设计，不能简单地用 Photoshop 展现，而交互设计对于移动应用的成功又异常关键，所以需要花费不少时间来设计，因此产品经理很难兼顾地做交互设计。所以，在国内的一线互联网公司里，交互设计师这个职位慢慢成了移动应用的标配。但是在大部分的非一线互联网公司里面，移动开发的设计仍然停留在由产品经理简单潦草的完成阶段。所以，Facebook 这次 Paper 的成功发布，再一次给移动开发的从业者指出了交互设计的重要性。<br>回顾中国互联网产业的发展我们可以发现，产品经理（Product Manager）这个职位也是最近五、六年才成为互联网公司的标配的，想必在不远的将来，除着交互设计越来越重要，移动交互设计师也会成为每一个互联网公司重要的必备职位。<br>另一方面，由于工具的欠缺，大量的交互设计师的工作效率非常低下，他们为了做出一个新颖的效果常常需要花费大量精力。这次 Facebook 免费开放出基于苹果 Quartz Composer 的增强工具集 Origami，使得交互设计工作得到更好的辅助。而且在 Facebook 的带动下，jQC 1.0 也出现了。jQC 是一个与 Facebook 之前开源的 Origami 兼容的工具，提供了 15 个新的 Patch 来提高 Quartz Composer 的功能。<br>不过另一方面，该工具仍然需要设计师具备一定的基础编码能力，所以对于广大设计师来说，交互设计工具 Origami 对设计师带来的既是机会，同时也是挑战。<br>移动开发技术<br>随着 iOS 依赖管理工具 Cocoapods 和大量第三方开源库成熟起来，业界积累了大量的优秀开源项目。这次 Facebook 开发 Paper 使用了 将近 100 个第三方开源库，极大地减化了自己的应用开发任务。相信随着移动开发的发展，移动开发的生态圈会越来越成熟，基础的开源组件也将将越来越丰富，广大开发者都将从中受益。<br>另一方面，Facebook 的工程师在 Quora 上反馈 说 Paper 在 Xcode 下打开需要 40 多秒钟，编译一次需要 30 分钟。这反映出大量的开源库的使用也给 iOS 集成编译环境 Xcode 提出了新的挑战，相信苹果会花大力气解决 Xcode 的性能问题。<br>总结<br>Facebook 发布的 Paper 让我看到了移动开发领域的快速发展，大量新的工具和开源技术给了设计师和程序员机会和挑战，相信在移动互联网快速发展的浪潮中，会涌现出越来越多优秀的移动应用。谁会是未来移动互联网的霸主？让我们拭目以待。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/01/从Facebook看iOS移动端的开发/" data-id="cipthkkh50012wcs6hh6b77fc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/4/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">June 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">April 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">March 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">February 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">December 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">November 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">October 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">August 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/07/">July 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/01/">January 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/06/21/七牛上传视屏调用视屏播放器推介/">七牛上传视屏调用视屏播放器推介</a>
          </li>
        
          <li>
            <a href="/2016/06/14/WWDC——2016/">WWDC——2016</a>
          </li>
        
          <li>
            <a href="/2016/04/17/openGL学习/">openGL学习</a>
          </li>
        
          <li>
            <a href="/2016/04/05/MVVM/">MVVM</a>
          </li>
        
          <li>
            <a href="/2016/04/03/MVC/">MVC</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>