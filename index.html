<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>孙利峰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="孙利峰">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="孙利峰">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="孙利峰">
<meta name="twitter:description">
  
    <link rel="alternate" href="/atom.xml" title="孙利峰" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">孙利峰</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Bilibili开源的直播框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/22/Bilibili开源的直播框架/" class="article-date">
  <time datetime="2016-01-22T14:20:09.000Z" itemprop="datePublished">2016-01-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/22/Bilibili开源的直播框架/">Bilibili开源的直播框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>文档地址：<a href="http://www.jianshu.com/p/1f06b27b3ac0" target="_blank" rel="external">http://www.jianshu.com/p/1f06b27b3ac0</a></p>
<p>ijkplayer 是一款做视频直播的框架, 基于ffmpeg, 支持 Android 和 iOS, 网上也有很多集成说明, 但是个人觉得还是不够详细, 在这里详细的讲一下在 iOS 中如何集成ijkplayer, 即便以前从没有接触过, 按着下面做也可以集成成功!</p>
<p>一. 下载ijkplayer<br>ijkplayer下载地址:<a href="https://github.com/Bilibili/ijkplayer" target="_blank" rel="external">https://github.com/Bilibili/ijkplayer</a><br>下载完成后解压</p>
<p>二. 编译 ijkplayer<br>说是编译 ijkplayer, 其实是编译 ffmpeg, 在这里我们已经下载好了ijkplayer, 所以 github 上README.md中的Build iOS那一步中有一些步骤是不需要的.<br>下面开始一步一步编译:<br>1.打开终端, cd 到jkplayer-master文件夹中, 也就是下载完解压后的文件夹</p>
<p>2.执行命令行./init-ios.sh, 这一步是去下载 ffmpeg 的, 时间会久一点, 耐心等一下</p>
<p>3.在第2步中下载完成后, 执行cd ios, 也就是进入到 ios目录中</p>
<p>4.进入 ios 文件夹后, 在终端依次执行./compile-ffmpeg.sh clean和./compile-ffmpeg.sh all命令, 编译 ffmpeg, 也就是README.md中这两步</p>
<p>编译 ffmpeg<br>编译时间较久, 耐心等待一下.</p>
<p>三. 打包IJKMediaFramework.framework框架<br>集成 ijkplayer 有两种方法:<br>一种方法是按照IJKMediaDemo工程中那样, 直接导入工程IJKMediaPlayer.xcodeproj, 在这里不做介绍</p>
<p>导入IJKMediaPlayer.xcodeproj<br>第二种集成方法是把 ijkplayer 打包成framework导入工程中使用. 下面开始介绍如何打包IJKMediaFramework.framework, 按下面步骤开始一步一步做:</p>
<p>首先打开工程IJKMediaPlayer.xcodeproj<br>要打包的 framework 工程.png<br>2.工程打开后设置工程的 scheme</p>
<p>3.设置好 scheme 后, 分别选择真机和模拟器进行编译, 编译完成后, 进入 Finder</p>
<p>进入 Finder 后, 可以看到有真机和模拟器两个版本的编译结果</p>
<p>运行后生成的文件.png<br>下面开始合并真机和模拟器版本的 framework, 注意不要合并错了, 合并的是这个文件</p>
<p>合并真机和模拟器文件中的这个文件.png<br>打开终端, 进行合并, 命令行具体格式为:</p>
<p>lipo -create “真机版本路径” “模拟器版本路径” -output “合并后的文件路径”<br>合并</p>
<p>合并生成后的文件.png<br>下面很重要, 需要用合并后的IJKMediaFramework把原来的IJKMediaFramework替换掉, 如下图, 希望你能看懂:</p>
<p>用合并生成的文件替换原来的文件.png<br>上图中的1、2两步完成后, 绿色框住的那个IJKMediaFramework.framework文件就是我们需要的框架了, 可以复制出来, 稍后我们需要导入工程使用.</p>
<p>四. iOS工程中集成ijkplayer<br>新建工程, 导入合并后的IJKMediaFramework.framework以及相关依赖框架以及相关依赖框架</p>
<p>导入 framework及依赖框架.png<br>导入框架后, 在ViewController.m进行测试, 首先导入IJKMediaFramework.h头文件, 编译看有没有错, 如果没有错说明集成成功.<br>接着开始在ViewController.m文件中使用IJKMediaFramework框架进行测试使用, 写一个简单的直播视频进行测试, 在这里看一下运行后的结果, 后面会放上 Demo 供下载.</p>
<p>文／jianshu_wl（简书作者）<br>原文链接：<a href="http://www.jianshu.com/p/1f06b27b3ac0" target="_blank" rel="external">http://www.jianshu.com/p/1f06b27b3ac0</a><br>著作权归作者所有，转载请联系作者获得授权，并标注“简书作者”。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/22/Bilibili开源的直播框架/" data-id="cipfjlbkb0000e2s6sebhg9sg" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS三种视屏录制方式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/01/14/iOS三种视屏录制方式/" class="article-date">
  <time datetime="2016-01-14T14:14:49.000Z" itemprop="datePublished">2016-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/01/14/iOS三种视屏录制方式/">iOS三种视屏录制方式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>随着每一代 iPhone 处理能力和相机硬件配置的提高，使用它来捕获视频也变得更加有意思。它们小巧，轻便，低调，而且与专业摄像机之间的差距已经变得非常小，小到在某些情况下，iPhone 可以真正替代它们。</p>
<p>这篇文章讨论了关于如何配置视频捕获管线 (pipeline) 和最大限度地利用硬件性能的一些不同选择。 这里有个使用了不同管线的样例 app，可以在 GitHub 查看。</p>
<p>UIImagePickerController</p>
<p>目前，将视频捕获集成到你的应用中的最简单的方法是使用 UIImagePickerController。这是一个封装了完整视频捕获管线和相机 UI 的 view controller。</p>
<p>在实例化相机之前，首先要检查设备是否支持相机录制：</p>
<p>Objective-C</p>
<p>if ([UIImagePickerController<br>isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera]) {<br>NSArray <em>availableMediaTypes = [UIImagePickerController<br>availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera];<br>if ([availableMediaTypes containsObject:(NSString </em>)kUTTypeMovie]) {<br>// 支持视频录制<br>}<br>}<br>然后创建一个 UIImagePickerController 对象，设置好代理便于进一步处理录制好的视频 (比如存到相册) 以及对于用户关闭相机作出响应：</p>
<p>Objective-C</p>
<p>UIImagePickerController <em>camera = [UIImagePickerController new];<br>camera.sourceType = UIImagePickerControllerSourceTypeCamera;<br>camera.mediaTypes = @[(NSString </em>)kUTTypeMovie];<br>camera.delegate = self;<br>这是你实现一个功能完善的摄像机所需要写的所有代码。</p>
<p>相机配置</p>
<p>UIImagePickerController 提供了额外的配置选项。</p>
<p>通过设置 cameraDevice 属性可以选择一个特定的相机。这是一个 UIImagePickerControllerCameraDevice 枚举，默认情况下是 UIImagePickerControllerCameraDeviceRear，你也可以把它设置为 UIImagePickerControllerCameraDeviceFront。每次都应事先确认你想要设置的相机是可用的：</p>
<p>Objective-C</p>
<p>UIImagePickerController *camera = …<br>if ([UIImagePickerController isCameraDeviceAvailable:UIImagePickerControllerCameraDeviceFront]) {<br>[camera setCameraDevice:UIImagePickerControllerCameraDeviceFront];<br>}<br>videoQuality 属性用于控制录制视频的质量。它允许你设置一个特定的编码预设，从而改变视频的比特率和分辨率。以下是六种预设：</p>
<p>Objective-C</p>
<p>enum {<br>UIImagePickerControllerQualityTypeHigh             = 0,<br>UIImagePickerControllerQualityTypeMedium           = 1,  // default  value<br>UIImagePickerControllerQualityTypeLow              = 2,<br>UIImagePickerControllerQualityType640x480          = 3,<br>UIImagePickerControllerQualityTypeIFrame1280x720   = 4,<br>UIImagePickerControllerQualityTypeIFrame960x540    = 5<br>};<br>typedef NSUInteger  UIImagePickerControllerQualityType;<br>前三种为相对预设 (low, medium, high)。这些预设的编码配置会因设备不同而不同。如果选择 high，那么你选定的相机会提供给你该设备所能支持的最高画质。后面三种是特定分辨率的预设 (640×480 VGA, 960×540 iFrame, 和 1280×720 iFrame)。</p>
<p>自定义 UI</p>
<p>就像上面提到的，UIImagePickerController 自带一套相机 UI，可以直接使用。然而，你也可以自定义相机的控件，通过隐藏默认控件，然后创建带有控件的自定义视图，并覆盖在相机预览图层上面：</p>
<p>Objective-C</p>
<p>UIView *cameraOverlay = …<br>picker.showsCameraControls = NO;<br>picker.cameraOverlayView = cameraOverlay;<br>然后你需要将你覆盖层上的控件关联上 UIImagePickerController 的控制方法 (比如，startVideoCapture 和 stopVideoCapture)。</p>
<p>AVFoundation</p>
<p>如果你想要更多关于处理捕获视频的方法，而这些方法是 UIImagePickerController 所不能提供的，那么你需要使用 AVFoundation。</p>
<p>AVFoundation 中关于视频捕获的主要的类是 AVCaptureSession。它负责调配影音输入与输出之间的数据流：</p>
<p>AVCaptureSession setup<br>使用一个 capture session，你需要先实例化，添加输入与输出，接着启动从输入到输出之间的数据流：</p>
<p>Objective-C</p>
<p>AVCaptureSession <em>captureSession = [AVCaptureSession new];<br>AVCaptureDeviceInput </em>cameraDeviceInput = …<br>AVCaptureDeviceInput <em>micDeviceInput = …<br>AVCaptureMovieFileOutput </em>movieFileOutput = … </p>
<p>if ([captureSession canAddInput:cameraDeviceInput]) { </p>
<p>[captureSession addInput:cameraDeviceInput];</p>
<p>}</p>
<p>if ([captureSession canAddInput:micDeviceInput]) { </p>
<p>[captureSession addInput:micDeviceInput];</p>
<p>}</p>
<p>if ([captureSession canAddOutput:movieFileOutput]) { </p>
<p>[captureSession addOutput:movieFileOutput];</p>
<p>}</p>
<p>[captureSession startRunning];<br>(为了简单起见，调度队列 (dispatch queue) 的相关代码已经从上面那段代码中省略了。所有对 capture session 的调用都是阻塞的，因此建议将它们分配到后台串行队列中。)</p>
<p>capture session 可以通过一个 sessionPreset</p>
<p>来进一步配置，这可以用来指定输出质量的等级。有 11 种不同的预设模式：</p>
<p>Objective-C</p>
<p>NSString <em>const  AVCaptureSessionPresetPhoto;<br>NSString </em>const  AVCaptureSessionPresetHigh;<br>NSString <em>const  AVCaptureSessionPresetMedium;<br>NSString </em>const  AVCaptureSessionPresetLow;<br>NSString <em>const  AVCaptureSessionPreset352x288;<br>NSString </em>const  AVCaptureSessionPreset640x480;<br>NSString <em>const  AVCaptureSessionPreset1280x720;<br>NSString </em>const  AVCaptureSessionPreset1920x1080;<br>NSString <em>const  AVCaptureSessionPresetiFrame960x540;<br>NSString </em>const  AVCaptureSessionPresetiFrame1280x720;<br>NSString *const  AVCaptureSessionPresetInputPriority;<br>第一个代表高像素图片输出。 接下来的九个和之前我们在设置 UIImagePickerController 的 videoQuality 时看到过的 UIImagePickerControllerQualityType 选项非常相似，不同的是，这里有一些额外可用于 capture session 的预设。 最后一个 (AVCaptureSessionPresetInputPriority) 代表 capture session 不去控制音频与视频输出设置。而是通过已连接的捕获设备的 activeFormat 来反过来控制 capture session 的输出质量等级。在下一节，我们将会看到更多关于设备和设备格式的细节。</p>
<p>输入<br>AVCaptureSession 的输入其实就是一个或多个的 AVCaptureDevice 对象，这些对象通过 AVCaptureDeviceInput 连接上 capture session。</p>
<p>我们可以使用 [AVCaptureDevice devices] 来寻找可用的捕获设备。以 iPhone 6 为例：</p>
<p>Objective-C</p>
<p>(</p>
<p>“<avcapturefigvideodevice: 0x136514db0="" [back="" camera][com.apple.avfoundation.avcapturedevice.built-in_video:0]="">”,</avcapturefigvideodevice:></p>
<p>“<avcapturefigvideodevice: 0x13660be80="" [front="" camera][com.apple.avfoundation.avcapturedevice.built-in_video:1]="">”,</avcapturefigvideodevice:></p>
<p>“<avcapturefigaudiodevice: 0x174265e80="" [iphone="" microphone][com.apple.avfoundation.avcapturedevice.built-in_audio:0]="">”</avcapturefigaudiodevice:></p>
<p>)<br>视频输入<br>配置相机输入，需要实例化一个 AVCaptureDeviceInput 对象，参数是你期望的相机设备，然后把它添加到 capture session：</p>
<p>Objective-C</p>
<p>AVCaptureSession <em>captureSession = …<br>AVCaptureDevice </em>cameraDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];<br>NSError *error; </p>
<p>AVCaptureDeviceInput *cameraDeviceInput = [[AVCaptureDeviceInput alloc] initWithDevice:cameraDevice error:&amp;error]; </p>
<p>if ([captureSession canAddInput:input]) {<br>[captureSession addInput:cameraDeviceInput];<br>}<br>如果上面提到的 capture session 预设列表里能满足你的需求，那你就不需要做更多的事情了。如果不够，比如你想要高的帧率，你将需要配置具体的设备格式。一个视频捕获设备有许多设备格式，每个都带有特定的属性和功能。下面是对于 iPhone6 的后置摄像头的一些例子 (一共有 22 种可用格式)：</p>
<p>Objective-C</p>
<p>格式     分辨率        FPS      HRSI       FOV   VIS   最大放大比例  Upscales    AF  ISO SS  HDR</p>
<p>420v    1280x720    5 - 240 1280x720    54.626  YES 49.12   1.09    1   29.0 - 928  0.000003-0.200000   NO</p>
<p>420f    1280x720    5 - 240 1280x720    54.626  YES 49.12   1.09    1   29.0 - 928  0.000003-0.200000   NO</p>
<p>420v    1920x1080   2 - 30  3264x1836   58.040  YES 95.62   1.55    2   29.0 - 464  0.000013-0.500000   YES</p>
<p>420f    1920x1080   2 - 30  3264x1836   58.040  YES 95.62   1.55    2   29.0 - 464  0.000013-0.500000   YES</p>
<p>420v    1920x1080   2 - 60  3264x1836   58.040  YES 95.62   1.55    2   29.0 - 464  0.000008-0.500000   YES</p>
<p>420f    1920x1080   2 - 60  3264x1836   58.040  YES 95.62   1.55    2   29.0 - 464  0.000008-0.500000   YES</p>
<p>格式 = 像素格式<br>FPS = 支持帧数范围<br>HRSI = 高像素静态图片尺寸<br>FOV = 视角<br>VIS = 该格式支持视频防抖<br>Upscales = 加入数字 upscaling 时的放大比例<br>AF = 自动对焦系统（1 是反差对焦，2 是相位对焦）<br>ISO = 支持感光度范围<br>SS = 支持曝光时间范围<br>HDR = 支持高动态范围图像<br>通过上面的那些格式，你会发现如果要录制 240 帧每秒的视频的话，可以根据想要的像素格式选用第一个或第二个格式。另外若是要捕获 1920×1080 的分辨率的视频的话，是不支持 240 帧每秒的。</p>
<p>配置一个具体设备格式，你首先需要调用 lockForConfiguration: 来获取设备的配置属性的独占访问权限。接着你简单地使用 setActiveFormat: 来设置设备的捕获格式。这将会自动把 capture session 的预设设置为 AVCaptureSessionPresetInputPriority。</p>
<p>一旦你设置了预想的设备格式，你就可以在这种设备格式的约束参数范围内进行进一步的配置了。</p>
<p>对于视频捕获的对焦，曝光和白平衡的设置，与图像捕获时一样，具体可参考第 21 期“iOS 上的相机捕捉”。除了那些，这里还有一些视频特有的配置选项。</p>
<p>你可以用捕获设备的 activeVideoMinFrameDuration 和 activeVideoMaxFrameDuration 属性设置帧速率，一帧的时长是帧速率的倒数。设置帧速率之前，要先确认它是否在设备格式所支持的范围内，然后锁住捕获设备来进行配置。为了确保帧速率恒定，可以将最小与最大的帧时长设置成一样的值：</p>
<p>Objective-C</p>
<p>NSError *error; </p>
<p>CMTime frameDuration = CMTimeMake(1, 60);<br>NSArray *supportedFrameRateRanges = [device.activeFormat videoSupportedFrameRateRanges];<br>BOOL frameRateSupported = NO; </p>
<p>for (AVFrameRateRange *range in supportedFrameRateRanges) {<br>if (CMTIME_COMPARE_INLINE(frameDuration, &gt;=, range.minFrameDuration) &amp;&amp;<br>CMTIME_COMPARE_INLINE(frameDuration, &lt;=, range.maxFrameDuration)) {<br>frameRateSupported = YES;<br>}<br>}</p>
<p>if (frameRateSupported &amp;&amp; [device lockForConfiguration:&amp;error]) {<br>[device setActiveVideoMaxFrameDuration:frameDuration];<br>[device setActiveVideoMinFrameDuration:frameDuration];<br>[device unlockForConfiguration];<br>}<br>视频防抖 是在 iOS 6 和 iPhone 4S 发布时引入的功能。到了 iPhone 6，增加了更强劲和流畅的防抖模式，被称为影院级的视频防抖动。相关的 API 也有所改动 (目前为止并没有在文档中反映出来，不过可以查看头文件）。防抖并不是在捕获设备上配置的，而是在 AVCaptureConnection 上设置。由于不是所有的设备格式都支持全部的防抖模式，所以在实际应用中应事先确认具体的防抖模式是否支持：</p>
<p>Objective-C</p>
<p>AVCaptureDevice *device = …; </p>
<p>AVCaptureConnection *connection = …;</p>
<p>AVCaptureVideoStabilizationMode stabilizationMode = AVCaptureVideoStabilizationModeCinematic; </p>
<p>if ([device.activeFormat isVideoStabilizationModeSupported:stabilizationMode]) { </p>
<p>[connection setPreferredVideoStabilizationMode:stabilizationMode];</p>
<p>}<br>iPhone 6 的另一个新特性就是视频 HDR (高动态范围图像)，它是“高动态范围的视频流，与传统的将不同曝光度的静态图像合成成一张高动态范围图像的方法完全不同”，它是内建在传感器中的。有两种方法可以配置视频 HDR：直接将 capture device 的 videoHDREnabled 设置为启用或禁用，或者使用 automaticallyAdjustsVideoHDREnabled 属性来留给系统处理。</p>
<p>技术参考：iPhone 6 和 iPhone Plus 的新 AV Foundation 相机特性</p>
<p>音频输入<br>之前展示的捕获设备列表里面只有一个音频设备，你可能觉得奇怪，毕竟 iPhone 6 有 3 个麦克风。然而因为有时会放在一起使用，便于优化性能，因此可能被当做一个设备来使用。例如在 iPhone 5 及以上的手机录制视频时，会同时使用前置和后置麦克风，用于定向降噪。</p>
<p>Technical Q&amp;A: AVAudioSession – Microphone Selection</p>
<p>大多数情况下，设置成默认的麦克风配置即可。后置麦克风会自动搭配后置摄像头使用 (前置麦克风则用于降噪)，前置麦克风和前置摄像头也是一样。</p>
<p>然而想要访问和配置单独的麦克风也是可行的。例如，当用户正在使用后置摄像头捕获场景的时候，使用前置麦克风来录制解说也应是可能的。这就要依赖于 AVAudioSession。 为了变更要访问的音频，audio session 首先需要设置为支持这样做的类别。然后我们需要遍历 audio session 的输入端口和端口数据来源，来找到我们想要的麦克风：</p>
<p>Objective-C</p>
<p>// 配置 audio session<br>AVAudioSession *audioSession = [AVAudioSession sharedInstance];<br>[audioSession setCategory:AVAudioSessionCategoryPlayAndRecord error:nil];<br>[audioSession setActive:YES error:nil];</p>
<p>// 寻找期望的输入端口<br>NSArray<em> inputs = [audioSession availableInputs];<br>AVAudioSessionPortDescription </em>builtInMic = nil; </p>
<p>for (AVAudioSessionPortDescription* port in inputs) {<br>if ([port.portType isEqualToString:AVAudioSessionPortBuiltInMic]) {<br>builtInMic = port;<br>break;<br>}<br>}</p>
<p>// 寻找期望的麦克风</p>
<p>for (AVAudioSessionDataSourceDescription* source in builtInMic.dataSources) { </p>
<p>if ([source.orientation isEqual:AVAudioSessionOrientationFront]) {<br>[builtInMic setPreferredDataSource:source error:nil];<br>[audioSession setPreferredInput:builtInMic error:&amp;error];<br>break;<br>}<br>}<br>除了设置非默认的麦克风配置，你也可以使用 AVAudioSession 来配置其他音频设置，比如音频增益和采样率等。</p>
<p>访问权限<br>有件事你需要记住，访问相机和麦克风需要先获得用户授权。当你给视频或音频创建第一个 AVCaptureDeviceInput 对象时，iOS 会自动弹出一次对话框，请求用户授权，但你最好还是自己实现下。之后你就可以在还没有被授权的时候，使用相同的代码来提示用户进行授权。当用户未授权时，对于录制视频或音频的尝试，得到的将是黑色画面和无声。</p>
<p>输出<br>输入配置完了，现在把我们的注意力转向 capture session 的输出。</p>
<p>AVCaptureMovieFileOutput</p>
<p>将视频写入文件，最简单的选择就是使用 AVCaptureMovieFileOutput 对象。把它作为输出添加到 capture session 中，就可以将视频和音频写入 QuickTime 文件，这只需很少的配置。</p>
<p>Objective-C</p>
<p>AVCaptureMovieFileOutput *movieFileOutput = [AVCaptureMovieFileOutput new]; </p>
<p>if([captureSession canAddOutput:movieFileOutput]){ </p>
<p>[captureSession addOutput:movieFileOutput];</p>
<p>}</p>
<p>// 开始录制</p>
<p>NSURL *outputURL = … </p>
<p>[movieFileOutput startRecordingToOutputFileURL:outputURL recordingDelegate:self];<br>当实际的录制开始或停止时，想要接收回调的话就必须要一个录制代理。当录制停止时，输出通常还在写入数据，等它完成之后会调用代理方法。</p>
<p>AVCaptureMovieFileOutput 有一些其他的配置选项，比如在某段时间后，在达到某个指定的文件尺寸时，或者当设备的最小磁盘剩余空间达到某个阈值时停止录制。如果你还需要更多设置，比如自定义视频音频的压缩率，或者你想要在写入文件之前，处理视频音频的样本，那么你需要一些更复杂的操作。</p>
<p>AVCaptureDataOutput 和 AVAssetWriter</p>
<p>如果你想要对影音输出有更多的操作，你可以使用 AVCaptureVideoDataOutput 和 AVCaptureAudioDataOutput 而不是我们上节讨论的 AVCaptureMovieFileOutput。</p>
<p>这些输出将会各自捕获视频和音频的样本缓存，接着发送到它们的代理。代理要么对采样缓冲进行处理 (比如给视频加滤镜)，要么保持原样传送。使用 AVAssetWriter 对象可以将样本缓存写入文件：</p>
<p>Using an AVAssetWriter</p>
<p>配置一个 asset writer 需要定义一个输出 URL 和文件格式，并添加一个或多个输入来接收采样的缓冲。我们还需要将输入的 expectsMediaInRealTime属性设置为 YES，因为它们需要从 capture session 实时获得数据。</p>
<p>Objective-C</p>
<p>NSURL *url = …; </p>
<p>AVAssetWriter *assetWriter = [AVAssetWriter assetWriterWithURL:url fileType:AVFileTypeMPEG4 error:nil]; </p>
<p>AVAssetWriterInput *videoInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeVideo outputSettings:nil]; </p>
<p>videoInput.expectsMediaDataInRealTime = YES; </p>
<p>AVAssetWriterInput *audioInput = [[AVAssetWriterInput alloc] initWithMediaType:AVMediaTypeAudio outputSettings:nil]; </p>
<p>audioInput.expectsMediaDataInRealTime = YES; </p>
<p>if ([assetWriter canAddInput:videoInput]) { </p>
<p>[assetWriter addInput:videoInput];</p>
<p>}</p>
<p>if ([assetWriter canAddInput:audioInput]) { </p>
<p>[assetWriter addInput:audioInput];</p>
<p>}<br>(这里推荐将 asset writer 派送到后台串行队列中调用。)</p>
<p>在上面的示例代码中，我们将 asset writer 的 outputSettings 设置为 nil。这就意味着附加上来的样本不会再被重新编码。如果你确实想要重新编码这些样本，那么需要提供一个包含具体输出参数的字典。关于音频输出设置的键值被定义在这里, 关于视频输出设置的键值定义在这里。</p>
<p>为了更简单点，AVCaptureVideoDataOutput 和 AVCaptureAudioDataOutput 分别带有 recommendedVideoSettingsForAssetWriterWithOutputFileType: 和 recommendedAudioSettingsForAssetWriterWithOutputFileType: 方法，可以生成与 asset writer 兼容的带有全部键值对的字典。所以你可以通过在这个字典里调整你想要重写的属性，来简单地定义你自己的输出设置。比如，增加视频比特率来提高视频质量等。</p>
<p>或者，你也可以使用 AVOutputSettingsAssistant 来配置输出设置的字典，但是从我的经验来看，使用上面的方法会更好，它们会提供更实用的输出设置，比如视频比特率。另外，AVOutputSettingsAssistant 似乎存在一些缺点，例如，当你改变希望的视频的帧速率时，视频的比特率并不会改变。</p>
<p>实时预览</p>
<p>当使用 AVFoundation 来做图像捕获时，我们必须提供一套自定义的用户界面。其中一个关键的相机交互组件是实时预览图。最简单的实现方式是通过把 AVCaptureVideoPreviewLayer 对象作为一个 sublayer 加到相机图层上去：</p>
<p>Objective-C</p>
<p>AVCaptureSession <em>captureSession = …;<br>AVCaptureVideoPreviewLayer </em>previewLayer = [AVCaptureVideoPreviewLayer layerWithSession:captureSession];<br>UIView *cameraView = …;<br>previewLayer.frame = cameraView.bounds;<br>[cameraView.layer addSublayer:previewLayer];<br>如果你想要更进一步操作，比如，在实时预览图加滤镜，你需要将 AVCaptureVideoDataOutput 对象加到 capture session，并且使用 OpenGL 展示画面，具体可查看该文“iOS 上的相机捕捉”</p>
<p>总结</p>
<p>有许多不同的方法可以给 iOS 上的视频捕获配置管线，从最直接的 UIImagePickerController，到精密配合的 AVCaptureSession 与 AVAssetWriter。如何抉择取决于你的项目要求，比如期望的视频质量和压缩率，或者是你想要展示给用户的相机控件。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/01/14/iOS三种视屏录制方式/" data-id="cipfjlbl20008e2s6qoi5i93x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS中使用ZXing库" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/20/iOS中使用ZXing库/" class="article-date">
  <time datetime="2014-01-20T14:02:30.000Z" itemprop="datePublished">2014-01-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/20/iOS中使用ZXing库/">iOS中使用ZXing库</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>前言<br>ZXing(Github镜像地址)是一个开源的条码生成和扫描库（开源协议为Apache2.0)。它不但支持众多的条码格式，而且有各种语言的实现版本，它支持的语言包括：Java, C++, C#, Objective-C, ActionScript和Ruby。<br>我上周在iOS项目开发中使用了ZXing的扫描二维码功能。在此总结一下如何将ZXing集成到已有的iOS工程中，分享给大家。<br>集成步骤<br>首先去Google Code或Github将ZXing的代码下载下来，整个工程比较大，我们只需要其中涉及iOS的部分，所以最好做一些裁剪。简单来说，我们只需要保留cpp和iphone这2个文件夹，其余的全部删掉。如下图所示：</p>
<p>接着我们继续裁剪，对于cpp这个目录，只保留cpp/core/src/zxing下面的内容，其余内容也可以删掉了。但是整个目录结构必须保持原样。裁剪完后，整个目录结构如下所示：</p>
<p>接下来，我们把裁剪后的zxing目录整个移动到我们的iOS项目的目录下，并且把上图中可以看到的ZXingWidget.xcodeproj文件拖动到我们的iOS工程中。<br>下一步，我们需要设置ZXing项目和我们原本的iOS项目之间的依赖关系。在我们的iOS项目的设置中，点击build phases tab，然后增加 Target Dependencies 和 Link binary，并且增加这些framework依赖：<br>a. AVFoundation<br>b. AudioToolbox<br>c. CoreVideo<br>d. CoreMedia<br>e. libiconv<br>f. AddressBook<br>g. AddressBookUI</p>
<p>最后一步，在设置中增加如下2个header search path:<br>./zxing/iphone/ZXingWidget/Classes<br>./zxing/cpp/core/src<br>需要注意的是，第一个path要设置成循环查找子目录，而第二个不循环查找，如下图所示：</p>
<p>恭喜你，完成这步之后，你就已经完成ZXing库的集成了。下面谈谈如何使用ZXing库来做二维码识别。<br>二维码识别<br>ZXing的iOS版本提供2种方法来做二维码识别功能，第一种方法比较简单，第二种方法比较复杂。我在做Demo时使用了第一种方法，做真正项目开发的时候使用了第二种方法，所以都给大家介绍一下。<br>使用方法一<br>ZXing直接提供了一个扫描二维码的View Controller，即ZXingWidgetController。在需要使用的界面代码中，加入文件依赖：</p>
<p>#import <zxingwidgetcontroller.h></zxingwidgetcontroller.h></p>
<p>#import <qrcodereader.h><br><code>然后在需要扫描的时候，调用如下代码即可：</code> objc</qrcodereader.h></p>
<ul>
<li>(IBAction)scanPressed:(id)sender {<br>ZXingWidgetController <em>widController = [[ZXingWidgetController alloc] initWithDelegate:self showCancel:YES OneDMode:NO];<br>NSMutableSet </em>readers = [[NSMutableSet alloc ] init];<br>QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];<br>[readers addObject:qrcodeReader];<br>[qrcodeReader release];<br>widController.readers = readers;<br>[readers release];<br>[self presentModalViewController:widController animated:YES];<br>[widController release];<br>}<br>在ZXing扫描有结果时，会调用如下回调函数：</li>
</ul>
<p>@protocol ZXingDelegate</p>
<ul>
<li>(void)zxingController:(ZXingWidgetController<em>)controller didScanResult:(NSString </em>)result;</li>
<li>(void)zxingControllerDidCancel:(ZXingWidgetController*)controller;<br>@end<br>使用方法二<br>方法二与方法一的区别就相当于AVFoundation和UIImagePickerController的区别一样。简单来说，就是使用方法二比方法一更加麻烦，但是获得的可定制性更高。<br>使用方法二时，你需要自己用AVFoundation获得Camera返回的实时图象，然后转成UIImage，最后传给ZXing的Decoder类完成二维码的识别。由于使用AVFoundation涉及的代码略多，我写的示意代码如下：</li>
</ul>
<p>#import “Decoder.h”</p>
<p>#import “TwoDDecoderResult.h”</p>
<p>#import “QRCodeReader.h”</p>
<ul>
<li>(void)viewDidLoad {<br>// setup QR reader<br>self.qrReader = [[NSMutableSet alloc ] init];<br>QRCodeReader* qrcodeReader = [[QRCodeReader alloc] init];<br>[self.qrReader addObject:qrcodeReader];<br>self.scanningQR = NO;<br>self.step = STEP_QR;<br>}</li>
</ul>
<p>// AVFoundation的回调函数</p>
<ul>
<li>(void)captureOutput:(AVCaptureOutput <em>)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection </em>)connection {<br>// 第一步，将sampleBuffer转成UIImage<br>UIImage <em>image= [self getCaptureImage:sampleBuffer];<br>// 第二步，用Decoder识别图象<br>Decoder </em>d = [[Decoder alloc] init];<br>d.readers = self.qrReader;<br>d.delegate = self;<br>self.scanningQR = [d decodeImage:image] == YES ? NO : YES;<br>}<br>ZXing的Decoder类提供了以下回调函数获得识别结果：<br>@protocol DecoderDelegate<nsobject><br>@optional</nsobject></li>
<li>(void)decoder:(Decoder <em>)decoder willDecodeImage:(UIImage </em>)image usingSubset:(UIImage *)subset;</li>
<li>(void)decoder:(Decoder <em>)decoder didDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset withResult:(TwoDDecoderResult </em>)result {<br>NSLog(@”result = %@”, [result text]);<br>}</li>
<li>(void)decoder:(Decoder <em>)decoder failedToDecodeImage:(UIImage </em>)image usingSubset:(UIImage <em>)subset reason:(NSString </em>)reason;</li>
<li>(void)decoder:(Decoder *)decoder foundPossibleResultPoint:(CGPoint)point;</li>
</ul>
<p>@end<br>Trouble Shoot &amp; Tips<br>我在使用中遇到了一些问题，主要是编译的问题。<br>一个是找不到 头文件。解决方法：把用到ZXing的源文件扩展名由.m改成.mm。<br>报错：Undefined symbols for architecture armv7s，解决方法：把ZXingWidget的一个build target参数：”Build Active Architecture Only” 修改成 “NO”.<br>报错：No such file or directory，出现该错误可能是你的Header Search Path写错了，或者就是你的zxing库的目录结构不是我上面强调的，好好检查一下吧。<br>如果你需要生成二维码做测试，推荐一个不错的在线生成二维码的网站：<a href="http://cli.im/" target="_blank" rel="external">http://cli.im/</a><br>ZXing和OpenCV的兼容问题<br>ZXing 2.1 和OpenCV 2.4.3的iOS库有一些兼容问题，他们对C++标准库的版本和编译器版本都有一些需求，造成满足一方了，另一方就编译不通过了。Stackoverflow上有人终于找到了一个让它们和平共处的方法，但是只适用于iOS5.0以上版本。正好我们的App只支持iOS5.0+，所以就搞定了。所以如果你也正好遇到这个问题，可以参考这个贴子。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/20/iOS中使用ZXing库/" data-id="cipfjlbla000ae2s6mczy5omf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS应用内支付小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/14/iOS应用内支付小结/" class="article-date">
  <time datetime="2014-01-14T13:53:23.000Z" itemprop="datePublished">2014-01-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/14/iOS应用内支付小结/">iOS应用内支付小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>我们在今年春节后上线了新的在线智能题库：猿题库。这应该是我们在互联网教育这个创业领域尝试的第二个方向。<br>猿题库现在推出了公务员考试行测和申论 2 个产品，均包括 web, iOS 和 Android 三个平台。这次我们尝试做一个收费的产品，所以在 iOS 端集成了应用内支付（IAP）功能。在开发过程中和上线后，我们遇到了 IAP 中的一些坑，在此分享给各位。<br>IAP 审核相关的坑<br>IAP 开发的详细步骤我写在 另一篇博客 中了。在此主要介绍审核时遇到的问题。<br>IAP 类型错误<br>由于我们是按月付费的产品，所以在设置 IAP 类型时，我没有经验，只是简单设置成了可重复消费 (Consumable) 的 IAP 项目。但是我不知道，苹果对于这种按时间收费的产品，应该使用不可更新的定阅（Non-Renewing Subscription）类型。这个类型设置错误造成了我们 app 的一次审核被拒。<br>IAP 验证逻辑<br>由于苹果在 iOS5.0 以下有 IAP 的 bug，使得攻击者可以伪造支付成功的凭证。而 iOS6.0 的系统在越狱后同样可以伪造凭证，所以我们对于应用内支付，增加了服务器端的验证。<br>服务器端会将支付凭证发给苹果的服务器进行二次验证，以保证凭证是真实有效的。<br>在我们公司的测试服务器中，我们会连接苹果的测试服务器（ <a href="https://sandbox.itunes.apple.com/verifyReceipt" target="_blank" rel="external">https://sandbox.itunes.apple.com/verifyReceipt</a> ）验证。<br>在我们部署在线上的正式服务器中，我们会连接苹果的正式服务器（ <a href="https://buy.itunes.apple.com/verifyReceipt" target="_blank" rel="external">https://buy.itunes.apple.com/verifyReceipt</a> ）验证。<br>我们提交给苹果审核的是正式版，我们以为苹果审核时，我们应该连接苹果的线上验证服务器来验证购买凭证。结果我理解错了，苹果在审核 App 时，只会在 sandbox 环境购买，其产生的购买凭证，也只能连接苹果的测试验证服务器。但是审核的 app 又是连接的我们的线上服务器。所以我们这边的服务器无法验证通过 IAP 购买，造成我们 app 的又一次审核被拒。<br>解决方法是判断苹果正式验证服务器的返回 code，如果是 21007，则再一次连接测试服务器进行验证即可。苹果的 这一篇文档 上有对返回的 code 的详细说明。<br>IAP 上线后的遇到的情况<br>我们在服务器端增加了验证 IAP 是否有效的逻辑。在产品上线后，如我们所料，我们收到了大量的欺骗性购买，这些都被我们的服务器识别出来了，但是我们也遇到了以下这次没有想到的情况:<br>1、由于国内越狱用户的比例比较大 (2012 年底国内越狱比例是 42%), 所以虽然我们服务器会验证购买凭证，但是每天有超过 50% 以上的凭证都是伪造的。同时由于苹果的验证服务器在美国，凭证验证请求响应的时间比较慢，大量的伪造凭证发给苹果服务器，不知道会不会被苹果认为我们是在恶意进行 DDOS。至少我们发现有些时候，验证请求会超时。<br>2、由于国内有许多小白用户，他们的手机从购买时就被渠道商帮忙越狱过了并且安装了 IAP free 插件。所以对于这类用户，他们即使想付费购买，由于系统原有的 IAP 支付功能已经被破坏，所以他们是无法正常付费的。麻烦的是，他们会以为这是我们的 app 的问题，转而给我们的客服打电话投诉。这让我们非常郁闷。<br>3、苹果的验证服务器有时候会出问题，我们发现本来约定好返回的 JSON 数据在有几次返回的居然是一个 XML 格式的文件。造成我们将正常的付费 IAP 凭证验证失败。所以，在服务器记录下所有的验证凭证非常有必要，一来可以防止黑客多次提交同一个成功凭证的重放攻击，二来在需要时可以手工进行再验证。<br>越狱手机可能被黑客窃取购买凭证！！<br>我们发现有一部分用户反馈说已经收到苹果的扣费账单，但是我们从服务器的验证记录看，他上传的凭证却是虚假的。由于这些用户不太多，我们一开始以为是用户在恶意欺骗我们，后来我们让他将苹果的付费账单邮件转发给我们，以及将 itunes 的购买记录截图转发给我们，随着讨论的深入，我们越来越怀疑这里面有一个黑色的产业链。越狱手机的正常购买凭证可能被黑客的恶意程序截获，具体的攻击方式我们讨论了一下，其实就是被 中间人攻击，详细的过程如下:<br>越狱手机的在被破解后，可能从一些破解渠道安装了黑客的恶意程序。<br>黑客将越狱手机所有 https 请求都经过他的中间服务器。<br>当有支付请求时，黑客先将请求发给苹果服务器，待苹果将成功的凭证返回后，黑客将这个凭证替换成假的凭证，完全支付凭证的偷取。<br>或许有人会问，这个凭证拿来有什么用呢 ? 很简单 ，因为苹果为了保护用户的隐私，支付凭证中并不包含任何用户的 apple id 信息，所以我们的 app 和服务器无法知道这个凭证是谁买的，而只能知道这个凭证是真的还是假的。于是黑客就可以用这个凭证，在另外的账号中通知我们完成了购买，而发来的验证凭证又是真实的，所以我们的服务器就会误认为是黑客的账号完成了购买，继而把会员期算在黑客的账号上。<br>再举一个简单的例子，你拿 500 块钱买了顺风优选的 500 元购物券，由于这个购物券是不记名的，所以顺风优选无法知道是谁买的。如果这个购物券在发放过程中被人掉包，那么偷购物券的人就可以拿这个偷来的真购物券来购物，而顺风优选的卡因为是不记名的，所以也无法查证这件事情。在这个例子中，购物券的不记名和苹果的支付凭证无账号信息是同一个道理。<br>鉴于以上情况，考虑到越狱手机不但不能成功支付，还会有安全问题，所以我们在新版中取消了越狱手机中的 IAP 支付功能。<br>所以，请大家还是不要越狱自己的手机，iPhone 手机越狱后风险相当大。实在不值得为了免费玩几个游戏就丢掉安全性。<br>后记<br>中间人攻击的演示<br>iOS 独立开发者 王轲 _IndieBros 在他的博客文章 《使用 mitmproxy 获取 iTunes 11 的 Raw HTTPs Response》 中演示了如何使用中间人攻击来修改 Game Center 游戏数据。王轲还把我的例子白话翻译了一下（可见我还是说得太绕了，囧）：<br>坏人在购买过程中插了一腿，换走了用户的无记名发票（购物小票形象些），然后手持无记名小票伪装成真实顾客或者转手出售获利。<br>关于越狱与盗版<br>不少细心的同学评论纠正我，指出越狱并不等同于使用盗版。确实，如果说严格的定义，越狱只是让 iPhone 获得 root 权限，进而可以做任何事情。如果越狱的同学在越狱后不安装 IAP free 插件，不使用 app sync 插件，不使用任何国内的和非 bigboss 的 cydia 源，不使用任何盗版软件，所有应用都是从 app store 官方网站上下载的话，被黑客攻击的可能性会降低一些。<br>即使这样，由于手机已经被 root 了，苹果的沙盒安全机制失效，所以风险还是很大的。<br>关于越狱用户的比例<br>有同学提出我文章中写的越狱手机比例太高了，想询问数据来源。这个比例主要来自我们自己的 app 的统计信息，以及结合国内的统计工具友盟的 越狱手机比例统计，去年底国内的越狱比例是 42%。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/14/iOS应用内支付小结/" data-id="cipfjlblg000ce2s66mcnqrht" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-从Facebook看iOS移动端的开发" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2014/01/01/从Facebook看iOS移动端的开发/" class="article-date">
  <time datetime="2014-01-01T13:47:31.000Z" itemprop="datePublished">2014-01-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2014/01/01/从Facebook看iOS移动端的开发/">从Facebook看iOS移动端的开发</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>从 Facebook 谈起<br>Facebook 最近绝对是互联网界的新闻明星。它首先是进行了大手笔的收购：2014 年 2 月，Facebook 以 160 亿美元现金加股票，以及 30 亿美元受限制股票福利的方式 收购移动 IM 应用 WhatsApp，总收购成本 190 亿美元。然后是继续发布了新产品：2014 年 2 月，Facebook 发布了一个新的移动端新闻阅读应用 Paper。最后，Facebook 最近还将自己使用的大量工具开源，包括开源了 Paper 的加载效果 Shimmer，LLDB 的增强工具 chisel，以及 Key-Value Observing 工具 KVOController，如果说这些开源工具让程序员如获至宝的话，那么 Facebook 将 Paper 的交互设计工具 Origami 免费开放，则是对广大设计师的福音，极大地方便了移动交互设计工作的开展。<br>2014 年对于 Facebook 来说也是一个值得纪念的日子。因为从 2004 年 2 月 4 日 Facebook 产品上线到现在，Facebook 刚刚走过 10 个年头。10 年前，Facebook 的创始人扎克伯格才 19 岁，是哈佛大学的一名学生。转眼间 10 年后，Facebook 已经成长为全球最大的社交网络，月活跃用户达到 12 亿，市值约 1200 亿美元。<br>业界内大多讨论的话题都围绕在 Facebook 收购 WhatsApp 这件事情上，而作为一个移动开发者，我更加看重 Facebook 发布 Paper 这件事情。因为 Paper 并不是一个简单的应用，它有着非常优秀的交互效果，并且在产品设计和技术上都使用了许多前沿的技术，那就让我们看看，Paper 的开发到底有何不同之处？<br>交互设计<br>我们首先从产品设计上看 Paper 的不同之处。Paper 虽然只是一个新闻客户端，但从大家对 Paper 的评价上，我们发现优秀的交互再一次成为大家关注的焦点。回想那些成功的应用，大多都有着令人心动的交互效果，例如：Tweetie 的下拉刷新，现在基本上成为 iPhone 上内容刷新的标准。Path 跳出来的红心让人心动，很多朋友甚至会没事点那个红心，欣赏那流畅的按钮散开效果。还有 Mailbox，用流畅的手势操作，将邮件管理与任务管理完美结合起来。<br>国外成功的优秀应用也在影响着国内。交互设计不同于平面设计，不能简单地用 Photoshop 展现，而交互设计对于移动应用的成功又异常关键，所以需要花费不少时间来设计，因此产品经理很难兼顾地做交互设计。所以，在国内的一线互联网公司里，交互设计师这个职位慢慢成了移动应用的标配。但是在大部分的非一线互联网公司里面，移动开发的设计仍然停留在由产品经理简单潦草的完成阶段。所以，Facebook 这次 Paper 的成功发布，再一次给移动开发的从业者指出了交互设计的重要性。<br>回顾中国互联网产业的发展我们可以发现，产品经理（Product Manager）这个职位也是最近五、六年才成为互联网公司的标配的，想必在不远的将来，除着交互设计越来越重要，移动交互设计师也会成为每一个互联网公司重要的必备职位。<br>另一方面，由于工具的欠缺，大量的交互设计师的工作效率非常低下，他们为了做出一个新颖的效果常常需要花费大量精力。这次 Facebook 免费开放出基于苹果 Quartz Composer 的增强工具集 Origami，使得交互设计工作得到更好的辅助。而且在 Facebook 的带动下，jQC 1.0 也出现了。jQC 是一个与 Facebook 之前开源的 Origami 兼容的工具，提供了 15 个新的 Patch 来提高 Quartz Composer 的功能。<br>不过另一方面，该工具仍然需要设计师具备一定的基础编码能力，所以对于广大设计师来说，交互设计工具 Origami 对设计师带来的既是机会，同时也是挑战。<br>移动开发技术<br>随着 iOS 依赖管理工具 Cocoapods 和大量第三方开源库成熟起来，业界积累了大量的优秀开源项目。这次 Facebook 开发 Paper 使用了 将近 100 个第三方开源库，极大地减化了自己的应用开发任务。相信随着移动开发的发展，移动开发的生态圈会越来越成熟，基础的开源组件也将将越来越丰富，广大开发者都将从中受益。<br>另一方面，Facebook 的工程师在 Quora 上反馈 说 Paper 在 Xcode 下打开需要 40 多秒钟，编译一次需要 30 分钟。这反映出大量的开源库的使用也给 iOS 集成编译环境 Xcode 提出了新的挑战，相信苹果会花大力气解决 Xcode 的性能问题。<br>总结<br>Facebook 发布的 Paper 让我看到了移动开发领域的快速发展，大量新的工具和开源技术给了设计师和程序员机会和挑战，相信在移动互联网快速发展的浪潮中，会涌现出越来越多优秀的移动应用。谁会是未来移动互联网的霸主？让我们拭目以待。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2014/01/01/从Facebook看iOS移动端的开发/" data-id="cipfjlblp000he2s6dlwtkh9x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-用CocoaPods管理iOS程序" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/30/用CocoaPods管理iOS程序/" class="article-date">
  <time datetime="2013-12-30T13:43:15.000Z" itemprop="datePublished">2013-12-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/30/用CocoaPods管理iOS程序/">用CocoaPods管理iOS程序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>CocoaPods 简介<br>每种语言发展到一个阶段，就会出现相应的依赖管理工具，例如 Java 语言的 Maven，nodejs 的 npm。随着 iOS 开发者的增多，业界也出现了为 iOS 程序提供依赖管理的工具，它的名字叫做：CocoaPods。<br>CocoaPods项目的源码 在 Github 上管理。该项目开始于 2011 年 8 月 12 日，经过多年发展，现在已经成为 iOS 开发事实上的依赖管理标准工具。开发 iOS 项目不可避免地要使用第三方开源库，CocoaPods 的出现使得我们可以节省设置和更新第三方开源库的时间。<br>我在开发猿题库客户端时，使用了 24 个第三方开源库。在没有使用 CocoaPods 以前，我需要:<br>把这些第三方开源库的源代码文件复制到项目中，或者设置成 git 的 submodule。<br>对于这些开源库通常需要依赖系统的一些 framework，我需要手工地将这些 framework 分别增加到项目依赖中，比如通常情况下，一个网络库就需要增加以下 framework: CFNetwork, SystemConfiguration, MobileCoreServices, CoreGraphics, zlib。<br>对于某些开源库，我还需要设置-licucore或者 -fno-objc-arc等编译参数<br>管理这些依赖包的更新。<br>这些体力活虽然简单，但毫无技术含量并且浪费时间。在使用 CocoaPods 之后，我只需要将用到的第三方开源库放到一个名为 Podfile 的文件中，然后执行pod install。<br>CocoaPods 就会自动将这些第三方开源库的源码下载下来，并且为我的工程设置好相应的系统依赖和编译参数。<br>CocoaPods 的安装和使用介绍<br>安装<br>安装方式异常简单 , Mac 下都自带 ruby，使用 ruby 的 gem 命令即可下载安装：<br>$ sudo gem install cocoapods<br>$ pod setup<br>如果你的 gem 太老，可能也会有问题，可以尝试用如下命令升级 gem:<br>sudo gem update –system<br>另外，ruby 的软件源 <a href="https://rubygems.org" target="_blank" rel="external">https://rubygems.org</a> 因为使用的是亚马逊的云服务，所以被墙了，需要更新一下 ruby 的源，使用如下代码将官方的 ruby 源替换成国内淘宝的源：<br>gem sources –remove <a href="https://rubygems.org/" target="_blank" rel="external">https://rubygems.org/</a><br>gem sources -a <a href="https://ruby.taobao.org/" target="_blank" rel="external">https://ruby.taobao.org/</a><br>gem sources -l<br>还有一点需要注意，pod setup在执行时，会输出Setting up CocoaPods master repo，但是会等待比较久的时间。这步其实是 Cocoapods 在将它的信息下载到 ~/.cocoapods目录下，如果你等太久，可以试着 cd 到那个目录，用du -sh *来查看下载进度。你也可以参考本文接下来的使用 cocoapods 的镜像索引一节的内容来提高下载速度。<br>使用 CocoaPods 的镜像索引<br>所有的项目的 Podspec 文件都托管在<a href="https://github.com/CocoaPods/Specs。第一次执行pod" target="_blank" rel="external">https://github.com/CocoaPods/Specs。第一次执行pod</a> setup时，CocoaPods 会将这些podspec索引文件更新到本地的 ~/.cocoapods/目录下，这个索引文件比较大，有 80M 左右。所以第一次更新时非常慢，笔者就更新了将近 1 个小时才完成。<br>一个叫 akinliu 的朋友在 gitcafe 和 oschina 上建立了 CocoaPods 索引库的镜像，因为 gitcafe 和 oschina 都是国内的服务器，所以在执行索引更新操作时，会快很多。如下操作可以将 CocoaPods 设置成使用 gitcafe 镜像：</p>
<p>pod repo remove master<br>pod repo add master <a href="https://gitcafe.com/akuandev/Specs.git" target="_blank" rel="external">https://gitcafe.com/akuandev/Specs.git</a><br>pod repo update<br>将以上代码中的 <a href="https://gitcafe.com/akuandev/Specs.git" target="_blank" rel="external">https://gitcafe.com/akuandev/Specs.git</a> 替换成 <a href="http://git.oschina.net/akuandev/Specs.git" target="_blank" rel="external">http://git.oschina.net/akuandev/Specs.git</a> 即可使用 oschina 上的镜像。<br>使用 CocoaPods<br>使用时需要新建一个名为 Podfile 的文件，以如下格式，将依赖的库名字依次列在文件中即可<br>platform :ios<br>pod ‘JSONKit’,       ‘~&gt; 1.4’<br>pod ‘Reachability’,  ‘~&gt; 3.0.0’<br>pod ‘ASIHTTPRequest’<br>pod ‘RegexKitLite’<br>然后你将编辑好的 Podfile 文件放到你的项目根目录中，执行如下命令即可：<br>cd “your project home”<br>pod install<br>现在，你的所有第三方库都已经下载完成并且设置好了编译参数和依赖，你只需要记住如下 2 点即可：<br>使用 CocoaPods 生成的 .xcworkspace 文件来打开工程，而不是以前的 .xcodeproj 文件。<br>每次更改了 Podfile 文件，你需要重新执行一次pod update命令。<br>查找第三方库<br>你如果不知道 cocoaPods 管理的库中，是否有你想要的库，那么你可以通过 pod search 命令进行查找，以下是我用 pod search json 查找到的所有可用的库：<br>$ pod search json</p>
<p>-&gt; AnyJSON (0.0.1)<br>Encode / Decode JSON by any means possible.</p>
<ul>
<li>Homepage: <a href="https://github.com/mattt/AnyJSON" target="_blank" rel="external">https://github.com/mattt/AnyJSON</a></li>
<li>Source:   <a href="https://github.com/mattt/AnyJSON.git" target="_blank" rel="external">https://github.com/mattt/AnyJSON.git</a></li>
<li>Versions: 0.0.1 [master repo]</li>
</ul>
<p>-&gt; JSONKit (1.5pre)<br>A Very High Performance Objective-C JSON Library.</p>
<ul>
<li>Homepage: <a href="https://github.com/johnezang/JSONKit" target="_blank" rel="external">https://github.com/johnezang/JSONKit</a></li>
<li>Source:   git://github.com/johnezang/JSONKit.git</li>
<li>Versions: 1.5pre, 1.4 [master repo]</li>
</ul>
<p>// … 以下省略若干行<br>关于 Podfile.lock<br>当你执行pod install之后，除了 Podfile 外，CocoaPods 还会生成一个名为Podfile.lock的文件，Podfile.lock 应该加入到版本控制里面，不应该把这个文件加入到.gitignore中。因为Podfile.lock会锁定当前各依赖库的版本，之后如果多次执行pod install 不会更改版本，要pod update才会改Podfile.lock了。这样多人协作的时候，可以防止第三方库升级时造成大家各自的第三方库版本不一致。<br>CocoaPods 的这篇 官方文档 也在What is a Podfile.lock一节中介绍了Podfile.lock的作用，并且指出：<br>This file should always be kept under version control.<br>为自己的项目创建 podspec 文件<br>我们可以为自己的开源项目创建podspec文件，首先通过如下命令初始化一个podspec文件：<br>pod spec create your_pod_spec_name<br>该命令执行之后，CocoaPods 会生成一个名为your_pod_spec_name.podspec的文件，然后我们修改其中的相关内容即可。<br>具体步骤可以参考这两篇博文中的相关内容：<br>《如何编写一个 CocoaPods 的 spec 文件》<br>《Cocoapods 入门》。<br>使用私有的 pods<br>我们可以直接指定某一个依赖的podspec，这样就可以使用公司内部的私有库。该方案有利于使企业内部的公共项目支持 CocoaPods。如下是一个示例：<br>pod ‘MyCommon’, :podspec =&gt; ‘<a href="https://yuantiku.com/common/myCommon.podspec" target="_blank" rel="external">https://yuantiku.com/common/myCommon.podspec</a>‘<br>不更新 podspec<br>CocoaPods 在执行pod install和pod update时，会默认先更新一次podspec索引。使用–no-repo-update参数可以禁止其做索引更新操作。如下所示：<br>pod install –no-repo-update<br>pod update –no-repo-update<br>生成第三方库的帮助文档<br>如果你想让 CococaPods 帮你生成第三方库的帮助文档，并集成到 Xcode 中，那么用 brew 安装 appledoc 即可：<br>brew install appledoc<br>关于 appledoc，我在另一篇博客 《使用 Objective-C 的文档生成工具:appledoc》 中有专门介绍。它最大的优点是可以将帮助文档集成到 Xcode 中，这样你在敲代码的时候，按住 opt 键单击类名或方法名，就可以显示出相应的帮助文档。<br>原理<br>大概研究了一下 CocoaPods 的原理，它是将所有的依赖库都放到另一个名为 Pods 项目中，然后让主项目依赖 Pods 项目，这样，源码管理工作都从主项目移到了 Pods 项目中。发现的一些技术细节有：<br>Pods 项目最终会编译成一个名为 libPods.a 的文件，主项目只需要依赖这个 .a 文件即可。<br>对于资源文件，CocoaPods 提供了一个名为 Pods-resources.sh 的 bash 脚本，该脚本在每次项目编译的时候都会执行，将第三方库的各种资源文件复制到目标目录中。<br>CocoaPods 通过一个名为 Pods.xcconfig 的文件来在编译时设置所有的依赖和参数。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/30/用CocoaPods管理iOS程序/" data-id="cipfjlblj000ee2s6ktna6dd0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS开发如何提高" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/24/iOS开发如何提高/" class="article-date">
  <time datetime="2013-12-24T13:38:32.000Z" itemprop="datePublished">2013-12-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/24/iOS开发如何提高/">iOS开发如何提高</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>阅读博客<br>在现在这个碎片化阅读流行的年代，博客的风头早已被微博盖过。而我却坚持写作博客，并且大量地阅读同行的 iOS 开发博客。博客的文章长度通常在 3000 字左右，许多 iOS 开发知识都至少需要这样的篇幅才能完整地讲解清楚。并且博客相对于书籍来说，并没有较长的出版发行时间，所以阅读博客对于获取最新的 iOS 开发知识有着非常良好的效果。<br>我自己精心整理了国内 40 多位 iOS 开发博主的博客地址列表：<a href="https://github.com/tangqiaoboy/iOSBlogCN，希望大家都能培养起阅读博客的习惯。" target="_blank" rel="external">https://github.com/tangqiaoboy/iOSBlogCN，希望大家都能培养起阅读博客的习惯。</a><br>国外也有很多优秀的 iOS 开发博客，他们整体质量比中文的博客更高，以下是一些推荐的博客地址列表：<br>博客名                        博客地址<br>objc.io                       <a href="http://www.objc.io/" target="_blank" rel="external">http://www.objc.io/</a><br>Ray Wenderlich               <a href="http://www.raywenderlich.com" target="_blank" rel="external">http://www.raywenderlich.com</a><br>iOS Developer Tips           <a href="http://iosdevelopertips.com/" target="_blank" rel="external">http://iosdevelopertips.com/</a><br>iOS Dev Weekly               <a href="http://iosdevweekly.com/" target="_blank" rel="external">http://iosdevweekly.com/</a><br>NSHipster                   <a href="http://nshipster.com/" target="_blank" rel="external">http://nshipster.com/</a><br>Bartosz Ciechanowski       <a href="http://ciechanowski.me" target="_blank" rel="external">http://ciechanowski.me</a><br>Big Nerd Ranch Blog           <a href="http://blog.bignerdranch.com" target="_blank" rel="external">http://blog.bignerdranch.com</a><br>Nils Hayat    <a href="http://nilsou.com/" target="_blank" rel="external">http://nilsou.com/</a><br>另外，使用博客 RSS 聚合工具（例如 Feedly：<a href="http://www.feedly.com/）可以获得更好的博客阅读体验。手机上也有很多优秀的博客阅读工具（我使用的是" target="_blank" rel="external">http://www.feedly.com/）可以获得更好的博客阅读体验。手机上也有很多优秀的博客阅读工具（我使用的是</a> Newsify）。合理地使用这些工具也可以将你在地铁上、睡觉前等碎片时间充分利用上。<br>读书<br>博客的内容通常只能详细讲解一个知识点，而书籍则能成体系地介绍整个知识树。相比国外，中国的书籍售价相当便宜，所以这其实是一个非常划算的提高的方式。建议大家每年至少坚持读完 1 本高质量的 iOS 开发书籍。<br>去年出版的 《iOS 7 Programming Pushing the Limits》 以及 《Objective-C 高级编程：iOS 与 OS X 多线程和内存管理》 都算是不错的进阶方面的读物。顺便打个广告，我自己也在写一本 iOS 进阶方面的图书，年底前应该能上市。<br>看 WWDC 视频<br>由于 iOS 开发在快速发展，每年苹果都会给我们带来很多新的知识。而对于这些知识，第一手的资料就是 WWDC 的视频。<br>通常情况下，一个 iOS 开发的新知识首先会在 WWDC 上被苹果公开，然后 3 个月左右，会有国内外的博客介绍这些知识，再过半年左右，会有国外的图书介绍这些知识。所以如果想尽早地了解这些知识，那么只有通过 WWDC 的视频。<br>现在每年的 WWDC 视频都会在会议过程中逐步放出，重要的视频会带有英文字幕。坚持阅读这些视频不但可以获得最新的 iOS 开发知识，还可以提高英文听力水平。<br>看苹果的官方文档<br>苹果的官方文档相当详尽，对于不熟悉的 API，阅读官方文档也是最直接有效地方式。<br>苹果的文档比较海量，适合选一些重点来阅读，比如人机交互指南就是必读的，而其它的内容可以遇到的时候作为重点资源来查阅。<br>看开源项目的代码<br>大家一定有这样的感受，很多时候用文字讲解半天，还不如写几行代码来得直观。阅读优秀的开源项目代码，不但可以学习到 iOS 开发本身的基本知识，还能学习到设计模式等软件架构上的知识。<br>如果读者能够参与到开源项目的开发中，则能进一步提高自己的能力。<br>多写代码，多思考<br>知识的积累离不开实践和总结，我认为 iOS 代码量如果没有超过 10 万行，是不能称得上熟悉 iOS 开发的。某些在校的学生，仅仅做了几个 C++ 的大作业，就在求职简历里面写上 “精通 C++”，则真是让人哭笑不得。<br>在多写代码的同时，我们也要注意不要 “ 重复造轮子 “，尽量保证每次写的代码都能具有复用性。在代码结构因为业务需求需要变更时，及时重构，在不要留下技术债的同时，我们也要多思考如何设计应用架构，能够保证满足灵活多变的产品需求。<br>在多次重构和思考的过程中，我们就会慢慢积累出一类问题的 “最佳实践” 方式，成为自己宝贵的经验。<br>多和同行交流<br>有些时候遇到一些难解的技术问题，和同行的几句交流就可能让你茅塞顿开。。另外常见的技术问题通常都有人以前遇到过，简单指导几句就能让你一下子找到正确的解决方向。<br>国内开发者之间的交流，可以通过论坛，微博，QQ 群等方式来进行。另外各大公司有时候会办技术沙龙，这也是一个认识同行的好机会。<br>需要特别提醒的是，和国内开发者之前交流要注意讨论质量，有一些论坛和 QQ 群讨论质量相当低下，提的问题都是能通过简单 Google 获得的，这种社区一定要远离，以提高自己的沟通效率。<br>除了在国内的技术社区交流，建议读者可以去国外的 stackoverflow：<a href="http://www.stackoverflow.com" target="_blank" rel="external">http://www.stackoverflow.com</a> 上提问或回答问题。<br>分享<br>值得尝试的分享方式有：发起一个开源项目、写技术博客、在技术会议上做报告。这几种方式都比较有挑战，但是如果能大胆尝试，肯定会有巨大的收获。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/24/iOS开发如何提高/" data-id="cipfjlblh000de2s6z4e5al56" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="写ios-SDK注意问题小结" class="article article-type-写ios" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/14/SDK注意问题小结/" class="article-date">
  <time datetime="2013-12-14T13:35:15.000Z" itemprop="datePublished">2013-12-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/14/SDK注意问题小结/">SDK注意问题小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>我发现即使是像腾讯、小米这样的大厂提供的 SDK，在质量和规范上也有很多问题，而且包括我以及我身边的很多朋友都被恶心到了，所以我就把这些注意事项总结出来，希望大家不要犯同样的错误。<br>注意事项一：所有类名都应该加前缀<br>说明：没有前缀的类名有冲突的风险。<br>Bad Case：微信分享的 SDK，文件名：WXApiObject.h，代码如下，其中BaseReq类和BaseResp类都没有加前缀。<br>@interface BaseReq : NSObject</p>
<p>/<strong> 请求类型 */<br>@property (nonatomic, assign) int type;<br>/</strong> 由用户微信号和 AppID 组成的唯一标识，发送请求时第三方程序必须填写，用于校验微信用户是否换号登录 <em>/<br>@property (nonatomic, retain) NSString</em> openID;</p>
<p>@end</p>
<p>#pragma mark - BaseResp<br>/<em>! @brief 该类为微信终端 SDK 所有响应类的基类
</em><br><em>/<br>@interface BaseResp : NSObject<br>/** 错误码 </em>/<br>@property (nonatomic, assign) int errCode;<br>/<strong> 错误提示字符串 <em>/<br>@property (nonatomic, retain) NSString </em>errStr;<br>/</strong> 响应类型 */<br>@property (nonatomic, assign) int type;</p>
<p>@end<br>注意事项二：所有 category 方法加前缀<br>说明：category 方法如果不加前缀，有冲突的风险。<br>Bad Case：腾讯分享的 SDK，它为 NSArray 增加了一个 JSONArray 的 category，造成我们本身的同名 category 被覆盖。另外他们为 NSArray 增加的其它 category 和著名的 Cordova 开源库冲突，造成 Cordova 无法使用。<br>注意事项三：不要将第三方库打包进 SDK<br>说明：尽量不要将第三方库打包进 SDK，如果要打包，最好也要将该第三方库重命名，以避免冲突。<br>Bad Case：小米的推送 SDK，直接在 SDK 静态库里面编进去一个第三方依赖库，而且这个库还是 ASIHttpRequest。ASIHttp 当前已经处于无人维护状态，很多 Bug 都是大家自己在修复（例如网易就自己维护了一个 ASIHttpRequest 的分支）。在 SDK 中依赖这种库还是比较麻烦的。<br>注意事项四：做基本的检查和测试<br>说明：SDK 对外公布前应该进行基本的编译检查，不应该有编译器警告存在。<br>Bad Case：腾讯分享的 SDK。它的 CGIParamsWrap.o 和 TencentOAuth.o 文件里面的方法名冲突了，如下所示：<br>ld: warning: instance method ‘deleteAPIRequestBySeq:’ in category from /Users/tangqiao/work/iphone/solar-ios/lib_common/TencentOpenApi/TencentOpenAPI.framework/TencentOpenAPI(CGIParamsWrap.o) overrides method from class in /Users/tangqiao/work/iphone/solar-ios/lib_common/TencentOpenApi/TencentOpenAPI.framework/TencentOpenAPI(TencentOAuth.o)<br>注意事项五：文档完整并且正确<br>说明：这就不用解释了吧？<br>Bad Case: 微信官方的微信支付的示例代码，里面有各种错误，代码都无法编译成功。如下所示的是其中一个错误：</p>
<p>于是还有人专门帮微信另外制作了一个非官方的说明文档，地址在这里：<a href="https://github.com/gbammc/WechatPayDemo" target="_blank" rel="external">https://github.com/gbammc/WechatPayDemo</a><br>注意事项六：支持最新的 CPU 版本<br>说明：去年苹果的一次 Bug，造成上传应用必须支持 arm64 的 CPU 版本，结果众多应用因为依赖的 SDK 不支持 arm64 而无法更新。当然，这次 Bug 出来之后，各 SDK 厂商都紧急做了更新。但是我觉得这种事情如果要做得专业，就应该一开始就紧跟技术更新，及时更新，而不是被迫更新。<br>总结<br>以上 6 点是我认为写一个 SDK 的最最基本的要求，希望被点名批评的同学能尽快改正哟～<br>如果大家在使用其它 SDK 时也发现了类似的问题，欢迎在文章下面留言。希望通过这种方式给开发相关 SDK 的同学一些压力，让他们好好改一下。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/14/SDK注意问题小结/" data-id="cipfjlbl80009e2s6r9dw1lm0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-培训出来的iOS学员怎么了？" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/12/06/培训出来的iOS学员怎么了？/" class="article-date">
  <time datetime="2013-12-06T13:27:43.000Z" itemprop="datePublished">2013-12-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/12/06/培训出来的iOS学员怎么了？/">培训出来的iOS学员怎么了？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>今天就想和大家聊聊这个沉重的话题。<br>诚信的恶性循环<br>首先我们说说简历造假吧。在我看来，简历造假还是时常遇到的。我认识礼物说的 CTO，我们 iOS 群里常常有朋友面试时遇到说自己在礼物说工作过的候选人，为什么呢？还不是网上有一堆高仿礼物说的 APP，自己下载下来看看，然后就可以假装是自己做的了。<br>为什么很多候选人选择造假呢？除了简历不够好之外，造假很多时候确实有用。对于很多小公司来说，面试官自己也不懂如何面试 iOS 开发，那么就特别容易被忽悠。<br>但是，一个公司里面有 iOS 开发者，然后再稍微懂一些面试技巧的话，简历造假是很容易发现的。关于怎么在面试中鉴别造假，我们在下一节聊。<br>我们先聊聊看造假会造成什么危机呢？对于面试公司来说，如果他发现面试的效率特别低，或者招进来的人干活不行时，他会怎么办呢？<br>我觉得他会很直接地开地图炮，把一类人直接刷掉，不再给面试机会。这类人是哪些人？简历雷同的、培训机构培训出来的人。<br>这样公平吗？对候选人肯定不公平，但是公司招人也需要讲效率的，面试候选人其实成本特别高。<br>所以造假这个行为，最终伤害的是候选人本人，以及培训机构的信誉。<br>如何在面试中鉴别造假<br>其实挺简单的，首先面试的时候不要设置固定问题，然后根据候选人的回答情况来深入问细节。<br>就比如说一个候选人说他做过礼物说，那就有很多可以深入问的，比如问他：<br>礼物说有几个 iOS 开发<br>大家是如何分工的<br>你负责的那块最主要的难点在哪里<br>团队整个协作的过程<br>在开发的时候有没有遇到需求变更<br>功能上线后大概的数据是什么样的<br>你觉得哪些地方还需要改进<br>你们主要的竞争对手是谁，他们在哪些技术方面比你们做得好<br>一个谎话要编容易，难的是每一个细节都编得面面俱到，所以深入细节问，很容易就会露馅。<br>我是培训机构学员怎么办<br>简单地说，公司招一个人最终级的目的还是把活干好。如果一个培训机构的学员，没有实际的工作能力，单凭几个月的培训就想一劳永逸地找一份好工作，这是不现实的。<br>互联网技术日新月异，iOS 开发每年技术都在更新，如果指望所有知识都是从培训机构那儿获得，那么早晚都会被淘汰。<br>所以，即使你当前是培训机构出来的学员，也必须培养自己实际解决问题的能力和自学能力。这样才能一点点地增强自己的实力。<br>另外说一个残酷的现实，公司一般不会给你大块的上班时间用来学习新知识的。所以大多数学习充电过程只能是在下班后或周末。<br>我们应该怎么看待培训机构学员<br>我自己就招过一个培训机构出来的学员，她还是一个女生，现在工作得挺棒的。她是非计算机专业毕业的，参加培训机构学了 3 个月就来我们公司面试。她能通过面试，很大程度上是因为她不止参加了培训班的课，而且自己在网上学习了计算机数据结构和算法的基础知识，而且是看的国外的课程。<br>当时面试时我完全没有考查她 iOS 知识，因为她承认只参加了 3 个月的培训。所以我考查了一下她自学数据结构和算法的情况。结果让我觉得她是一个自学能力还不错的女生，所以我就把她招了进来。<br>刚进来带她做 iOS 费了一些精力，但是很快她就可以上手自己做事情了。现在，我已经完全把小猿搜题的 iOS 端交给她来负责。我想她就是一个培训机构出来学员的成功案例。<br>我们并不鄙视培训机构的学生，但是我们不认同那些没有自学能力，认为参加 3 个月培训就可以拿高薪的「投机者」。这个行业虽然高薪，但是也很辛苦，如果没有兴趣和毅力，是没办法做好的。<br>搞 iOS 开发到底需要什么核心能力<br>大家看了我上次采访的 YYKit 作者的文章 后，或许就能明白，其实一个人核心的能力就是学习能力。有强大的学习能力，那么就可以像 YYKit 作者那样，才接触 iOS 开发一年多就可以开源出大量优秀的作品。<br>基本上，一个人在一个领域坚持投入大量的时间，很难做得不好。所以你是一个培训机构的学员，苦于找不到工作。与其简历造假拿到面试机会，倒不如再多花花精力，自己多专研一些代码，写一些 App，不要那么急功近利，我想结果都会好很多。<br>愿培训机构出来的 iOS 学员都能找一份好工作。</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/12/06/培训出来的iOS学员怎么了？/" data-id="cipfjlbln000ge2s6uogwfu5y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS-Runtime全方位装逼小结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2013/11/27/iOS-Runtime全方位装逼小结/" class="article-date">
  <time datetime="2013-11-27T13:10:55.000Z" itemprop="datePublished">2013-11-27</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/11/27/iOS-Runtime全方位装逼小结/">iOS_Runtime全方位装逼小结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><span></span></p>
<p>楔子<br>Runtime是什么？见名知意，其概念无非就是“因为 Objective-C 是一门动态语言，所以它需要一个运行时系统……这就是 Runtime 系统”云云。对博主这种菜鸟而言，Runtime 在实际开发中，其实就是一组C语言的函数。胡适说：“多研究些问题，少谈些主义”，云山雾罩的概念听多了总是容易头晕，接下来我们直接从代码入手学习 Runtime。</p>
<p>1、由objc_msgSend说开去：<br>Objective-C 中的方法调用，不是简单的方法调用，而是发送消息，也就是说，其实 [receiver message] 会被编译器转化为: objc_msgSend(receiver, selector)，何以证明？新建一个类 MyClass，其.m文件如下：</p>
<p>#import “MyClass.h”<br>@implementation MyClass</p>
<p>-(instancetype)init{<br>if (self = [super init]) {<br>[self showUserName];<br>}<br>return self;<br>}</p>
<p>-(void)showUserName{<br>NSLog(@”Dave Ping”);<br>}<br>使用 clang 重写命令:</p>
<p>$ clang -rewrite-objc MyClass.m<br>然后在同一目录下会多出一个 MyClass.cpp 文件，双击打开，可以看到 init 方法已经被编译器转化为下面这样：</p>
<p>static instancetype _I_MyClass_init(MyClass <em> self, SEL _cmd) {<br>if (self = ((MyClass </em>(<em>)(__rw_objc_super </em>, SEL))(void <em>)objc_msgSendSuper)((__rw_objc_super){(id)self, (id)class_getSuperclass(objc_getClass(“MyClass”))}, sel_registerName(“init”))) {<br>((void (</em>)(id, SEL))(void *)objc_msgSend)((id)self, sel_registerName(“showUserName”));<br>}<br>return self;<br>}<br>我们要找的就是它：</p>
<p>((void (<em>)(id, SEL))(void </em>)objc_msgSend)((id)self, sel_registerName(“showUserName”))<br>objc_msgSend 函数被定义在 objc/message.h 目录下，其函数原型是酱紫滴：</p>
<p>OBJC_EXPORT void objc_msgSend(void /<em> id self, SEL op, … </em>/ )<br>该函数有两个参数，一个 id 类型，一个 SEL 类型。</p>
<p>2、SEL<br>SEL 被定义在 objc/objc.h 目录下：</p>
<p>typedef struct objc_selector *SEL;<br>其实它就是个映射到方法的C字符串，你可以用 Objective-C 编译器命令 @selector() 或者 Runtime 系统的 sel_registerName 函数来获得一个 SEL 类型的方法选择器。</p>
<p>3、id<br>与 SEL 一样，id 也被定义在 objc/objc.h 目录下：</p>
<p>typedef struct objc_object *id;<br>id 是一个结构体指针类型，它可以指向 Objective-C 中的任何对象。objc_object 结构体定义如下：</p>
<p>struct objc_object { Class isa OBJC_ISA_AVAILABILITY;};<br>我们通常所说的对象，就长这个样子，这个结构体只有一个成员变量 isa，对象可以通过 isa 指针找到其所属的类。isa 是一个 Class 类型的成员变量，那么 Class 又是什么呢？</p>
<p>4、Class<br>Class 也是一个结构体指针类型：</p>
<p>typedef struct objc_class *Class;<br>objc_class 结构体是酱紫滴：</p>
<p>struct objc_class {<br>Class isa  OBJC_ISA_AVAILABILITY;</p>
<p>#if !<strong>OBJC2</strong><br>Class super_class                                        OBJC2_UNAVAILABLE;<br>const char <em>name                                         OBJC2_UNAVAILABLE;<br>long version                                             OBJC2_UNAVAILABLE;<br>long info                                                OBJC2_UNAVAILABLE;<br>long instance_size                                       OBJC2_UNAVAILABLE;<br>struct objc_ivar_list </em>ivars                             OBJC2_UNAVAILABLE;<br>struct objc_method_list <em>*methodLists                    OBJC2_UNAVAILABLE;<br>struct objc_cache </em>cache                                 OBJC2_UNAVAILABLE;<br>struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;</p>
<p>#endif</p>
<p>} OBJC2_UNAVAILABLE;<br>我们通常说的类就长这样子：<br>·Class 也有一个 isa 指针，指向其所属的元类（meta）.<br>·super_class：指向其超类.<br>·name：是类名.<br>·version：是类的版本信息.<br>·info：是类的详情.<br>·instance_size：是该类的实例对象的大小.<br>·ivars：指向该类的成员变量列表.<br>·methodLists：指向该类的实例方法列表，它将方法选择器和方法实现地址联系起来。methodLists 是指向 ·objc_method_list 指针的指针，也就是说可以动态修改 *methodLists 的值来添加成员方法，这也是 Category 实现的原理，同样解释了 Category 不能添加属性的原因.<br>·cache：Runtime 系统会把被调用的方法存到 cache 中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高.<br>·protocols：指向该类的协议列表.</p>
<p>说到这里有点乱了，我们来捋一下，当我们调用一个方法时，其运行过程大致如下：</p>
<p>首先，Runtime 系统会把方法调用转化为消息发送，即 objc_msgSend，并且把方法的调用者，和方法选择器，当做参数传递过去.</p>
<p>此时，方法的调用者会通过 isa 指针来找到其所属的类，然后在 cache 或者 methodLists 中查找该方法，找得到就跳到对应的方法去执行.</p>
<p>如果在类中没有找到该方法，则通过 super_class 往上一级超类查找（如果一直找到 NSObject 都没有找到该方法的话，这种情况，我们放到后面消息转发的时候再说）.</p>
<p>前面我们说 methodLists 指向该类的实例方法列表，实例方法即-方法，那么类方法（+方法）存储在哪儿呢？类方法被存储在元类中，Class 通过 isa 指针即可找到其所属的元类.</p>
<p>上图实线是 super_class 指针，虚线是 isa 指针。根元类的超类是NSObject，而 isa 指向了自己。NSObject 的超类为 nil，也就是它没有超类。</p>
<p>5、使用objc_msgSend<br>前面我们使用 clang 重写命令，看到 Runtime 是如何将方法调用转化为消息发送的。我们也可以依样画葫芦，来学习使用一下 objc_msgSend。新建一个类 TestClass，添加如下方法：</p>
<p>-(void)showAge{<br>NSLog(@”24”);<br>}</p>
<p>-(void)showName:(NSString *)aName{<br>NSLog(@”name is %@”,aName);<br>}</p>
<p>-(void)showSizeWithWidth:(float)aWidth andHeight:(float)aHeight{<br>NSLog(@”size is %.2f * %.2f”,aWidth, aHeight);<br>}</p>
<p>-(float)getHeight{<br>return 187.5f;<br>}</p>
<p>-(NSString *)getInfo{<br>return @”Hi, my name is Dave Ping, I’m twenty-four years old in the year, I like apple, nice to meet you.”;<br>}<br>我们可以像下面这样，使用 objc_msgSend 依次调用这些方法：</p>
<p>TestClass *objct = [[TestClass alloc] init];</p>
<p>((void (*) (id, SEL)) objc_msgSend) (objct, sel_registerName(“showAge”));</p>
<p>((void (<em>) (id, SEL, NSString </em>)) objc_msgSend) (objct, sel_registerName(“showName:”), @”Dave Ping”);</p>
<p>((void (*) (id, SEL, float, float)) objc_msgSend) (objct, sel_registerName(“showSizeWithWidth:andHeight:”), 110.5f, 200.0f);</p>
<p>float f = ((float (*) (id, SEL)) objc_msgSend_fpret) (objct, sel_registerName(“getHeight”));<br>NSLog(@”height is %.2f”,f);</p>
<p>NSString <em>info = ((NSString</em> (*) (id, SEL)) objc_msgSend) (objct, sel_registerName(“getInfo”));<br>NSLog(@”%@”,info);<br>也许你已经注意到，objc_msgSend 在使用时都被强制转换了一下，这是因为 objc_msgSend 函数可以hold住各种不同的返回值以及多个参数，但默认情况下是没有参数和返回值的。如果我们把调用 showAge 方法改成这样：</p>
<p>objc_msgSend(objct, sel_registerName(“showAge”));<br>Xcode 就会报错：</p>
<p>Too many arguments to function call, expected 0, have 2.<br>完整的 objc_msgSend 使用代码在这里。</p>
<p>6、objc_msgSendSuper<br>编译器会根据情况在 objc_msgSend，objc_msgSend_stret，objc_msgSendSuper，objc_msgSendSuper_stret 或 objc_msgSend_fpret 五个方法中选择一个来调用。如果消息是传递给超类，那么会调用 objc_msgSendSuper 方法，如果消息返回值是数据结构，就会调用 objc_msgSendSuper_stret 方法，如果返回值是浮点数，则调用 objc_msgSend_fpret 方法。</p>
<p>这里我们重点说一下 objc_msgSendSuper，objc_msgSendSuper 函数原型如下：</p>
<p>OBJC_EXPORT void objc_msgSendSuper(void /<em> struct objc_super </em>super, SEL op, … */ )<br>当我们调用 [super selector] 时，Runtime 会调用 objc_msgSendSuper 方法，objc_msgSendSuper 方法有两个参数，super 和 op，Runtime 会把 selector 方法选择器赋值给 op。而 super 是一个 objc_super 结构体指针，objc_super 结构体定义如下：</p>
<p>struct objc_super {<br>/// Specifies an instance of a class.<br>__unsafe_unretained id receiver;</p>
<p>/// Specifies the particular superclass of the instance to message. </p>
<p>#if !defined(<strong>cplusplus)  &amp;  !</strong>OBJC2<strong><br>/<em> For compatibility with old objc-runtime.h header </em>/
</strong>unsafe_unretained Class class;</p>
<p>#else<br>__unsafe_unretained Class super_class;</p>
<p>#endif<br>/<em> super_class is the first class to search </em>/<br>};<br>Runtime 会创建一个 objc_spuer 结构体变量，将其地址作为参数（super）传递给 objc_msgSendSuper，并且将 self 赋值给 receiver：super—&gt;receiver=self.<br>举个栗子，问下面的代码输出什么：</p>
<p>@implementation Son : Father</p>
<ul>
<li>(id)init<br>{<br>self = [super init];<br>if (self)<br>{<br>NSLog(@”%@”, NSStringFromClass([self class]));<br>NSLog(@”%@”, NSStringFromClass([super class]));<br>}<br>return self;<br>}<br>@end<br>答案是全部输出 Son.<br>使用 clang 重写命令，发现上述代码被转化为:</li>
</ul>
<p>NSLog((NSString <em>)&amp;<strong>NSConstantStringImpl</strong>var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_0, NSStringFromClass(((Class (</em>)(id, SEL))(void <em>)objc_msgSend)((id)self, sel_registerName(“class”))));<br>NSLog((NSString </em>)&amp;<strong>NSConstantStringImpl</strong>var_folders_gm_0jk35cwn1d3326x0061qym280000gn_T_main_a5cecc_mi_1, NSStringFromClass(((Class (<em>)(__rw_objc_super </em>, SEL))(void *)objc_msgSendSuper)((__rw_objc_super){ (id)self, (id)class_getSuperclass(objc_getClass(“Son”)) }, sel_registerName(“class”))));<br>当调用 [super class] 时，会转换成 objc_msgSendSuper 函数：</p>
<p>第一步先构造 objc_super 结构体，结构体第一个成员就是 self。第二个成员是 (id)class_getSuperclass(objc_getClass(“Son”)).</p>
<p>第二步是去 Father 这个类里去找 – (Class)class，没有，然后去 NSObject 类去找，找到了。最后内部是使用 objc_msgSend(objc_super-&gt;receiver, @selector(class)) 去调用，此时已经和 [self class] 调用相同了，所以两个输出结果都是 Son。</p>
<p>7、对象关联<br>对象关联允许开发者对已经存在的类在 Category 中添加自定义的属性：</p>
<p>OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) <strong>OSX_AVAILABLE_STARTING(</strong>MAC_10_6, __IPHONE_3_1);<br>·object 是源对象.<br>·value 是被关联的对象.<br>·key 是关联的键，objc_getAssociatedObject 方法通过不同的 key 即可取出对应的被关联对象.<br>·policy 是一个枚举值，表示关联对象的行为，从命名就能看出各个枚举值的含义：</p>
<p>typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) {<br>OBJC_ASSOCIATION_ASSIGN = 0,           /**<br>要取出被关联的对象使用 objc_getAssociatedObject 方法即可，要删除一个被关联的对象，使用 objc_setAssociatedObject 方法将对应的 key 设置成 nil 即可：</p>
<p>objc_setAssociatedObject(self, associatedKey, nil, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>objc_removeAssociatedObjects 方法将会移除源对象中所有的关联对象.<br>举个栗子，假如我们要给 UIButton 添加一个监听单击事件的 block 属性，新建 UIButton 的 Category，其.m文件如下：</p>
<p>#import “UIButton+ClickBlock.h”</p>
<p>#import </p>
<p>static const void *associatedKey = “associatedKey”;</p>
<p>@implementation UIButton (ClickBlock)</p>
<p>//Category中的属性，只会生成setter和getter方法，不会生成成员变量</p>
<p>-(void)setClick:(clickBlock)click{<br>objc_setAssociatedObject(self, associatedKey, click, OBJC_ASSOCIATION_COPY_NONATOMIC);<br>[self removeTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];<br>if (click) {<br>[self addTarget:self action:@selector(buttonClick) forControlEvents:UIControlEventTouchUpInside];<br>}<br>}</p>
<p>-(clickBlock)click{<br>return objc_getAssociatedObject(self, associatedKey);<br>}</p>
<p>-(void)buttonClick{<br>if (self.click) {<br>self.click();<br>}<br>}</p>
<p>@end<br>然后在代码中，就可以使用 UIButton 的属性来监听单击事件了：</p>
<p>UIButton *button = [UIButton buttonWithType:UIButtonTypeCustom];<br>button.frame = self.view.bounds;<br>[self.view addSubview:button];<br>button.click = ^{<br>NSLog(@”buttonClicked”);<br>};<br>完整的对象关联代码点这里</p>
<p>8、自动归档<br>博主在学习 Runtime 之前，归档的时候是酱紫写的：</p>
<ul>
<li><p>(void)encodeWithCoder:(NSCoder *)aCoder{<br>[aCoder encodeObject:self.name forKey:@”name”];<br>[aCoder encodeObject:self.ID forKey:@”ID”];<br>}</p>
</li>
<li><p>(id)initWithCoder:(NSCoder *)aDecoder{<br>if (self = [super init]) {<br>self.ID = [aDecoder decodeObjectForKey:@”ID”];<br>self.name = [aDecoder decodeObjectForKey:@”name”];<br>}<br>return self;<br>}<br>那么问题来了，如果当前 Model 有100个属性的话，就需要写100行这种代码：</p>
</li>
</ul>
<p>[aCoder encodeObject:self.name forKey:@”name”];<br>想想都头疼，通过 Runtime 我们就可以轻松解决这个问题：<br>1.使用 class_copyIvarList 方法获取当前 Model 的所有成员变量.<br>2.使用 ivar_getName 方法获取成员变量的名称.<br>3.通过 KVC 来读取 Model 的属性值（encodeWithCoder:），以及给 Model 的属性赋值（initWithCoder:）.</p>
<p>举个栗子，新建一个 Model 类，其.m文件如下：</p>
<p>#import “TestModel.h”</p>
<p>#import </p>
<p>#import </p>
<p>@implementation TestModel</p>
<ul>
<li>(void)encodeWithCoder:(NSCoder <em>)aCoder{<br>unsigned int outCount = 0;<br>Ivar </em>vars = class_copyIvarList([self class], &amp;outCount);<br>for (int i = 0; i<br>完整的自动归档代码在这里</li>
</ul>
<p>9、字典与模型互转<br>最开始博主是这样用字典给 Model 赋值的：</p>
<p>-(instancetype)initWithDictionary:(NSDictionary *)dict{<br>if (self = [super init]) {<br>self.age = dict[@”age”];<br>self.name = dict[@”name”];<br>}<br>return self;<br>}<br>可想而知，遇到的问题跟归档时候一样（后来使用MJExtension），这里我们稍微来学习一下其中原理，字典转模型的时候：<br>1.根据字典的 key 生成 setter 方法.<br>2.使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）.</p>
<p>模型转字典的时候：<br>1.调用 class_copyPropertyList 方法获取当前 Model 的所有属性.<br>2.调用 property_getName 获取属性名称.<br>3.根据属性名称生成 getter 方法.<br>4.使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）.</p>
<p>代码如下：</p>
<p>#import “NSObject+KeyValues.h”</p>
<p>#import </p>
<p>#import </p>
<p>@implementation NSObject (KeyValues)</p>
<p>//字典转模型<br>+(id)objectWithKeyValues:(NSDictionary <em>)aDictionary{<br>id objc = [[self alloc] init];<br>for (NSString </em>key in aDictionary.allKeys) {<br>id value = aDictionary[key];</p>
<p>/<em>判断当前属性是不是Model</em>/<br>objc_property_t property = class_getProperty(self, key.UTF8String);<br>unsigned int outCount = 0;<br>objc_property_attribute_t <em>attributeList = property_copyAttributeList(property, &amp;outCount);<br>objc_property_attribute_t attribute = attributeList[0];<br>NSString </em>typeString = [NSString stringWithUTF8String:attribute.value];<br>if ([typeString isEqualToString:@”@”TestModel””]) {<br>value = [self objectWithKeyValues:value];<br>}<br>/<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>/</p>
<p>//生成setter方法，并用objc_msgSend调用<br>NSString <em>methodName = [NSString stringWithFormat:@”set%@%@:”,[key substringToIndex:1].uppercaseString,[key substringFromIndex:1]];<br>SEL setter = sel_registerName(methodName.UTF8String);<br>if ([objc respondsToSelector:setter]) {<br>((void (</em>) (id,SEL,id)) objc_msgSend) (objc,setter,value);<br>}<br>}<br>return objc;<br>}</p>
<p>//模型转字典<br>-(NSDictionary <em>)keyValuesWithObject{<br>unsigned int outCount = 0;<br>objc_property_t </em>propertyList = class_copyPropertyList([self class], &amp;outCount);<br>NSMutableDictionary *dict = [NSMutableDictionary dictionary];<br>for (int i = 0; i<br>完整代码在这里</p>
<p>10、动态方法解析<br>前面我们留下了一点东西没说，那就是如果某个对象调用了不存在的方法时会怎么样，一般情况下程序会crash，错误信息类似下面这样：</p>
<p>unrecognized selector sent to instance 0x7fd0a141afd0<br>但是在程序crash之前，Runtime 会给我们动态方法解析的机会，消息发送的步骤大致如下：</p>
<p>1.检测这个 selector 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 retain，release 这些函数了.</p>
<p>2.检测这个 target 是不是 nil 对象。ObjC 的特性是允许对一个 nil 对象执行任何一个方法不会 Crash，因为会被忽略掉.</p>
<p>3.如果上面两个都过了，那就开始查找这个类的 IMP，先从 cache 里面找，完了找得到就跳到对应的函数去执行.<br>如果 cache 找不到就找一下方法分发表.</p>
<p></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2013/11/27/iOS-Runtime全方位装逼小结/" data-id="cipfjlbl10007e2s6wvwbgaky" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">January 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/10/">October 2013</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/09/">September 2013</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/01/22/Bilibili开源的直播框架/">Bilibili开源的直播框架</a>
          </li>
        
          <li>
            <a href="/2016/01/14/iOS三种视屏录制方式/">iOS三种视屏录制方式</a>
          </li>
        
          <li>
            <a href="/2014/01/20/iOS中使用ZXing库/">iOS中使用ZXing库</a>
          </li>
        
          <li>
            <a href="/2014/01/14/iOS应用内支付小结/">iOS应用内支付小结</a>
          </li>
        
          <li>
            <a href="/2014/01/01/从Facebook看iOS移动端的开发/">从Facebook看iOS移动端的开发</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>